* 数据结构

** dlm_lkb
   - 它对应一个锁,请求锁住资源或解锁
     #+begin_src 
	struct dlm_rsb		*lkb_resource;	/* the rsb */
	struct kref		lkb_ref;
	int			lkb_nodeid;	/* copied from rsb */ //发起锁的node?
	int			lkb_ownpid;	/* pid of lock owner */
	uint32_t		lkb_id;		/* our lock ID */
	uint32_t		lkb_remid;	/* lock ID on remote partner */ //为什么不是lkb_nodeid
	uint32_t		lkb_exflags;	/* external flags from caller */
	uint32_t		lkb_sbflags;	/* lksb flags */
	uint32_t		lkb_flags;	/* internal flags */
	uint32_t		lkb_lvbseq;	/* lvb sequence number */

	int8_t			lkb_status;     /* granted, waiting, convert */
	int8_t			lkb_rqmode;	/* requested lock mode */
	int8_t			lkb_grmode;	/* granted lock mode */
	int8_t			lkb_highbast;	/* highest mode bast sent for */

	int8_t			lkb_wait_type;	/* type of reply waiting for */
	int8_t			lkb_wait_count;
	int			lkb_wait_nodeid; /* for debugging */

	struct list_head	lkb_statequeue;	/* rsb g/c/w list */
	struct list_head	lkb_rsb_lookup;	/* waiting for rsb lookup */
	struct list_head	lkb_wait_reply;	/* waiting for remote reply */
	struct list_head	lkb_ownqueue;	/* list of locks for a process */
	struct list_head	lkb_time_list;
	ktime_t			lkb_timestamp;
	ktime_t			lkb_wait_time;
	unsigned long		lkb_timeout_cs;

	struct mutex		lkb_cb_mutex;
	struct work_struct	lkb_cb_work;
	struct list_head	lkb_cb_list; /* for ls_cb_delay or proc->asts */
	struct dlm_callback	lkb_callbacks[DLM_CALLBACKS_SIZE];
	struct dlm_callback	lkb_last_cast;
	struct dlm_callback	lkb_last_bast;
	ktime_t			lkb_last_cast_time;	/* for debugging */
	ktime_t			lkb_last_bast_time;	/* for debugging */

	uint64_t		lkb_recover_seq; /* from ls_recover_seq */

	char			*lkb_lvbptr;
	struct dlm_lksb		*lkb_lksb;      /* caller's status block */
	void			(*lkb_astfn) (void *astparam);
	void			(*lkb_bastfn) (void *astparam, int mode);
	union {
		void			*lkb_astparam;	/* caller's ast arg */
		struct dlm_user_args	*lkb_ua;
	};
     #+end_src

** dlm_rsb
   - 被锁的资源
     #+begin_src 
	struct dlm_ls		*res_ls;	/* the lockspace */
	struct kref		res_ref;
	struct mutex		res_mutex;
	unsigned long		res_flags;
	int			res_length;	/* length of rsb name */
	int			res_nodeid;  //如果>0, 表示锁的master, 而且不是local; 如果=0,master是local; 如果是-1,表示没有找到master; 其他的无效
	int			res_master_nodeid;
	int			res_dir_nodeid;
	int			res_id;		/* for ls_recover_idr */
	uint32_t                res_lvbseq;
	uint32_t		res_hash;
	uint32_t		res_bucket;	/* rsbtbl */
	unsigned long		res_toss_time;
	uint32_t		res_first_lkid;
	struct list_head	res_lookup;	/* lkbs waiting on first */
	union {
		struct list_head	res_hashchain;
		struct rb_node		res_hashnode;	/* rsbtbl */
	};
	struct list_head	res_grantqueue;
	struct list_head	res_convertqueue;
	struct list_head	res_waitqueue;

	struct list_head	res_root_list;	    /* used for recovery */
	struct list_head	res_recover_list;   /* used for recovery */
	int			res_recover_locks_count;

	char			*res_lvbptr;
	char			res_name[DLM_RESNAME_MAXLEN+1];     
     #+end_src

* lock.c
  - 锁操作分成4种:请求锁/request,转换锁/convert,释放锁/unlock,取消锁操作/cancel
  - 一般每个操作分4个过程
    - 检查输入参数,根据参数调用上面4种操作
    - 找到锁的对象dlm_rsb
    - 如果是remote锁,发送锁请求
    - do_lock,执行锁的操作

** dlm_lvb_operations[8][8]
   - 数组表示dlm_lvb的操作,一般情况在锁升级操作时才会获取lvb,在锁降级时设置lvb

** dlm_lkb
   #+begin_src 
	//奇怪,这里的数据结构格外大
	struct dlm_rsb		*lkb_resource;	/* the rsb */
	struct kref		lkb_ref;
	int			lkb_nodeid;	/* copied from rsb */
	int			lkb_ownpid;	/* pid of lock owner */
	uint32_t		lkb_id;		/* our lock ID */
	uint32_t		lkb_remid;	/* lock ID on remote partner */
	uint32_t		lkb_exflags;	/* external flags from caller */
	uint32_t		lkb_sbflags;	/* lksb flags */
	uint32_t		lkb_flags;	/* internal flags */
	uint32_t		lkb_lvbseq;	/* lvb sequence number */

	int8_t			lkb_status;     /* granted, waiting, convert */
	int8_t			lkb_rqmode;	/* requested lock mode */
	int8_t			lkb_grmode;	/* granted lock mode */
	int8_t			lkb_highbast;	/* highest mode bast sent for */

	int8_t			lkb_wait_type;	/* type of reply waiting for */
	int8_t			lkb_wait_count;
	int			lkb_wait_nodeid; /* for debugging */

	struct list_head	lkb_statequeue;	/* rsb g/c/w list */
	struct list_head	lkb_rsb_lookup;	/* waiting for rsb lookup */
	struct list_head	lkb_wait_reply;	/* waiting for remote reply */
	struct list_head	lkb_ownqueue;	/* list of locks for a process */
	struct list_head	lkb_time_list;
	ktime_t			lkb_timestamp;
	ktime_t			lkb_wait_time;
	unsigned long		lkb_timeout_cs;

	struct mutex		lkb_cb_mutex;
	struct work_struct	lkb_cb_work;
	struct list_head	lkb_cb_list; /* for ls_cb_delay or proc->asts */
	struct dlm_callback	lkb_callbacks[DLM_CALLBACKS_SIZE];
	struct dlm_callback	lkb_last_cast;
	struct dlm_callback	lkb_last_bast;
	ktime_t			lkb_last_cast_time;	/* for debugging */
	ktime_t			lkb_last_bast_time;	/* for debugging */

	uint64_t		lkb_recover_seq; /* from ls_recover_seq */

	char			*lkb_lvbptr;
	struct dlm_lksb		*lkb_lksb;      /* caller's status block */
	void			(*lkb_astfn) (void *astparam);
	void			(*lkb_bastfn) (void *astparam, int mode);
	union {
		void			*lkb_astparam;	/* caller's ast arg */
		struct dlm_user_args	*lkb_ua;
	};
   
   #+end_src

** dlm_rsb 
   #+begin_src 
	struct dlm_ls		*res_ls;	/* the lockspace */
	struct kref		res_ref;
	struct mutex		res_mutex;
	unsigned long		res_flags;
	int			res_length;	/* length of rsb name */
	int			res_nodeid;
	int			res_master_nodeid;
	int			res_dir_nodeid;
	int			res_id;		/* for ls_recover_idr */
	uint32_t                res_lvbseq;
	uint32_t		res_hash;
	uint32_t		res_bucket;	/* rsbtbl */
	unsigned long		res_toss_time;
	uint32_t		res_first_lkid;
	struct list_head	res_lookup;	/* lkbs waiting on first */
	union {
		struct list_head	res_hashchain;
		struct rb_node		res_hashnode;	/* rsbtbl */
	};
	struct list_head	res_grantqueue;
	struct list_head	res_convertqueue;
	struct list_head	res_waitqueue;

	struct list_head	res_root_list;	    /* used for recovery */
	struct list_head	res_recover_list;   /* used for recovery */
	int			res_recover_locks_count;

	char			*res_lvbptr;
	char			res_name[DLM_RESNAME_MAXLEN+1];   
   #+end_src

** is_granted(dlm_lkb)
   - 使用dlm_lkb->lkb_status和lkb_sbflags表示他的状态和属性

** queue_cast(dlm_rsb, dlm_lkb, rv)
   - 检查dlm_lbk->lkb_flags & DLM_IFL_MSTCPY, master是本地的?
   > is_master_copy(dlm_lkb)
   - 删除计时器 dlm_lkb->lkb_time_list
   > del_timeout(dlm_lbk)
   - rv表示锁操作类型,如果是DLM_ECANCEL, 而且dlm_lkb->lkb_flags & DLM_IFL_TIMEOUT_CANCEL, 设置rv=ETIMEOUT
   - 如果dlm_lkb->lkb_flags & DLM_IFL_DEADLOCK_CANCEL, 设置rv = EDEADLK
   - 创建dlm_callback
   > dlm_add_cb(dlm_lkb, DLM_CB_CAST, dlm_lkb->lkb_grmode, rv, dlm_lkb->lkb_sbflags)

** queue_cast_overlap(dlm_rsb, dlm_lkb)
   - 添加dlm_callback, 怎么就2中类型?
   > queeu_cast(dlm_rsb, dlm_lkb, is_overlap_unlock(dlm_lkb)?DLM_EUNLOCK:DLM_ECANCEL

** queue_bast(dlm_rsb, dlm_lkb, rqmode)
   - master?  就去发送给别的node?
   > send_bast(dlm_rsb, dlm_lkb, rqmode)
   - 否则,放到dlm_lkb队列中
   > dlm_add_cb(dlm_lkb, DLM_CB_BAST, rqmode, 0, 0)

** hold_rsb(dlm_rsb)
   - 使用dlm_rsb->ref_ref管理使用计数  kobject

** dlm_hold_rsb(dlm_rsb)
   > hold_rsb(dlm_rsb)

** put_rsb(dlm_rsb)
   - 使用kobject释放? 
   > kref_put(dlm_ref->res_ref, toss_rsb)

** dlm_put_rsb(dlm_rsb)
   - put_rsb(dlm_rsb)

** pre_rsb_struct(dlm_ls)
   - 提前创建dlm_rsb
   - 如果dlm_ls->ls_new_rsb_count > dlm_config->ci_new_rsb_count / 2, 直接返回
   - 创建2个,放到dlm_ls->ls_new_rsb队列, 使用dlm_rsb->res_hashchina
   > dlm_allocate_rsb(dlm_ls)
   - 增加dlm_ls->ls_new_rsb_count

** get_rsb_count(dlm_ls, name, len, dlm_rsb)
   - 创建dlm_rsb,他使用提前创建的dlm_ls->ls_new_rsb中的
   - 如果队列为空,这里也不会有分配动作
   - 从队列中取一个dlm_rsb, 设置name

** rsb_cmp(dlm_rsb, name, nlen)
   - 比较name和dlm_rsb->res_name

** dlm_search_rsb_tree(rb_root, name, len, dlm_rsb)
   - rb_root中是dlm_rsb->res_hashnode
   - 查找rb_root, 根据name索引排序

** rsb_insert(dlm_rsb, rb_root)
   - 把dlm_rsb->res_hashnode放到rb_root中

** find_rsb_dir(dlm_ls, name, len, hash, b, dir_nodeid, from_nodeid, flags, dlm_rsb)
   - dlm_ls->dlm_rsbtable管理dlm_rsb, 他有2个rb_root, 一个是normal, 使用中的;另一个是toss, 不再使用的
   - toss里面的dlm_rsb有2种,一种是本地不再使用的,被释放的,还有一种是directory record,他的所有者是其他node
   - 这个函数查找dlm_rsb
   - 根据参数dlm_rsb有3个来源? from_dir, from_other, from_local
   - 如果flags包含R_RECEIVE_REQUEST, 这是来自其他node的请求? 而且from_nodeid == dir_nodeid, from_dir = 1. 为何自己还要给自己发送请求?
   - 否则dlm_nodeid != dir_nodeid, 设置from_other=1
   - 如果flags & R_REQUEST, 这是本地请求, from_local = 1
   - 首先从keep rb_root中查找
   > dlm_search_rsb_tree(dlm_ls->ls_rsbtbl[b].keep, name, len, dlm_rsb)
   - 如果找到直接返回
   - 然后查找toss 
   > dlm_search_rsb_tree(dlm_ls->ls_rsbtbl[b].toss, name, len, dlm_rsb)
   - 如果找到,检查结果 
   - 如果dlm_rsb->res_master_nodeid != our_nodeid, 而且from_other!=0, 返回错误ENOTBLK??
   - 如果dlm_rsb->res_master_nodeid != our_nodeid, 而且from_dir!=0,需要更新dlm_rsb
   - 设置dlm_rsb->res_master_nodeid = our_nodeid, res_nodeid=0, 清除dlm_res->res_flags的RSB_MASTER_UNCERTAIN
   - 如果dlm_rsb->res_master_nodeid !=our_nodeid, 而且from_local==1, 设置dlm_rsb->res_flags的RSB_MASTER_UNCERTAIN
   - 把dlm_rsb->res_hashnode从toss转移到keep中
   - 如果找不到,就创建新的.
   > get_rsb_struct(dlm_ls, name, len, dlm_rsb)
   - 设置dlm_rsb->res_hash, res_dir_nodeid应该是它应该被索引的nodeid
   - 如果from_other有效,而且dir_nodeid != our_nodeid, 返回ENOTBLK
   - 如果dir_nodeid == our_nodeid, 设置dlm_rsb->res_master_nodeid = our_nodeid, dlm_rsb->res_nodeid = 0
   - 否则,设置dlm_res->res_master_nodeid = 0, dlm_rsb->res_nodeid = -1
   - 最后把创建的dlm_rsb放到dlm_ls->dlm_rsbhash->keep中

** find_rsb_nodir(dlm_ls, name, len, hash, b, dir_nodeid, from_nodeid, flags, dlm_rsb)
   - 什么是nodir
   - 检查是否在recover状态 flags & R_RECEIVE_RECOVER
   - 首先查找keep
   > dlm_search_rsb_tree(dlm_ls->dlm_rsbtable->keep, name, len, dlm_rsb)
   - 如果找到直接返回
   - 如果找不到查找toss
   > dlm_search_rsb_tree(dlm_ls->dlm_rsbtable->toss, name, len, dlm_rsb)
   - 如果找不到直接去创建. 如果找到,检查dlm_rsb是否正常
   - 如果不是recover, 而且dlm_rsb->res_master_nodeid != our_nodeid, 而且from_nodeid!=0, 说明这个dlm_rsb是无效的?? 返回ENOTBLK
   - 如果不是recover, 而且dlm_rsb->res_master_nodeid != our_nodeid, 而且dir_nodeid == our_nodeid, local node索引它,但不是他的master, 这里更新
   - 设置dlm_rsb->res_master_nodeid = our_nodeid, 而且dlm_rsb->res_nodeid = 0
   - 把dlm_rsb从toss中放到keep中
   - 如果要创建新的dlm_rsb 
   - 设置dlm_res->res_master_nodeid = res_dir_nodeid = dir_nodeid? 不是nodir??
   - 放到keep中
   > rsb_insert(dlm_rsb, dlm_ls->dlm_rsbtable->keep)

** find_rsb(dlm_ls, name, len, from_nodeid, flags, dlm_rsb)
   - 首先计算hash
   > jhash(name, len, 0)
   - 根据hash,找到directory node
   > dlm_hash2nodeid(dlm_ls, hash)
   - 检查dlm_ls是否支持dir?  dlm_ls->ls_flags & LSFL_NODIR
   > dlm_no_directory(dlm_ls)
   - 如果是nodir 
   > find_rsb_nodir(dlm_ls, name, len, hash, b, dir_nodeid, from_nodeid, flags, dlm_rsb)
   - 否则是普通的
   > find_rsb_dir(dlm_ls, name, len, hash, b, dir_nodeid, from_nodeid, flags, dlm_rsb)

** validate_master_nodeid(dlm_ls, dlm_rsb, from_nodeid)
   - 如果收到请求,操作的dlm_rsb的res_master_nodeid != our_nodeid, 这时需要更新它? 
   - 检查dlm_ls是否是nodir 
   > dlm_no_directory(dlm_ls)
   - 如果是nodir, 直接返回ENOTBLK??
   - 如果from_nodeid != dlm_rsb->res_dir_nodeid, 也不正常?  返回ENOTBLK
   - 否则更新这个dlm_rsb 
   - 设置dlm_rsb->res_master_nodeid = our_nodeid, res_nodeid = 0

** dlm_master_lookup(dlm_ls, from_nodeid, name, len, flags, r_nodeid, result)
   - 一般在处理lookup命令是使用这个函数, 但在recover directory或recover master时也使用这个函数
   - 如果from_nodeid == our_nodeid, 这时不可能的, 因为本地查找master直接去directory中
   - 如果flags & DLM_LU_RECOVER_DIR, 是recovery directory处理, from_master
   - 如果flags & DLM_LU_RECOVER_MASTER,是recovery master处理, fix_master
   - 根据name计算hash值,找到dir_nodeid
   > dlm_hash2nodeid(dlm_ls, hash)
   - 如果dir_nodeid不是our_nodeid,返回EINVAL
   - 查找dlm_rsb, 先查找keep, 然后是toss
   > dlm_search_rsb_tree(dlm_ls->dlm_rsbtable->keep, name, len, dlm_rsb)
   - 如果找到的dlm_rsb->res_dir_nodeid != our_nodeid, 更新它
   - 如果fix_master !=0, 而且dlm_rsb->res_master_nodeid已经删除, 更新他的master
   - 设置dlm_rsb->res_master_nodeid = from_nodeid, res_nodeid = from_nodeid, 设置dlm_rsb->rsb_flags的RSB_NEW_MASTER
   - 如果是from_master, 而且dlm_rsb->res_master_nodeid != from_nodeid, 更新它
   - 设置dlm_rsb->res_master_nodeid = from_nodeid, res_nodeid, 设置dlm_rsb->rsb_flags的RSB_NEW_MASTER
   - 最后返回dlm_res->res_master_nodeid给r_nodeid返回
   - 如果没有找到,创建一个
   - 设置res_dir_nodeid = our_nodeid, res_master_nodeid = from_nodeid
   - 而且把它放到toss中
   > rsb_insert(dlm_rsb, dlm_ls->dlm_rsbtable->toss)

** dlm_dump_rsb_hash(dlm_ls, hash)
   - 打印dlm_ls->dlm_rsbtable[hash]中所有的dlm_rsb

** dlm_rsb(kref)
   - 把dlm_rsb放到toss中, 目前在keep中
   > rsb_insert(dlm_rsb, dlm_ls->dlm_rsbtable->toss)
   - 删除他的lvb? 
   > dlm_free_lvb(dlm_rsb->res_lvbptr)

** unhold_rsb(dlm_rsb)
   - 释放dlm_rsb, 但释放是把它放到toss中
   > kref_put(dlm_res->res_ref, toss_rsb)

** kill_rsb(kref)
   - 这里只有检查. dlm_rsb的队列为空

** attach_lkb(dlm_rsb, dlm_lkb)
   - 增加dlm_lkb使用计数
   > hold_rsb(dlm_lkb)
   - 设置dlm_lkb->lkb_resource = dlm_rsb

** detach_lkb(dlm_lkb)
   - 正好相反

** create_lkb(dlm_ls, dlm_lkb)
   - 创建dlm_lkb
   > dlm_allocate_lkb(dlm_ls)
   - 使用dlm_ls->ls_lkbidr分配dlm_lkb->lkb_id
   - dlm_lkb->lkb_cb_work是dlm_callback_work, 哪里使用??
   
** find_lkb(dlm_ls, lkid, dlm_lkb)
   - lkid是dlm_lkb->ls_lkbidr, 使用他查找dlm_lkb

** kill_lkb(kref)
   - 注销dlm_lkb之前的检测函数

** __put_lkb(dlm_ls, dlm_lkb)
   - 为何不完全使用kref? 
   - 检查kobject的计数
   > kref_put(dlm_lkb->lkb_ref, kill_lkb)
   - 如果需要删除, 操作idr
   > idr_remove(dlm_ls->ls_lkbidr, lkid)
   - 释放dlm_rsb
   > detach_lkb(dlm_lkb)
   - dlm_lkb->lkb_lvbptr是什么?
   
** dlm_put_lkb(dlm_lkb)
   - dlm_lkb->dlm_rsb->dlm_ls 找到dlm_ls
   > __put_lkb(dlm_ls, dlm_lkb)

** hold_lkb(dlm_lkb)
   - 增加kobject使用计数

** unhold_lkb(dlm_lkb)
   - 减小使用计数
   > kref_put(dlm_lkb->lkb_ref, kill_lkb)

** lkb_add_ordered(list_head new, list_head head, mode)
   - new和head是dlm_lkb->lkb_statequeue队列
   - 队列中按照dlm_lkb->lkb_rqmode排序

** add_lkb(dlm_rsb, dlm_lbk, status)
   - 把dlm_lkb放到dlm_rsb队列中, status区分granted/waiting/convert队列
   - 设置dlm_lkb->lkb_timestamp = ktime_get()
   - 如果status == DLM_LKSTS_WAITING, 添加到dlm_rsb->res_waitqueue中
   - 如果dlm_lkb->lkb_exflags & DLM_LKF_HEADQUE有效,放到对头,否则放到队尾
   - 如果status == DLM_LKSTS_GRANTED, 添加到dlm_rsb->res_grantqueue中,而且保持有序
   > lkb_add_ordered(dlm_lkb->lkb_statusqueue, dlm_rsb->res_grantqueue, dlm_lkb->lkb_grmode)
   - 如果是DLM_LKSTS_CONVERT, 和wait一样

** del_lkb(dlm_rsb, dlm_lkb)
   - 释放dlm_lkb->lkb_statequeue链表

** move_lkb(dlm_rsb, dlm_lkb, sts)
   - 先删除之前的队列关系,然后根据sts放到新的队列中
   > del_lkb(dlm_rsb, dlm_lkb)
   > add_lkb(dlm_rsb, dlm_lkb, sts)

** msg_reply_type(mstype)
   - mstype表示请求的类别,返回对应的应答类型
   - DLM_MSG_REQUEST 对应  DLM_MSG_REQUEST_REPLY
   - CONVERT / UNLOCK / CANCEL / LOOKUP, 都相应的对应

** nodeid_warned(nodeid, num_nodes, int *warned)
   - warned是nodeid的数组,下面遍历等待的dlm_lkb,把等待的对象nodeid放到数组中
   - 这里保证没有重复
  
** dlm_scan_waiters(dlm_ls) 
   - 所有等待结果的dlm_ls放到dlm_ls->lkb_wait_time链表中
   - 遍历这个链表，检查dlm_lkb->lkb_wait_time
   - ktime_to_us(ktime_sub(ktime_get(), dlm_lkb->lkb_wait_time))
   - 如果超过dlm_config->ci_waitwarn_us, 把等待的nodeid放到数组中
   > nodeid_warned(dlm_lkb->lkb_wait_nodeid, num_nodes, warned)
   - 打印log错误信息
   - 如果dlm_config->ci_waitwarn_us ==0, 不会检查

** add_to_waiters(dlm_lkb, mstype, to_nodeid)
   - dlm_lkb->lkb_flags的DLM_IFL_OVERLAP_UNLOCK是什么意思? DLM_IFL_OVERLAP_CANCEL
   - 首先检查锁的状态, 根据dlm_lkb->lkb_wait_type和mstype
   - 如果检查通过，设置dlm_lkb, lkb_wait_count ++, lkb_wait_type = mstype, lkb_wait_nodeid = to_nodeid
   - 把dlm_lkb->lkb_wait_reply放到dlm_ls->ls_waiters中
  
** _remove_from_waiters(dlm_lkb, mstype, dlm_message)
   - 检查mstype和dlm_lkb的状态
   - 检查overlap??
   - 如果mstype ==DLM_MSG_CANCEL_REPLY,而且dlm_lkb->lkb_wait_type!=DLM_MSG_CANCEL, 返回-1?  cancel也需要等待?
   - 如果dlm_lkb->lkb_wait_type !=0, 设置为0
   - 最后各种检查如果需要删除等待, --dlm_lkb->lkb_wait_count, 还有多种等待?
   - 如果dlm_lkb->lkb_wait_count ==0, 删除链表dlm_lkb->lkb_wait_reply
  
** remove_from_waiters(dlm_lkb, mstype)
   > _remove_from_waiters(dlm_lkb, mstype, NULL)

** remove_from_waiters_ms(dlm_lkb, dlm_message)
   > _remove_from_waiters(dlm_lkb, dlm_message->m_type, dlm_message)

** wait_pending_remove(dlm_rsb)
   - dlm_ls->ls_remove_name表示正在删除一个dlm_rsb
   - 检查dlm_rsb是否是正在删除,等待删除完成?
   > rsb_cmp(dlm_rsb, dlm_ls->ls_rename_name, len)

** shrink_bucket(dlm_ls, int b)
   - 要释放一些无效的dlm_rsb? 把他们放到dlm_ls->ls_remove_lens/ls_remove_names
   - b用来索引dlm_ls->ls_rsbtbl这个hash表
   - 首先检查dlm_ls->ls_rsbtbl[b]->flags & DLM_RTF_SHRINK, 如果没有直接返回
   - 遍历dlm_rsbtable->toss中的dlm_rsb, 检查是否需要删除
   - 不是nodir,而且不是local的dlm_rsb  dlm_rsb->res_master_nodeid !=our_nodeid, 而且dir_nodeid ==our_nodeid,不能删除它
   > dlm_no_directory(dlm_ls)
   - 时间条件, 如果还很新,不处理它
   > time_after_eq(jiffies, dlm_rsb->res_toss_time + dlm_config->ci_toss_secs)
   - 如果dlm_rsb->res_master_nodeid == our_nodeid,但dir_nodid不是,需要发送remove请求,把这个dlm_rsb放到ls_remove_names中
   - 对于其他情况,可以直接删除, 可能是nodir的,也可能是local的
   - 释放dlm_rsb的使用计数
   > kref_put(dlm_rsb->res_ref, kill_rsb)
   - 删除rb_root关系, 删除dlm_rsb
   > dlm_free_rsb(dlm_rsb)
   - 然后遍历dlm_ls->ls_remove_names中的dlm_rsb, 还没有删除他们
   - 先检查它是否在toss中,如果找不到,别人删除它? 
   > dlm_search_rsb_tree(dlm_ls->ls_rsbtbl[b]->toss, name, len, dlm_rsb)
   - 检查dlm_rsb->res_master_nodeid != our_nodeid, 不能删除. 它会被修改?
   - 检查dlm_rsb->res_dir_nodeid ==our_nodeid? 这时会报错
   - 检查time??
   - 释放kobject使用计数,从rb_tree中删除它
   - 把name/len给dlm_ls->ls_remove_len/name, 发送remove消息
   > send_remove(dlm_rsb)
   - 删除dlm_rsb 
   > dlm_free_rsb(dlm_rsb)

** dlm_scan_rsbs(dlm_ls)
   - 遍历dlm_ls->ls_rsbtbl这个hash表,删除过期的dlm_rsb 
   > shrink_bucket(dlm_ls, i)

** add_timeout(dlm_lkb)
   - master copy , 不会timeout?
   > is_master_copy(dlm_lkb)
   - 检查dlm_lkb的条件,是否需要把它放到时间监控链表中
   - 首先dlm_ls需要,而且dlm_lkb没有拒绝
   - 对于dlm_ls->ls_flags&LSFL_TIMEWARN, 而且dlm_lkb->lkb_exflags没有DLM_LKF_NODLCKWT, 需要监控,设置dlm_lkb->lkb_extflags的DLM_IFL_WATCH_TIMEWARN
   - 如果dlm_lkb->lkb_extflags & DLM_LKF_TIMEOUT, 也需要监控
   - 把dlm_lkb->lkb_time_list放到dlm_ls->ls_timeout链表中

** del_timeout(dlm_lkb)
   - 释放dlm_lkb->lkb_time_list链表关系

** dlm_scan_timeout(dlm_ls)
   - 超时有2中处理,一种是warn, 另一种是cancel.
   - 遍历dlm_ls->ls_timeout链表中的dlm_lkb.
   - 计算dlm_lkb的时间
   > ktime_sub(ktime_get(), dlm_lkb->lkb_timestamp)
   - 如果dlm_lkb->lkb_extflags & DLM_LKF_TIMEOUT有效, 而且 wait > dlm_lkb->lkb_timeout_cs * 10000, 需要cancel, 在锁操作中指定了时间
   - 如果dlm_lkb->lkb_extflags & DLM_LFL_WATCH_TIMEWARN, 而且wait > dlm_config->ci_timewarn_cs * 10000, 需要warn
   - 如果是warn
   > dlm_timeout_warn(dlm_lkb)
   - 如果是cancel, 释放timeout链表
   > del_timeout(dlm_lkb)
   - cancel操作
   > _cancel_lock(dlm_rsb, dlm_lkb)

** dlm_adjust_timeouts(dlm_ls)
   - 根据dlm_ls->ls_recover_begin,调整dlm_lkb的时间? 增加jiffies - dlm_ls->ls_recover_begin 
   - 遍历dlm_ls->ls_timeout链表中的dlm_lkb, 增加dlm_lkb->lkb_timestamp
   - 遍历dlm_ls->ls_waiters, 设置dlm_lkb->lkb_wait_time = ktime_get()

** set_lvb_lock(dlm_rsb, dlm_lkb)
   - 检查lvb的操作, b = dlm_lvb_operations[dlm_lkb->lkb_grmode+1][dlm_lkb->lkb_rqmode+1]
   - 如果b==1, 获取lvb, dlm_lkb->lkb_exflags & DLM_LKF_VALBLK必须有效, 设置dlm_lkb->lkb_lvbseq = dlm_rsb->res_lvbseq
   - 如果b==0, 设置lvb.
   - 如果dlm_rsb->res_lvbptr ==NULL,创建dlm_lvb
   > dlm_allocate_lvb(dlm_rsb->dlm_ls)
   - 复制dlm_lvb, 增加dlm_rsb->res_lvbseq, 去掉dlm_rsb->res_flags的RSB_VALNOTVALID
   > rsb_clear_flags(dlm_rsb, RSB_VALNOTVALID)

** set_lvb_unlock(dlm_rsb, dlm_lkb)
   - 设置lvb, 首先检查条件
   - dlm_lkb->lkb_grmode < DLM_LOCK_PW不允许 ??
   - dlm_lkb->lkb_exflags包含DLM_LKF_IVVALBLK, 这要invalid,直接设置dlm_rsb 
   > rsb_set_flag(dlm_rsb, RSB_VALNOTVALID)
   - dlm_lkb->lkb_exflags没有DLM_LKF_VALBLK, 也不允许
   - 最后设置lvb, dlm_rsb->res_lvbseq ++, 清除dlm_rsb->res_flags的RSB_VALNOTVALID

** set_lvb_lock_pc(dlm_rsb, dlm_lkb, dlm_message)
   - process copy?
   - 这里只能获取lvb
   - 获取操作方向 b = dlm_lvb_operations[dlm_lkb->lkb_grmode+1][dlm_lkb_rqmode+1]
   - 如果b==1, 把dlm_message中的数据放到dlm_lkb->lkb_lvbptr???

** _remove_lock(dlm_rsb, dlm_lkb)
   - 对于dlm_lkb来说, 它的操作包括remove,revert,grant
   - remove是从grant队列中删除
   - revert是从convert转移到grant
   - cancel是从convert/wait队列上删除
   - 释放dlm_lkb->lkb_statequeue链表
   > del_lkb(dlm_rsb, dlm_lkb)
   - 设置dlm_lkb->lkb_grmode = DLM_LOCK_IV, 释放它
   > unhold_lkb(dlm_lkb)

** remove_lock(dlm_rsb, dlm_lkb)
   - 先处理lvb
   > set_lvb_unlock(dlm_rsb, dlm_lkb)
   - 然后删除它
   > _remove_lock(dlm_rsb, dlm_lkb)

** remove_lock_pc(dlm_rsb, dlm_lkb)
   > _remove_lock(dlm_rsb, dlm_lkb)

** revert_lock(dlm_rsb, dlm_lkb)
   - 首先它的request是满足不了,设置dlm_lkb->lkb_rqmode = DLM_LOCK_IV
   - 检查它的当前状态 dlm_lkb->lkb_status
   - 如果是DLM_LKSTS_GRANTED, 它已经有锁?? 没有操作
   - 如果是DLM_LKSTS_CONVERT,在请求convert, 把它放到granted队列中
   > move_lkb(dlm_rsb, dlm_lkb, DLM_LKSTS_GRANTED)
   - 如果是DLM_LKSTS_WAITING, 直接cancel??
   - del_lkb(dlm_rsb, dlm_lkb)
   - 设置dlm_lkb->lkb_grmode = DLM_LOCK_IV, 释放它
   > unhold_lkb(dlm_lkb)

** revert_lock_pc(dlm_rsb, dlm_lkb)
   > revert_lock(dlm_rsb, dlm_lkb)

** _grant_lock(dlm_rsb, dlm_lkb)
   - 接受锁请求
   - 设置dlm_lkb->lkb_grmode = dlm_lkb->lkb_rqmode
   - 如果dlm_lkb->lkb_status !=0, 移动队列
   > move_lkb(dlm_rsb, dlm_lkb, DLM_LKSTS_GRANTED)
   - 否则把它放到granted队列
   > add_lkb(dlm_rsb, dlm_lkb, DLM_LKSTS_GRANTED)
   - 最后设定dlm_lkb->lkb_rqmode = DLK_LOCK_IV

** grant_lock(dlm_rsb, dlm_lkb)
   - 设置lvb, 这是可以写lvb吗??
   > set_lvb_lock(dlm_rsb, dlm_lock)
   - 接受锁
   > _grant_lock(dlm_rsb, dlm_lock)

** grant_lock_pc(dlm_rsb, dlm_lkb, dlm_message)
   - pc就只能读取?? 
   > set_lvb_lock_pc(dlm_rsb, dlm_lkb, dlm_message)
   > _grant_lock(dlm_rsb, dlm_lkb)

** grant_lock_pending(dlm_rsb, dlm_lkb)
   - 接受了等待中的锁
   - 首先操作本地dlm_lkb
   > grant_lock(dlm_rsb, dlm_lkb)
   - 如果是远程请求,发送grant消息
   > send_grant(dlm_rsb, dlm_lkb)
   - 否则执行ast
   > queue_cast(dlm_rsb, dlm_lkb, 0)

** munge_demoted(dlm_lkb)
   - 在死锁中的处理? 降低锁的等级
   - 如果dlm_lkb->lkb_rqmode == DLM_LOCK_IV或dlm_lkb->lkb_grmode == DLM_LOCK_IV, 无效情况
   - 设置dlm_lkb->lkb_grmode = DLM_LOCK_NL

** munge_altmode(dlm_lkb, dlm_message)
   - 根据dlm_lkb->lkb_exflags修改dlm_lkb->lkb_rqmode
   - dlm_message->m_type必须是DLM_MSG_REQUEST_REPLY或DLM_MSG_GRANT
   - 如果dlm_lkb->lkb_exflags包含DLM_LKF_ALTPR, 改为dlm_lkb->lkb_rqmode = DLM_LOCK_PR
   - 如果是DLM_LKF_ALTCW, 改为DLM_LOCK_CW

** first_in_list(dlm_lkb, list_head)
   - 第一个dlm_lkb

** qeueu_conflict(list_head, dlm_lkb)
   - 检查dlm_lkb是否和链表中的冲突, 需要遍历链表的所有dlm_lkb
   > modes_compat(dlm_lkb, dlm_lkb)
  
** conversion_deadlock_detect(dlm_rsb, dlm_lkb lkb2)
   - 检查是否有convert deadlock, lkb2已经在队列上?
   - 遍历dlm_rsb->res_convertqueue队列上的dlm_lkb
   - 对于lkb2前面的dlm_lkb, 只要lkb2->lkb_grmode和dlm_lkb->lkb_rqmode冲突,就会eadlock
   > modes_compat(lkb2, dlm_lkb)
   - 对于后面的,需要互相冲突

** _can_be_granted(dlm_rsb, dlm_lkb, now, recover)
   - 检查锁请求是否接受
   - 如果dlm_lkb->lkb_exflags & DLM_LKF_EXPEDITE !=0, 返回1??
   - 检查是否和granted的冲突
   > queue_conflict(dlm_rsb->res_grantqueue, dlm_lkb)
   - 检查是否和convert的冲突
   > queue_conflict(dlm_res->res_convertqueue, dlm_lkb)
   - 如果dlm_lkb->lkb_grmode != DLM_LOCK_IV, 它已经有锁,现在是convert操作
   - 如果conv && recover !=0, 直接返回1, 接受锁
   - 如果now&conv=1, dlm_lkb->lkb_exflags & DLM_LKF_QUECVT ==0, 也接受???
   - 如果now & conv=1,dlm_lkb->lkb_exflags&DLM_LKF_QUECVT !=0, 但dlm_res->res_convertqueue为空,也接受?
   - 还有很多条件


** can_be_granted(dlm_rsb, dlm_lkb, now, recover, err)
   - 先检查是否能接受
   > _can_be_granted(dlm_rsb, dlm_lkb, now, recover)
   - 如果不能接受,处理返回的提示
   - 如果convert, dlm_lkb可以放在队列中
   > can_be_queued(dlm_lkb)
   - 有convert死锁
   > conversion_deadlock_detect(dlm_rsb, dlm_lkb)
   - 如果dlm_lkb->lkb_exflags & DLM_LKF_CONVDEADLK !=0, 改变它持有的锁?
   - 设置dlm_lkb->lkb_grmode = DLM_LOCK_NL, dlm_lkb->lkb_sbflags |= DLM_SBF_DEMOTED
   - 如果dlm_lkb->lkb_exflags & DLM_LKF_NODLCKWT ==0, 返回错误
   - 如果没有死锁，只能不能满足要求, 检查dlm_lkb->lkb_exflags & DLM_LKF_ALTERPR, DLM_LKF_ALTCW
   - 如果dlm_lkb->rqmode != DLM_LOCK_PR, 尝试DLM_LOCK_PR, 或者DLM_LKF_CW
   - 重新检查
   > _can_be_granted(dlm_res, dlm_lkb, now, 0)
   - 如果锁能接受,设置dlm_lkb_sbflags |= DLM_SBF_ALTMODE

** grant_pending_convert(dlm_rsb, high, int *cw, int *count)
   - 接受等待的convert请求
   - 遍历dlm_rsb->res_convertqueue队列上的dlm_lkb, 挨个处理
   > can_be_granted(dlm_rsb, dlm_lkb, 0, recover, deadlock)
   - 如果接受了请求,还需要重新遍历

** grant_pending_wait(dlm_rsb, high, cw, count)
   - 处理wait队列上的dlm_lkb
   - 遍历dlm_rsb->res_waitqueue队列上的dlm_lkb
   > can_be_granted(dlm_rsb, dlm_lkb, 0, 0, NULL)
   - 如果接受 
   > grant_lock_pending(dlm_rsb, dlm_lkb)
   - 参数cw用来统计DLM_LOCK_CW的锁, count表示接受的个数

** lock_requires_bast(dlm_lkb gr, high, cw)
   - gr是被阻塞的??
   - 如果dlm_lkb->lkb_grmode == DLM_LOCK_PR, 而且cw=1, 而且dlm_lkb->lkb_highbast < DLM_LOCK_EX, 需要bast?, 否则不需要
   

** grant_pending_locks(dlm_rsb, count)
   - 检查是否接受等待的请求
   - 首先dlm_rsb必须是local master
   > is_master(dlm_rsb) 
   - 首先是convert 
   > grant_pending_convert(dlm_rsb, high, cw, count)
   - 然后是wait
   > grant_pending_wait(dlm_rsb, high, cw, count)
   - 如果high == DLM_LOCK_IV?? 那就没有锁请求, 它表示被阻塞的锁的最高级别
   - 发送bast请求
   - 遍历dlm_rsb->res_grantqueue队列
   - 如果dlm_lkb->lkb_bastfn有效,而且有冲突
   > lock_requires_bast(dlm_lkb, high, cw)
   - 如果cw==1, high == DLM_LOCK_PR, 而且dlm_lkb->lkb_grmode == DLM_LOCK_PR, cw被pr阻塞
   > queue_bast(dlm_rsb, dlm_lkb, DLM_LOCK_CW)
   - 否则发送high 
   > queue_bast(dlm_rsb, dlm_lkb, high)

** modes_requires_bast(dlm_lkb gr, dlm_lkb rq)
   - 如果gr->lkb_grmode和rq->lkb_rqmode是DLM_LOCK_PR和DLM_LOCK_CW
   - 而且如果gr->lkb_highbast < DLM_LOCK_EX,需要发送bast, 否则不发送
   - 如果gr->lkb_highbast < rq->lkb_rqmode, 而且2个不相容,也发送bast
   > modes_compat(gr,rq)
   - bast是有条件的

** send_bast_queue(dlm_rsb, list_head, dlm_lkb)
   - 遍历list_head上面的dlm_lkb, 他应该是granted列表
   - 检查是否需要发送
   > modes_requires_bast(gr, dlm_lkb)
   - 发送bast请求
   > queue_bast(dlm_rsb, gr, dlm_lkb->lkb_rqmode)
   - 设置gr->lkb_highbast = dlm_lkb->lkb_rqmode

** send_blocking_asts(dlm_rsb, dlm_lkb)
   - 给granted的锁发送bast 
   > send_bast(dlm_rsb, dlm_rsb->res_grantqueue, dlm_lkb)

** send_blocking_asts_all(dlm_rsb, dlm_lkb)
   - 给granted和等待的convert的锁发送
   > send_bast(dlm_rsb, dlm_rsb->res_grantqueue, dlm_lkb)
   > send_bast(dlm_rsb, dlm_rsb->res_convertqueue, dlm_lkb)

** set_master(dlm_rsb, dlm_lkb)
   - 设置dlm_lkb->lkb_nodeid, 它根据dlm_res->res_nodeid
   - 如果dlm_res->res_nodeid不知道,需要发送lookup请求
   - 检查dlm_rsb->res_flags & RSB_MASTER_UNCERTAIN, 如果包含,好像也不是不明确的东西?
   - 设置dlm_res->res_first_lkid = dlm_lkb->lkb_id , dlm_lkb->lkb_nodeid = dlm_res->res_nodeid
   - 如果dlm_res->res_first_lkid !=0, 而且dlm_res->res_first_lkid != dlm_lkb->lkb_id, 说明有人在查找nodeid?? 把dlm_lkb放到dlm_res->lkb_rsb_lookup队列中
   - 如果dlm_res是local master? dlm_res->res_master_nodeid == our_nodeid, 设置dlm_lkb->lkb_nodeid = 0
   - 如果dlm_res->res_master_nodeid !=0, 他是remote, 设置dlm_lkb->lkb_nodeid = dlm_rsb->res_master_nodeid
   - 如果dlm_res->res_dir_nodeid = our_nodeid, 这时是奇怪的情况,因为他应该知道dlm_res->res_master_nodeid, 但上面却说不是. 只能说明他是local master?
   - 设置dlm_res->res_master_nodeid = our_nodeid, dlm_res->res_nodeid = 0, dlm_lkb->lkb_nodeid = 0
   - 其他情况, dlm_res的master不是our_nodeid, dir_nodeid也不是our_nodeid,需要去查找
   - 等待recover 
   > wait_pending_remove(dlm_rsb)
   - 设置dlm_rsb->res_first_lkid = dlm_lkb->lkb_id 
   - 发送lookup请求
   > send_lookup(dlm_rsb, dlm_lkb)

** process_lookup_list(dlm_rsb)
   - 处理lookup请求? 
   - 遍历dlm_rsb->res_lookup队列上的dlm_lkb
   - 发送请求.
   - 所以发送请求之前先查找,而且在dlm_res上等待?
   > _request_lock(dlm_rsb, dlm_lkb)

** confirm_master(dlm_rsb, error)
   - 处理应答消息?
   - 如果dlm_res->res_first_lkid ==0, 直接返回,他应该设置为某个dlm_lkb->lkb_lkid
   - 如果error是0或EINPROGRESS, 说明完成了?
   > process_lookup_list(dlm_rsb)
   - 如果是EAGAIN,EBAD,ENOTBLK, 这个请求是无效的,处理在dlm_res->res_lookup队列中的下一个dlm_lkb, 发送请求
   > _request_lock(dlm_rsb, dlm_lkb)
 
** dlm_lksb
   #+BEGIN_SRC 
	int 	 sb_status;
	__u32	 sb_lkid;
	char 	 sb_flags;
	char *	 sb_lvbptr;
	//lock status block, 在convert操作中使用
   #+END_SRC

** set_lock_args(mode, dlm_lksb, flags, namelen, timeout_cs, ast, astparam, bast, dlm_args)
   - 设置lock请求的参数
   - 检查flags是否有效, 这里有各种无效
   - 把参数给dlm_args

** set_unlock_args(flags, astarg, dlm_args)
   - 设置unlock的参数
   - 检查flags, 只能包含这些标志:DLM_LKF_CANCEL | DLM_LKF_VALBLK | DLM_LKF_IVVALBLK | DLM_LKF_FORCEUNLOCK, 取消或强制解锁,以及设置lvb
   - DLM_LKF_CANCEL不能和DLM_LKF_FORCEUNLOCK一块使用
   - 设置dlm_args->flags / astparam

** validate_lock_args(dlm_ls, dlm_lkb, dlm_args)
   - 根据dlm_args设置dlm_lkb
   - 如果dlm_args->flags & DLM_LKF_CONVERT, 检查dlm_lkb目前的状态
   - 如果dlm_lkb->lkb_flags & DLM_IFL_MSTCPY !=0 ?? 错误操作
   - 如果dlm_args->flags & DLM_LKF_QUECVT !=0, 而且__quecvt_compat_matrix[dlm_lkb->lkb_grmode +1][dlm_args->mode+1] ==0, 错误操作?? DLM_LKF_QUECVT表示让convert请求放到队列中??
   - 如果dlm_lkb->lkb_status != DLM_LKSTS_GRANTED, 表示他没有锁,不能convert
   - overlap??
   > is_overlap(dlm_lkb)

** validate_unlock_args(dlm_lkb, dlm_args)
   - 如果dlm_lkb->lkb_flags & DLM_IFL_MSTCPY !=0, 错误操作
   - 如果dlm_lkb->lkb_flags & DLM_IFL_ENDOFLIFE !=0, 错误操作
   - 如果dlm_lkb->lkb_res_lookup队列不是空, 他在查找dlm_rsb的master的过程, 只能是cancel dlm_lkb?
   - 删除dlm_lkb->lkb_res_lookup, 发送cast
   > queue_cast(dlm_lkb->lkb_resource, dlm_lkb, dlm_args->flags & DLM_LKF_CANCEL ? DLM_ECANCEL:DLM_EUNLOCK)
   - 先处理cancel操作  dlm_args->flags & DLM_LKF_CANCEL
   - 如果dlm_lkb->lkb_exflags & DLM_LKF_CANCEL, 不需再在cancel?
   - 删除dlm_lkb的timer
   > del_timeout(dlm_lkb)
   - 如果dlm_lkb->lkb_flags & DLM_IFL_RESEND, 设置dlm_lkb->lkb_flags的DLM_IFL_OVERLAP_CANCEL
   - 如果dlm_lkb->lkb_status == DLM_LKSTS_GRANTED, 而且dlm_lkb->lkb_wait_type ==0, 没有可cancel的, 直接返回
   - 如果dlm_lkb->lkb_wait_type是DLM_MSG_LOOKUP|DLM_MSG_REQUEST, 在等待lookup/request消息, 设置DLM_IFL_OVERLAP_CANCEL
   - 如果dlm_lkb->lkb_wait_type是DLM_MSG_UNLOCK|DLM_MSG_CANCEL, 直接返回??
   - 再处理force unlock dlm_args->flags & DLM_LKF_FORCEUNLOCK
   - 如果dlm_lkb->lkb_exflags & DLM_LKF_FORCEUNLOCK, 已经有了forceunlock??
   - 如果是overlap, 也不再操作
   - 从timeout链表中释放
   > del_timeout(dlm_lkb)
   - 如果有dlm_lkb->lkb_flags & DLM_IFL_RESEND, 设置DLM_IFL_OVERLAP_UNLOCK, 返回-EBUSY??
   - 检查dlm_lkb->lkb_wait_type, 如果是DLM_MSG_LOOKUP|DLM_MSG_REQUEST, 设置DLM_IFL_OVERLAP_UNLOCK, 返回-ebusy?? 这样不能force unlock?
   - 最后如果也没有cancel,也没有force unlock,而且dlm_lkb在等待状态, 不允许unlock,返回-EBUSY, dlm_lkb->lkb_wait_type || dlm_lkb->lkb_wait_count !=0
   - 如果参数都正确,设置dlm_lkb->lkb_exflags, dlm_lkb->lkb_astparam

** do_request(dlm_rsb, dlm_lkb)
   - 作为master处理锁请求
   - 是否能接受
   > can_be_granted(dlm_rsb, dlm_lkb, 1, 0, NULL)
   - 如果能,放到dlm_res队列中
   > grant_lock(dlm_res, dlm_lkb)
   - 发送cast??? 本地请求?? 
   > queue_cast(dlm_rsb, dlm_lkb, 0)
   - 如果不能接受,尝试queue
   > can_be_queued(dlm_lkb)
   - 如果可以返回-EINPROGRESS, 放到wait队列
   > add_lkb(dlm_rsb, dlm_lkb, DLM_LKSTS_WAITING)
   - timeout 
   > add_timeout(dlm_lkb)
   - 否则直接返回-EAGAIN
   > queue_cast(dlm_rsb, dlm_lkb, -EAGAIN)

** do_request_effects(dlm_rsb, dlm_lkb, error)
   - 处理request结果?
   - 如果error=EAGAIN, 而且dlm_lkb->lkb_exflags & DLM_LKF_NOQUEUEBAST?? 需要告诉别人? 
   > send_blocking_asts_all(dlm_rsb, dlm_lkb)
   - 如果error=EINPROGRESS, 在等待中, 也发起bast?
   > send_blocking_asts(dlm_rsb, dlm_lkb)

** do_convert(dlm_rsb, dlm_lkb)
   - 检查能否接受请求
   > can_be_granted(dlm_rsb, dlm_lkb, 1, 0, deadlock)
   - 如果可以就像处理request一样
   > grant_lock(dlm_rsb, dlm_lkb)
   - 发送cast 
   > queue_cast(dlm_rsb, dlm_lkb, 0)
   - 如果不能,而且有deadlock, 把他放到granted队列中,这里他在convert队列中? 
   > revert_lock(dlm_rsb, dlm_lkb)
   - 返回EDEADLK
   > queue_cast(dlm_rsb, dlm_lkb, -EDEADLK)
   - 如果dlm_lkb->lkb_sbflags & DLM_SBF_DEMOTED, 表示他demoted, 这时其他convert/request请求可能接受
   > grant_pending_convert(dlm_rsb, DLM_LOCK_IV, NULL, NULL)
   - 再检查它能否接受? 
   > _can_be_granted(dlm_rsb, dlm_lkb, 1, 0)
   - 如果能接受, 放到granted队列
   - 如果不能接受,检查能不能queue
   > can_be_queued(dlm_lkb)
   - 如果能queue, 返回-EINPROGRESS, 放到convert队列
   > del_lkb(dlm_rsb, dlm_lkb)
   > add_lkb(dlm_rsb, dlm_lkb, DLM_LKSTS_CONVERT)
   - timeout处理
   > add_timeout(dlm_lkb)
   - 不能queue就返回-EAGAIN
   > queeu_cast(dlm_rsb, dlm_lkb, -EAGAIN)

** do_canvert_effects(dlm_rsb, dlm_lkb, error)
   - 如果error==0, 接受了请求?? 检查能否接受等待的请求
   > grant_pending_locks(dlm_rsb, NULL)
   - 如果-EAGAIN, 请求失败了, 发送bcase
   > force_blocking_asts(dlm_lkb)
   > send_blocking_asts_ass(dlm_rsb, dlm_lkb)
   - 如果是EINPROGRESS, 请求需要等待
   > send_blocking_asts(dlm_rsb, dlm_lkb)

** do_unlock(dlm_rsb, dlm_lkb)
   - 很简单?? 释放dlm_lkb
   > remove_lock(dlm_rsb, dlm_lkb)
   - 发送cast
   > queue_cast(dlm_rsb, dlm_lkb, -DLM_EUNLOCK)

** do_unlock_effects(dlm_rsb, dlm_lkb, error)
   - error就是上面的ELM_EUNLOCK, 既然有锁释放了,就可以接受新的锁
   > grant_pending_locks(dlm_rsb, NULL)

** do_cancel(dlm_rsb, dlm_lkb)
   - cancel之前的等待请求
   > revert_lock(dlm_rsb, dlm_lkb)
   - 如果error ==0, 表示没有有效操作, 否则error就是DLM_ECANCEL
   - 返回结果
   > queeu_cast(dlm_rsb, dlm_lkb, -DLM_ECANCEL)

** do_cancel_effects(dlm_rsb, dlm_lkb, error)
   - 检查能否接受新的锁
   > grant_pending_locks(dlm_rsb, NULL)

** _request_lock(dlm_rsb, dlm_lkb)
   - 处理上层的锁请求,首先获取锁的master nodeid, 如果是remote,发送消息,否则本地处理
   - 获取master nodeid 
   > set_master(dlm_rsb, dlm_lkb)
   - 如果error !=0, 就是有问题
   - 如果是remote,发送消息
   > send_request(dlm_rsb, dlm_lkb)
   - 否则处理请求
   > do_request(dlm_rsb, dlm_lkb)
   > do_request_effects(dlm_rsb, dlm_lkb, error)

** _convert_lock(dlm_rsb, dlm_lkb)
   - dlm_rsb已经知道了master nodeid? 
   - 如果是remote,发送消息
   > send_convert(dlm_rsb, dlm_lkb)
   - 否则本地处理 
   > do_convert(dlm_rsb, dlm_lkb)
   > do_convert_effects(dlm_rsb, ..)

** _unlock_lock(dlm_rsb, dlm_lkb)
   - 和上面一样

** _cancel_lock(dlm_rsb, dlm_lkb)
   - 和上面一样

** request_lock(dlm_ls, dlm_lkb, name, len, dlm_args)
   - 处理参数,传递给上面的函数.
   - 检查dlm_lkb / dlm_args
   > validate_lock_args(dlm_ls, dlm_lkb, dlm_args)
   - 找到dlm_rsb
   > find_rsb(dlm_ls, name, lne, 0, R_REQUEST, dlm_rsb)
   - 关联dlm_rsb / dlm_lkb, dlm_lkb->lkb_lksb->sb_lkid = dlm_lkb->lkb_id, dlm_lksb
   - 发送请求
   > _request_lock(dlm_rsb, dlm_lkb)

** convert_lock(dlm_ls, dlm_lkb, dlm_args)
   - dlm_rsb和dlm_lkb已经关联, 检查参数
   > validate_lock_args(dlm_ls, dlm_lkb, dlm_args)
   - 发送请求
   > _convert_lock(dlm_rsb, dlm_lkb)

** unlock_lock(dlm_ls, dlm_lkb, dlm_args)
   - unlock和convert一样

** cancel_lock(dlm_ls, dlm_lkb, dlm_args)
   - 和上面一样

** dlm_lock(dlm_lockspace_t, mode, dlm_lksb, flags, name, namelen, parent_lkid, ast, astarg, bast)
   - 函数有10个参数,处理request或convert请求
   - 根据dlm_lockspace_t找到dlm_ls 
   > dlm_find_lockspace_local(dlm_lockspace_t)
   - 处理recover?? 
   > dlm_lock_recovery(dlm_ls)
   - 如果是request请求, 构造dlm_lkb
   > create_lkb(dlm_ls, dlm_lkb)
   - 如果是convert请求,找到dlm_lkb
   > find_lkb(dlm_ls, dlm_lksb->sb_lkid, dlm_lkb)
   - 设置dlm_lkb参数
   > set_lock_args(mode, dlm_lksb, flags, namelen, 0, ast, astarg, bast, dlm_args)
   - 发送请求
   > convert_lock(dlm_ls, dlm_lkb, dlm_args)
   > request_lock(dlm_ls, dlm_lkb, name, namelen, dlm_args)

** dlm_unlock(dlm_lockspace_t, lkid, flags, dlm_lksb, astargs)
   - 处理unlock和cancel请求
   - 先找到dlm_ls
   > dlm_find_lockspace_local(dlm_lockspace_t)
   - 找到dlm_lkb
   > find_lkb(dlm_ls, lkid, dlm_lkb)
   - 把函数参数包装给dlm_args
   > set_unlock_args(flags, astarg, dlm_args)
   - 发送请求
   > cancel_lock(dlm_ls, dlm_lkb, dlm_args)
   > unlock_lock(dlm_ls, dlm_lkb, dlm_args)
  
** 消息函数
   #+BEGIN_SRC 
 * send_args
 * send_common
 * send_request			receive_request
 * send_convert			receive_convert
 * send_unlock			receive_unlock
 * send_cancel			receive_cancel
 * send_grant			receive_grant
 * send_bast			receive_bast
 * send_lookup			receive_lookup
 * send_remove			receive_remove
 *
 * 				send_common_reply
 * receive_request_reply	send_request_reply
 * receive_convert_reply	send_convert_reply
 * receive_unlock_reply		send_unlock_reply
 * receive_cancel_reply		send_cancel_reply
 * receive_lookup_reply		send_lookup_reply
   
#define DLM_MSG_REQUEST		1
#define DLM_MSG_CONVERT		2
#define DLM_MSG_UNLOCK		3
#define DLM_MSG_CANCEL		4

#define DLM_MSG_REQUEST_REPLY	5
#define DLM_MSG_CONVERT_REPLY	6
#define DLM_MSG_UNLOCK_REPLY	7
#define DLM_MSG_CANCEL_REPLY	8

#define DLM_MSG_GRANT		9
#define DLM_MSG_BAST		10
#define DLM_MSG_LOOKUP		11
#define DLM_MSG_REMOVE		12
#define DLM_MSG_LOOKUP_REPLY	13
#define DLM_MSG_PURGE		14

   #+END_SRC

** _create_message(dlm_ls, mb_len, to_nodeid, mstype, dlm_message, dlm_mhandle)
   - 构造消息
   - 先获取dlm_lowcomms上面的缓存, 构造一个dlm_message, 使用dlm_mhandle索引. 这个函数返回dlm_mhandle索引的数据区, 也就是dlm_message
   > dlm_lowcomms_get_buffer(to_nodeid, mb_len, GFP_NOFS, dlm_mhandle)
   - dlm_mhandle来管理这个数据块,里面是dlm_message. 填充dlm_header
   - 设置h_lockspace = dlm_ls->ls_global_id?  h_nodeid = our_nodeid, h_cmd = DLM_MSG
   - dlm_msg->m_type = mstype?? 具体的请求参数?

** create_message(dlm_rsb, dlm_lkb, to_nodeid, mstype, dlm_message, dlm_mhandle)
   - 如果是request/lookup/remove, 数据是dlm_rsb?  dlm_rsb->res_length
   - 如果是convert/unlock/request_reply/convert_reply/grant, 需要涉及lvb?
   - 使用的buf长度增加dlm_ls->ls_lvblen
   > _create_message(dlm_ls, mb_len, to_nodeit, mstype, ms_ret, mh_ret)

** send_message(dlm_mhandle, dlm_message)
   - 发送消息, 格式化参数
   > dlm_message_out(dlm_message)
   - 提交缓存
   > dlm_lowcomms_commit_buffer(dlm_mhandle)
   - 果然它在lowcomms中是writequeue_entry

** send_args(dlm_rsb, dlm_lkb, dlm_message)
   - 根据dlm_lkb/dlm_rsb包装dlm_message
   - dlm_res的数据原来是dlm_rsb->res_name, 在REQUEST/LOOKUP中使用, 放到dlm_message->m_extra中
   - 如果是convert/unlock/request_reply/convert_reply/grant, 需要传递lvb, 在dlm_lkb->lkb_lvbptr中

** send_common(dlm_rsb, dlm_lkb, mstype)
   - 发送请求信息使用的函数
   - 目标节点是dlm_rsb->res_nodeid? 不是res_master_nodeid?
   - 设置dlm_lkb的等待参数,放到dlm_ls->ls_waiters链表上
   > add_to_waiters(dlm_lkb, mstype, to_nodeid)
   - 创建dlm_message 
   > create_message(dlm_rsb, dlm_lkb, to_nodeid, mstype, dlm_message, dlm_mhandle)
   - 根据dlm_lkb,设置dlm_message
   > send_args(dlm_rsb, dlm_lkb, dlm_message)
   - 发送dlm_message 
   > send_message(dlm_mhandle, dlm_message)

** send_request(dlm_rsb, dlm_lkb)
   - 发送request请求, dlm_lkb里面没有参数说明它的操作??
   > send_common(dlm_rsb, dlm_lkb, DLM_MSG_REQUEST)

** send_convert(dlm_rsb, dlm_lkb)
   - convert操作
   > send_common(dlm_rsb, dlm_lkb, DLM_MSG_CONVERT)
   - down conversion不会等待reply?
   - 如果error ==0, 发送reply请求
   > down_conversion(dlm_lkb)
   - 释放等待队列
   > remove_from_waiters(dlm_lkb, DLM_MSG_CONVERT_REPLY)
   - 设置dlm_rsb->dlm_ls->dlm_message, m_flags/m_type/m_result
   > __receive_convert_reply(dlm_rsb, dlm_lkb, dlm_res->dlm_ls->ls_stub_ms)
   - 收到的dlm_message先放到dlm_ls->ls_stub_ms中? 

** send_unlock(dlm_rsb, dlm_lkb)
   > send_common(dlm_rsb, dlm_lkb, DLM_MSG_UNLOCK)

** send_cancel(dlm_rsb, dlm_lkb)
   > send_common(dlm_rsb, dlm_lkb, DLM_MSG_CANCEL)

** send_grant(dlm_rsb, dlm_lkb)
   - dlm_lkb->lkb_nodeid是请求锁的nodeid??
   > create_message(dlm_rsb, dlm_lkb, DLM_MSG_GRANT, dlm_message, dlm_mhandle)
   - 设置并发送消息? 
   > send_args(dlm_rsb, dlm_lkb, dlm_message)
   > send_message(dlm_mhandle, dlm_message)

** send_bast(dlm_rsb, dlm_lkb, mode)
   - 发送给dlm_lkb的持有者?  dlm_lkb->lkb_nodeid
   - 和上面类似, 不过dlm_message->m_bastmode = mode

** send_lookup(dlm_rsb, dlm_lkb)
   - 发送的目的是dlm_rsb->res_dir_nodeid
   - 设置waiter队列
   > add_to_waiters(dlm_lkb, DLM_MSG_LOOKUP, to_nodeid)
   - 构造dlm_message 
   > create_message(dlm_rsb, NULL, to_nodeid, DLM_MSG_LOOKUP, dlm_message, dlm_mhandle)
   - 发送dlm_message
   > send_args(dlm_rsb, dlm_lkb, dlm_message)
   - 发送消息
   > send_message(dlm_mhandle, dlm_message)

** send_remove(dlm_rsb)
   - 发送给dlm_rsb->res_dir_nodeid, 从directory中删除dlm_rsb
   > create_message(dlm_rsb, NULL, to_nodeid, DLM_MSG_REMOVE, dlm_message, dlm_mhandle)
   - 发送之后不会等待
   - 需要发送dlm_rsb->res_name/res_hash
   > send_message(dlm_mhandle, dlm_message)

** send_common_reply(dlm_rsb, dlm_lkb, mstype, rv)
   - 发送reply消息, 给dlm_lkb->res_nodeid
   > create_message(dlm_rsb, dlm_lkb, to_nodeid, mstype, dlm_message, dlm_mhandle)
   - 消息包装和发送请求一样
   > send_args(dlm_rsb, dlm_lkb, dlm_message)
   - 设置dlm_message->m_result = rv
   > send_message(dlm_mhandle, dlm_message)

** send_request_reply(dlm_rsb, dlm_lkb, rv)
   > send_common_reply(dlm_rsb, dlm_lkb, DLM_MSG_REQUEST_REPLY, rv)

** send_convert_reply(dlm_rsb, dlm_lkb, rv)
   - 和上面一样

** send_unlock_reply(dlm_rsb, dlm_lkb, rv)
   - 和上面一样

** send_cancel_reply(dlm_rsb, dlm_lkb, rv)
   - 和上面一样

** send_lookup_reply(dlm_ls, dlm_message, ret_nodeid, rv)
   - 返回lookup的结果, 就只有一个rv和ret_nodeid??!! 还要请求的dlm_lkb->lkb_id = dlm_message->m_lkid
   - 构造dlm_message 
   > create_message(dlm_rsb, NULL, nodeid, DLM_MSG_LOOKUP_REPLY, dlm_message, dlm_mhandle)
   - 设置dlm_messge->m_lkid/m_result/m_nodeid, 发送消息
   > send_message(dlm_mhandle, dlm_message)

** receive_flags(dlm_lkb, dlm_message)
   - 把dlm_message的结果给dlm_lkb, 设置dlm_lkb->lkb_exflags / lkb_sbflags/ lkb_flags

** receive_flags_reply(dlm_lkb, dlm_message)
   - 在dlm_message->m_flags == DLM_IFL_STUD_MS时是无效的??
   - 设置dlm_lkb->lkb_sbflags, lkb_flags

** receive_extralen(dlm_message)
   - 额外数据的长度
   > dlm_header->h_length - sizeof(dlm_message)

** receive_lvb(dlm_ls, dlm_lkb, dlm_message)
   - 接受lvb数据, 首先dlm_lkb->lkb_exflags & DLM_LKF_VALBLK !=0
   - 分配dlm_lkb->lkb_lvbptr, 计算长度, 从dlm_message中复制数据
   > receive_extralen(dlm_message)

** fake_bastfn(astparam, mode)
   - 临时的bast回调函数

** fake_astfn(void astparam)
   - ast回调函数

** receive_request_args(dlm_ls, dlm_lkb, dlm_message)
   - 处理接受的dlm_message, 里面是request reply
   - 设置dlm_lkb->lkb_nodeid??
   - dlm_lkb->lkb_ownpid / lkb_remid / lkb_grmode / lkb_rqmode, 这些不是已经有吗? 
   - 如果dlm_message->m_asts 包含DLM_CB_BAST, 设置dlm_lkb->lkb_bastfn = fake_bastfn?  为何不是NULL
   - DLM_CB_CAST对应dlm_lkb->lkb_astfn = fake_astfn
   - DLM_LKF_VALBLK对应dlm_lkb->lkb_lvbptr, 但这里仅仅是准备, 因为request不会获取??

** receive_convert_args
   - 如果dlm_lkb->lkb_status != DLM_LKSTS_GRANTED, 返回enomem?
   - 接受lvb
   > receive_lvb(dlm_ls, dlm_lkb, dlm_message)
   - 接受dlm_lkb->lkb_rqmode / lkb_grmode

** receive_unlock_args(dlm_ls, dlm_lkb, dlm_message)
   - 同样只接受lvb? unlock不是设置lvb??

** setup_stub_lkb(dlm_ls, dlm_message)
   - 把dlm_message的信息放到dlm_ls->ls_stub_lkb, 仅仅包括lkb_nodeid / lkb_remid

** validate_message(dlm_lkb, dlm_message)
   - 验证接受的dlm_message, 根据dlm_message->m_type验证
   - 如果是DLM_MSG_CONVERT,DLM_MSG_UNLOCK, DLM_MSG_CANCEL
   - local应该是锁的master, dlm_lkb->lkb_flags & DLM_IFL_MSTCPY  有效,而且dlm_lkb->lkb_nodeid == dlm_message->dlm_header->h_nodeid, 而且dlm_lkb是master copy
   - 如果是DLM_MSG_CONVERT_REPLY, DLM_MSG_UNLOCK_REPLY, DLM_MSG_CANCEL_REPLY, DLM_MSG_GRANT, DLM_MSG_BAST
   - local应该是锁操作的发起者,收到了应答, dlm_lkb是process copy, dlm_lkb->lkb_flags & DLM_IFL_MSTCPY ==0, 而且dlm_lkb->lkb_nodeid == from. lkb_nodeid是什么东西??
   - 如果是DLM_MSG_REQUEST_REPLY, 收到锁请求, 同样是process copy, 而且dlm_lkb->lkb_nodeid ==-1或from

** send_repeat_remove(dlm_ls, ms_name,len)
   - remove请求?
   - 找到dir_nodeid
   - 检查dlm_ls是否还索引它.
   - 根据ms_name计算hash,在dlm_ls中找对应的dlm_rsb, dlm_ls->ls_rsbtbl[b]->keep/toss
   - 如果还在dlm_rsbtable中,不处理??
   - 把name/len给dlm_ls->ls_remove_len/name, 发送DLM_MSG_REMOVE消息
   > _create_message(dlm_ls, sizeof(dlm_message) + len, dir_nodeid, DLM_MSG_REMOVE, dlm_message, dlm_mhandle)
   - 这里没有dlm_lkb的事情, 直接发送
   > send_message(dlm_mhandle, dlm_message)
   - 删除dlm_ls->ls_remove_name / ls_remove_len

** receive_request(dlm_ls, dlm_message)
   - 接受dlm_request请求, local是dlm_rsb的master,所以他没有dlm_lkb
   - 构造dlm_lkb
   > create_lkb(dlm_ls, dlm_lkb)
   - 根据dlm_message设置dlm_lkb
   > receive_lkb(dlm_lkb, dlm_message)
   - 设置dlm_lkb->lkb_flags的DLM_IFL_MSTCPY
   > receive_request_args(dlm_ls, dlm_lkb, dlm_message)
   > receive_extralen(dlm_message)
   - 根据name找到dlm_rsb 
   > find_rsb(dlm_ls, dlm_message->m_extra namelen, from_nodeid, R_RECEVIE_REQUEST, dlm_rsb)
   - 如果找到的dlm_rsb->res_master_nodeid != our_ndoeid, 需要更新这个dlm_rsb 
   > validate_master_nodeid(dlm_ls, dlm_rsb, from_nodeid)
   - 执行request
   > do_request(dlm_rsb, dlm_lkb)
   - 发送reply, 处理锁的回调
   > send_request_reply(dlm_rsb, dlm_lkb, error)
   > do_request_effects(dlm_rsb, dlm_lkb, error)
   - 如果上面获取不到dlm_rsb, 或者dlm_rsb的master不正确,直接发送错误reply
   > setup_stub_lkb(dlm_ls, dlm_message)
   - send_request_reply(dlm_ls->ls_stub_rsb, dlm_ls->ls_stub_lkb, error)
   - 这时没有合适的dlm_lkb, 所以使用dlm_ls->ls_stub_lkb, 但dlm_ls->ls_stub_rsb里面没有有效信息?

** receive_convert(dlm_ls, dlm_message)
   - 找到dlm_lkb, 因为这时convert操作
   > find_lkb(dlm_ls, dlm_message->m_remid, dlm_lkb)
   - 这个dlm_lkb是master copy, dlm_lkb->lkb_remid == dlm_message->m_lkid
   - 检查dlm_message 
   > validate_message(dlm_lkb, dlm_message)
   - 接受dlm_message 
   > receive_flags(dlm_lkb, dlm_message)
   > receive_convert_args(dlm_ls, dlm_lkb, dlm_message)
   - 处理convert请求
   > do_convert(dlm_rsb, dlm_lkb)
   - 只有在down convert时才会reply
   > send_convert_reply(dlm_rsb, dlm_lkb, error)
   > do_convert_effects(dlm_rsb, dlm_lkb, error)

** receive_unlock(dlm_ls, dlm_message)
   - 和convert类似, 不过这里必须发送reply

** receive_cancel(dlm_ls, dlm_message)
   - 和上面类似

** receive_grant(dlm_ls, dlm_message)
   - 应该是master向请求者发送grant
   - 根据dlm_message->m_remid找到dlm_lkb
   > find_lkb(dlm_ls, dlm_message->m_remid, dlm_lkb)
   - 验证dlm_message 
   > validate_message(dlm_message)
   - 接受dlm_message
   > receive_flags_reply(dlm_lkb, dlm_message)
   - alter mode?  dlm_lkb->lkb_sbflags & DLM_SBF_ALTMODE, master改变锁级别, 修改dlm_lkb->lkb_rqmode
   > munge_altmode(dlm_lkb, dlm_message)
   - 处理请求
   > grant_lock_pc(dlm_rsb, dlm_lkb, dlm_message)
   - 发送cast 
   > queue_cast(dlm_rsb, dlm_lkb, 0)

** receive_bast(dlm_ls, dlm_message)
   - cast就是grant消息?  bast需要区别对待
   - 根据dlm_message->m_remid找到dlm_lkb
   > find_lkb(dlm_ls, dlm_message->m_remid, dlm_lkb)
   > validate_message(dlm_lkb, dlm_rsb)
   - 处理bast
   > queue_bast(dlm_rsb, dlm_lkb, dlm_message->m_bastmode)
   - 设置dlm_lkb->lkb_highbast = dlm_message->m_bastmode, 也不比较??

** receive_lookup(dlm_ls, dlm_message)
   - 处理lookup请求, 查询结果就是dir_nodeid
   > dlm_master_lookup(dlm_ls, from_nodeid, dlm_message->m_extra, len, 0, ret_nodeid, NULL)
   - 如果master是our_nodeid, dlm_message里面就是lock request?  直接处理
   > receive_request(dlm_ls, dlm_message)
   - 否则发送结果
   > send_lookup_reply(dlm_ls, dlm_message, ret_nodeid, error)
   
** receive_remove(dlm_ls, dlm_message)
   - 处理remove请求
   - 根据name找到dlm_rsb的dir_nodeid
   > dlm_hash2nodeid(dlm_ls, dlm_message->m_hash)
   - 如果dir_nodeid不是our_nodeid,直接返回
   - 根据dlm_res->res_name计算在dlm_restable表中的hash
   - 找到dlm_ls->dlm_restable[b]->toss中的dlm_rsb, 如果toss没有,查找keep
   - 如果在keep中,不能释放!
   - dlm_rsb->res_master_nodeid必须是dlm_message->dlm_header->h_nodeid
   - 使用kobject释放
   > kref_put(dlm_rsb->res_ref, kill_rsb) 
   - 在rb_root中删除
   > rb_erase(dlm_rsb->res_hashnode, dlm_ls->dlm_rsbtable->toss)
   > dlm_free_rsb(dlm_rsb)

** receive_purge(dlm_ls, dlm_message)
   - 释放pid的所有的dlm_lkb??
   > do_purge(dlm_ls, dlm_message->m_nodeid, dlm_message->m_pid)

** receive_reuqest_reply(dlm_ls, dlm_message)
   - 接受request reply
   - 根据dlm_message->m_remid找到dlm_lkb 
   > find_lkb(dlm_ls, id, ldm_lkb)
   - 验证dlm_message 
   > validate_messsage(dlm_lkb, dlm_message)
   - 从等待队列上删除, dlm_lkb怎么等待?? 会有多种情况?
   > remove_from_waiters(dlm_lkb, DLM_MSG_REQUEST_REPLY)
   - 检查dlm_lkb的等待条件, 如果是DLM_MSG_LOOKUP, 说明master nodeid也是dir nodeid, 而且处理Lookup请求时,处理了request 
   - 设置dlm_res->res_master_nodeid = from_nodeid, dlm_rsb->res_nodeid = from_nodeid, dlm_lkb->lkb_nodeid = from_nodeid
   - 处理结果dlm_message->m_result 
   - 如果是-EAGAIN, 发送cast
   > queue_cast(dlm_rsb, dlm_lkb, -EAGAIN)
   - 为何有验证master 
   > confirm_master(dlm_rsb, -EAGAIN)
   - 如果是EINPROGRESS或0, 表示接受或等待中
   > receive_flags_reply(dlm_lkb, dlm_message)
   - 设置dlm_lkb->remid = dlm_message->m_lkid, 也就是在master的lkb_id?
   - 什么时候设置alt?
   > munge_altmode(dlm_lkb)
   - 如果result是EINPROGRESS, 放到waiter队列, 调用者被阻塞??
   > add_lkb(dlm_rsb, dlm_lkb, DLM_LKSTS_WAITING)
   > add_timeout(dlm_lkb)
   - 否则接受请求,放到grant队列,发送cast
   > grant_lock_pc(dlm_rsb, dlm_lkb, dlm_message)
   > queue_cast(dlm_rsb, dlm_lkb, 0)
   - 同样验证dlm_rsb的master
   > confirm_master(dlm_rsb, result)
   - 如果是ENOTBLK/EBADR, 而且dlm_res的master nodeid和dir nodeid都不是our_nodeid, 设置dlm_rsb->res_master_nodeid=0, res_nodeid=-1, dlm_lkb->lkb_nodeid=-1, 无效的值?!
   - 还有overlap处理
   - 还要再重新发送? 
   > _request_lock(dlm_rsb, dlm_lkb)

** __receive_convert_reply(dlm_rsb, dlm_lkb, dlm_message)
   - 收到convert reply, 处理dlm_message
   - 如果dlm_message->m_result == EAGAIN, 发送cast
   > queue_cast(dlm_rsb, dlm_lkb, -EAGAIN)
   - 如果是EDEADLK, 接受flags 
   > receive_flags_reply(dlm_lkb, dlm_message)
   - 在本地回复dlm_lkb的链表,应该是放回granted队列
   > recvert_lock_pc(dlm_rsb, dlm_lkb)
   > queue_cast(dlm_rsb, dlm_lkb, -EDEADLK)
   - 如果是EINPROGRESS,在convert队列中等待
   > receive_flags_reply(dlm_lkb, dlm_message)
   > del_lkb(dlm_rsb, dlm_lkb)
   > add_lkb(dlm_rsb, dlm_lkb, DLM_LKSTS_CONVERT)
   > add_timeout(dlm_lkb)
   - 如果是0, 请求被接受
   > receive_flags_reply(dlm_lkb, dlm_message)
   > munge_demoted(dlm_lkb)
   - 仅仅修改dlm_lkb的状态,放到grant队列中,他不会检查是否修改其他锁, 那是master的工作
   > grant_lock_pc(dlm_rsb, dlm_lkb, dlm_message)
   > queue_cast(dlm_rsb, dlm_lkb, 0)
   
** _receive_convert_reply(dlm_lkb, dlm_message)
   - 检查dlm_message消息
   > validate_message(dlm_lkb, dlm_message)
   - 释放timeout链表
   > remove_from_waiters_ms(dlm_lkb, dlm_message)
   > __receive_convert_reply(dlm_rsb, dlm_lkb, dlm_message)

** receive_convert_reply(dlm_ls, dlm_message)
   - 先找到dlm_lkb 
   > find_lkb(dlm_ls, dlm_message->m_remid, dlm_lkb)
   > _receive_convert_reply(dlm_lkb, dlm_message)

** _receive_unlock_reply(dlm_lkb, dlm_message)
   - 验证dlm_message 
   > validate_message(dlm_lkb, dlm_message)
   - 释放timeout链表
   > remove_from_waiters_ms(dlm_lsb, dlm_message)
   - 如果dlm_message->m_result == -DLM_EUNLOCK, 请求被接受
   > receive_flags_reply(dlm_lkb, dlm_message)
   > remove_lock_pc(dlm_rsb, dlm_lkb)
   > queue_cast(dlm_rsb, dlm_lkb, -DLM_EUNLOCK)
   - 其他不处理,错误情况

** receive_unlock_reply(dlm_ls, dlm_message)
   > find_lkb(dlm_ls, dlm_message->m_remid, dlm_lkb)
   > _receive_unlock_reply(dlm_lkb, dlm_message)

** _receive_cancel_reply(dlm_lkb, dlm_message)
   - 验证dlm_message
   > validate_message(dlm_lkb, dlm_message)
   - waiter
   > remove_from_waiters_ms(dlm_lkb, dlm_message)
   - 如果dlm_message->m_result == DLM_ECANCEL, 请求被接受
   > receive_flags_reply(dlm_lkb, dlm_message)
   > revert_lock_pc(dlm_rsb, dlm_lkb)
   > queue_cast(dlm_rsb, dlm_lkb, DLM_ECANCEL)
   - 其他情况不处理

** receive_cancel_reply(dlm_ls, dlm_message)
   > find_lkb(dlm_ls, dlm_message->m_remid, dlm_lkb)
   > _receive_cancel_reply(dlm_lkb, dlm_message)

** receive_lookup_reply(dlm_ls, dlm_message)
   - 接受lookup reply
   > find_lkb(dlm_ls, dlm_message->m_remid, dlm_lkb)
   - waiter
   > remove_from_waiters(dlm_lkb, DLM_MSG_LOOKUP_REPLY)
   - 结果里面有效的是dlm_message->m_nodeid, 表示dlm_res->res_master_nodeid
   - 如果dlm_rsb->res_master_nodeid!=0, 它必须是dlm_message->m_nodeid, 否则就有错误, 有错误也不处理!!
   - 如果dlm_message->m_nodeid == dlm_our_nodedid()
   - 者还需要查找? 设置dlm_rsb->res_master_nodeid = our_nodeid, res_nodeid = 0
   - 如果dlm_message->m_nodeid !=0, 设置dlm_rsb->res_master_nodeid = res_nodeid = dlm_message->m_nodeid
   - 其他情况就是错误情况
   - 继续处理lock 
   > _request_lock(dlm_rsb, dlm_lkb)
   - 如果dlm_lkb是local master, 处理等待lookup的dlm_lkb ?? 不是的也应该处理??
   > process_lookup_list(dlm_rsb)

** _receive_message(dlm_ls, dlm_message, saved_seq)
   - 接受消息函数, 检查nodeid 
   > dlm_is_member(dlm_ls, dlm_message->dlm_header->h_nodeid)
   - 根据dlm_message->m_type,调用不同函数
   - request / convert / unlock / cancel
   - request_reply / convert_reply / unlock_reply / cancel_reply
   - grant / bast
   - lookup / remove
   - lookup_reply / remove_reply
   - purge

** dlm_receive_message(dlm_ls, dlm_message, nodeid)
   - 在recovery过程中,收到dlm_message, 放到requestqueue中.
   - removery完成后,调用dlm_recoverd处理这些dlm_message
   - 在正常状态下,处理dlm_message需要等待requestqueue队列的处理
   - 检查是否正常状态, dlm_ls->ls_flags & LSFL_RUNNING
   > dlm_locking_stopped(dlm_ls)
   - 如果是recovery状态, 放到requestqueue.  
   > dlm_add_requestqueue(dlm_ls, nodeid, dlm_message)
   - 否则处理他
   > dlm_wait_requestqueue(dlm_ls)
   > _receive_message(dlm_ls, dlm_message, 0)

** dlm_receive_buffer(dlm_packet, nodeid)
   - 接受数据的处理? 
   - dlm_packet->dlm_header已经有效
   - 如果dlm_header->h_cmd == DLM_MSG, 接受dlm_message 
   > dlm_message_in(dlm_packet->dlm_message)
   - 否则是rcom 
   > dlm_rcom_in(dlm_packet->dlm_rcom
   - dlm_header->h_nodeid必须是nodeid 
   - 查找dlm_ls 
   > dlm_find_lockspace_global(dlm_header->h_lockspace)
   - 调用具体的回调
   > dlm_receive_message(dlm_ls, dlm_message, nodeid)
   > dlm_receive_rcom(dlm_ls, dlm_rcom, nodeid)

** recover_convert_waiter(dlm_ls, dlm_lkb, dlm_message ms_stub)
   - 恢复convert?
   - 首先是middle conversion, PR和CW互相convert, 初始化ms_stub
   - 设置dlm_message->m_flags = DLM_IFL_STUB_MS, m_type = DLM_MSG_CONVERT_REPLY, m_result = EINPROGRESS, 模仿收到一个消息??
   > _receive_convert_reply(dlm_lkb, dlm_message)
   - 设置dlm_lkb->lkb_grmode = DLM_LOCK_IV, 设置dlm_rsb->rsb_flags的RSB_RECOVER_CONVERT
   - 如果dlm_lkb->lkb_rqmode > dlm_lkb->lkb_grmode, 升级锁
   - 设置dlm_lkb->lkb_flags & DLM_IFL_RESEND
   - 其他情况,降级锁不处理, 那是async, 需要等待master发送grant??

** waiter_needs_recovery(dlm_ls, dlm_lkb, dir_nodeid)
   - 等待的dlm_lkb是否需要recovery?  nodeid无效
   > dlm_is_removed(dlm_ls, dlm_lkb->lkb_wait_nodeid)
   
** dlm_recover_waiters_pre(dlm_ls)
   - 对于等待reply的dlm_lkb, 如果它们等待的nodeid无效, 恢复它们
   - 对于unlock, concel, down-convert, 使用假的消息处理它们
   - 对于request, up-convert, 设置resend, recovery完成后重新发送
   - 构造dlm_message
   - 遍历dlm_ls->ls_waiters链表中的dlm_lkb->lkb_wait_reply
   - 如果dlm_lkb->lkb_wait_type == DLM_MSG_LOOKUP, 设置dlm_lkb->lkb_flags |= DLM_IFL_RESEND
   - 如果不需要恢复, 也就是nodeid还有效, 不处理
   > waiter_needs_recovery(dlm_ls, dlm_lkb, dir_nodeid)
   - 检查dlm_lkb->lkb_wait_type, 他对应锁的操作??
   - 如果dlm_lkb->lkb_wait_type == 0, 处理overlap? 他应该没有等待? 
   > 如果lkb_wait_type == DLM_MSG_REQUEST, 设置dlm_lkb->lkb_flags的DLM_IFL_RESEND
   - 如果lkb_wait_type == DLM_MSG_CONVERT
   > recover_convert_waiter(dlm_ls, dlm_lkb, dlm_message)
   - 如果是DLM_MSG_UNLOCK / DLM_MSG_CANCEL, 都要构造假的dlm_message 
   - dlm_message->m_flags = DLM_IFL_STUB_MS, m_type是DLM_MSG_UNLOCK_REPLY/DLM_MSG_CANCEL_REPLY, m_result = DLM_EUNLOCK/DLM_ECANCEL, dlm_header->h_nodeid = dlm_lkb->lkb_nodeid
   > _receive_unlock_reply(dlm_lkb, dlm_message)
   > _receive_cancel_reply(dlm_lkb, dlm_message)
   
** find_resend_waiter(dlm_ls)
   - 处理需要重新发送的请求
   - 遍历dlm_ls->ls_waiters上的dlm_ls
   - 检查dlm_lkb->lkb_flags & DLM_IFL_RESEND

** dlm_recover_waiters_post(dlm_ls)
   - 处理resend的dlm_lkb
   - 循环查找resend的dlm_lkb 
   - 如果是recovery状态,不在这里处理
   > dlm_locking_stopped(dlm_ls)
   - 查找resend的dlm_lkb 
   > find_resend_waiter(dlm_ls)
   - 去掉DLM_IFL_RESEND / DLM_IFL_OVERLAP_UNLOCK / DLM_IFL_OVERLAP_CANCEL标志
   - 释放等待队列
   > list_del_init(dlm_lkb->lkb_wait_reply)
   - 如果有overlap情况, 使用cancel/unlock处理
   - queue_cast(dlm_rsb, dlm_lkb, DLM_EUNLOCK/DLM_ECANCEL)
   - 如果是DLM_MSG_CONVERT, 而且overlap_unlock, 还要释放原来的锁
   > _unlock_lock(dlm_rsb, dlm_lkb)
   - 如果没有overlap, 重新发送请求
   > _request_lock(dlm_rsb, dlm_lkb)
   > _convert_lock(dlm_rsb, dlm_lkb)

** purge_mstcpy_list(dlm_ls, dlm_rsb, list_head)
   - 遍历list_head上的dlm_lkb->lkb_statequeue
   - 检查dlm_lkb->lkb_recover_seq == dlm_ls->ls_recover_seq, 不处理它
   - 否则删除,它们已经被recover?? 
   > del_lkb(dlm_rsb, dlm_lkb)

** dlm_purge_mstcpy_locks(dlm_rsb)
   > purge_mstcpy_list(dlm_ls, dlm_rsb, dlm_rsb->res_grantqueue)
   > purge_mstcpy_list(dlm_ls, dlm_rsb, dlm_rsb->res_convertqueue)
   > purge_mstcpy_list(dlm_ls, dlm_rsb, dlm_rsb->res_waitqueue)

** purge_dead_list(dlm_ls, dlm_rsb, list_head, nodeid_gone, count)
   - 遍历list_head上的dlm_lkb
   - 如果不是master copy , 他是本地的dlm_lkb, 不处理
   > is_master_copy(dlm_lkb)
   - dlm_lkb->lkb_nodeid = nodeid_gone, 而且他的nodeid已经删除
   > dlm_is_remove(dlm_ls, dlm_lkb->lkb_nodeid)
   - 删除dlm_lkb
   > del_lkb(dlm_rsb, dlm_lkb)
   - 设置dlm_rsb->rsb_flags的RSB_RECOVER_GRANT

** dlm_recover_purge(dlm_ls)
   - recover操作中的purge
   - 遍历dlm_ls->ls_root_list中的dlm_rsb, 删除他的3个列表
   > purge_dead_list(dlm_ls, dlm_rsb, dlm_rsb->res_grantqueue, nodeid_gone, count)

** find_grant_rsb(dlm_ls, bucket)
   - bucket是dlm_rsbtable的hash值
   - 查找dlm_ls->dlm_rsbtable->keep中的dlm_lkb, 查找带有RSB_RECOVER_GRANT的, 而且dlm_rsb->res_nodeid ==0, master_nodeid = our_nodeid
   
** dlm_recover_grant(dlm_ls)
   - 在recovery过程中,一些dead nodeid的锁被删除,可能会接受其他的锁
   - 循环查找需要recover grant的dlm_rsb 
   > find_grant_rsb(dlm_ls, bucket)
   - 处理等待的锁
   > grant_pending_locks(dlm_rsb, count)
   - 清除RSB_RECOVER_GRANT
   > confrim_master(dlm_rsb, 0)

** search_remid_list(list_head, nodeid, remid)
   - 在list_head中查找一个dlm_lkb 
   > dlm_lkb->lkb_nodeid = nodeid, dlm_lkb->lkb_remid = remid

** search_remid(dlm_rsb, nodeid, remid)
   - 在dlm_rsb的3个队列上查找

** rcom_lock 
   #+begin_src 
	__le32			rl_ownpid;
	__le32			rl_lkid;
	__le32			rl_remid;
	__le32			rl_parent_lkid;
	__le32			rl_parent_remid;
	__le32			rl_exflags;
	__le32			rl_flags;
	__le32			rl_lvbseq;
	__le32			rl_result;
	int8_t			rl_rqmode;
	int8_t			rl_grmode;
	int8_t			rl_status;
	int8_t			rl_asts;
	__le16			rl_wait_type;
	__le16			rl_namelen;
	char			rl_name[DLM_RESNAME_MAXLEN];
	char			rl_lvb[0];   
   #+end_src

** receive_rcom_lock_args(dlm_ls, dlm_lkb, dlm_rsb, dlm_rcom)
   - rcom_lock是什么??
   - 使用rcom_lock初始化dlm_lkb, 他是dlm_message?

** dlm_recover_master_copy(dlm_ls, dlm_rcom)
   - 找到dlm_rsb 
   > find_rsb(dlm_ls, dlm_rcom->rl_name, name_len, from_nodeid, R_RECEIVE_RECOVER, dlm_rsb)
   - 再找dlm_lkb 
   > search_remid(dlm_rsb, rcom_lock->dlm_header->h_nodeid, rcom_lock->rl_lkid)
   - 如果没找到,根据rcom_lock构造一个新的dlm_lkb 
   > create_lkb(dlm_ls, dlm_lkb)
   - 放到grant队列中
   > receive_rcom_lock_args(dlm_ls, dlm_lkb, dlm_rsb, rc)
   > attach_lkb(dlm_rsb, dlm_lkb)
   > add_lkb(dlm_rsb, dlm_lkb, status)
   - 设置dlm_lkb->lkb_recover_seq = dlm_ls->ls_recover_seq

** dlm_recover_process_copy(dlm_ls, dlm_rcom)
   - 恢复process lock??
  > find_lkb(dlm_ls, rcom_lock->rl_lkid)
  - dlm_lkb必须是process copy, 这时在请求端的nodeid
  > is_process_copy(dlm_lkb)
  - 检查rcom_lock->rl_result, 如果是EBADR, 发送给谁? 
  > dlm_send_rcom_lock(dlm_rsb, dlm_lkb)
  - 如果是0, 设置dlm_lkb->lkb_remid = remid
  - 最后恢复dlm_rsb 
  > dlm_recovered_lock(dlm_rsb)

** dlm_user_request(dlm_ls, dlm_user_args, mode, flags, name, namelen, timeout_cs)
   - 接受userspace的请求
   > dlm_lock_recovery(dlm_ls)
   - 构造dlm_lkb 
   > create_lkb(dlm_ls, dlm_lkb)
   - 如果flags & DLM_LKF_VALBLK, 准备lvb数据, DLM_USER_LVB_LEN
   > set_lock_args(mode, dlm_user_args->lksb, flags, namelen, timeout_cs, fake_astfn, dlm_user_args, fake_bastfn, dlm_args)
   - 设置dlm_lkb->lkb_flags的DLM_IFL_USER
   > request_lock(dlm_ls, dlm_lkb, name, namelen, dlm_args)
   - 如果返回0/EINPROGRESS/EAGAIN, 就是没有问题?? 
   > list_add_tail(dlm_lkb->lkb_ownqueue, dlm_user_args->dlm_user_proc->locks)

** dlm_user_convert(dlm_ls, dlm_user_args, mode, flags, lkid, lvb_in, timeout_cs)
   - 查找dlm_lkb 
   > find_lkb(dlm_ls, dlm_lkb)
   - 如果flags & DLM_LKF_VALBLK, 把lvb_in的数据放到dlm_user_args->dlm_lksb->sb_lvbptr中
   - 把dlm_user_args参数放到dlm_lkb->lkb_ua中
   > set_lock_args(mode, dlm_user_args->dlm_lksb, flags, 0, timeout_cs, fake_astfn, dlm_user_args, fake_bastfn, dlm_args)
   - 提交convert
   > convert_lock(dlm_ls, dlm_lkb, dlm_args)

** dlm_user_unlock(dlm_ls, dlm_user_args, flags, lkid, lvb_in)
   - dlm_user_args的参数传递到dlm_args, 然后传递给dlm_lkb, 然后给master处理
   - 找到dlm_lkb
   > find_lkb(dlm_ls, lkid, dlm_lkb)
   - 处理lvb, castparam
   > 处理dlm_user_args参数
   > set_unlock_args(flags, dlm_user_args, dlm_args)
   - 提交unlock请求
   > unlock_lock(dlm_ls, dlm_lkb, dlm_args)
   - 如果结果是DLM_EUNLOCK,是正确的
   - 如果是EBUSY,而且flags & DLM_LKF_FORCEUNLOCK,也是正确??
   - 其他情况,都是错误
   - 释放dlm_user_args->dlm_user_proc->unlocking链表

** dlm_user_cancel(dlm_ls, dlm_user_args, flags, lkid)
   - 找到dlm_lkb
   > find_lkb(dlm_ls, lkid, dlm_lkb)
   - 处理flags / dlm_user_args 
   > set_unlock_args(flags, dlm_user_args, dlm_args)
   > cancel_lock(dlm_ls, dlm_lkb, dlm_args)

** dlm_user_deadlock(dlm_ls, flags, lkid)
   - 找到dlm_lkb 
   > find_lkb(dlm_ls, lkid, dlm_lkb)
   - 设置flags
   > set_unlock_args(flags, dlm_user_args, dlm_args)
   - 验证unlock参数? 
   > validate_unlock_args(dlm_lkb, dlm_args)
   - 设置dlm_lkb->lkb_flags的DLM_IFL_DEADLOCK_CANCEL
   - 怎么cancel? 不是检查deadlock?
   > _cancel_lock(dlm_rsb, dlm_lkb)
   > dlm_unlock_recovery(dlm_ls)

** orphan_proc_lock(dlm_ls, dlm_lkb)
   - 取消dlm_lkb??
   - 把dlm_lkb->lkb_ownqueue放到dlm_ls->ls_orphans链表上
   > set_unlock_args(0, dlm_lkb->dlm_user_args, dlm_args)
   > cancel_lock(dlm_ls, dlm_lkb, dlm_args)

** unlock_proc_lock(dlm_ls, dlm_lkb)
   - 设置dlm_args的DLM_LKF_FORCEUNLOCK|DLM_LKF_INVVALBLK, 强制unlock, 而且如果是EX/PW的dlm_lkb, 使dlm_rsb->lvb无效
   > set_unlock_args(DLM_LKF_FORCEUNLOCK|DLM_LKF_INVVALBLK, dlm_user_args, dlm_args)
   > unlock_lock(dlm_ls, dlm_lkb, dlm_args)

** del_proc_lock(dlm_ls, dlm_user_proc)
   - 从dlm_user_proc->locks链表中,删除一个dlm_lkb?
   - 如果dlm_lkb->lkb_exflags & DLM_LKF_PERSISTENT !=0, 设置dlm_lkb->lkb_flags的DLM_IFL_ORPHAN?? 否则设置DLM_IFL_DEAD

** dlm_clear_proc_locks(dlm_ls, dlm_user_proc)
   - 删除dlm_user_proc管理的所有的dlm_lkb?? 
   - 首先循环遍历dlm_user_proc->locks链表
   - 删除timeout链表
   > del_timeout(dlm_lkb)
   > orphan_proc_lock(dlm_ls, dlm_lkb) 
   > unlock_proc_lock(dlm_ls, dlm_lkb)
   - 遍历dlm_user_proc->unlocking链表, 仅仅删除它们
   > del_put_lkb(dlm_lkb)
   - 然后是dlm_user_proc->asts, 上面也是dlm_lkb 
   > 清除dlm_lkb->lkb_callbacks
   > dlm_put_lkb(dlm_lkb)

** purge_proc_locks(ldm_ls, dlm_user_proc)
   - 遍历dlm_user_proc->locks, 发起unlock操作, 设置dlm_lkb->lkb_flags的DLM_IFL_DEAD
   > unlock_proc_lock(dlm_ls, dlm_lkb)
   - 处理dlm_user_proc->unlocking / asts链表

** do_purge(dlm_ls, nodeid, pid)
   - 删除dlm_ls->ls_orphans链表上的,pid使用的dlm_lkb 
   - dlm_lkb->lkb_ownpid == pid
   - 发起unlock请求
   > unlock_proc_lock(dlm_ls, dlm_lkb)
   
** send_purge(dlm_ls, nodeid, pid)
   - 发送purge请求, 去nodeid删除pid使用的dlm_lkb 
   > _create_message(dlm_ls, sizeof(dlm_message), nodeid, DLM_MSG_PURGE, dlm_message, dlm_mhandle)
   - 填充dlm_message->m_nodeid, m_pid
   > send_message(dlm_mhandle, dlm_message)

** dlm_user_purge(dlm_ls, dlm_user_proc, nodeid, pid)
   - 如果nodeid != dlm_our_nodeid()
   > send_purge(dlm_ls, nodeid, pid)
   - 否则, 本地删除
   - 如果pid == current->pid 
   > purge_proc_locks(dlm_ls, dlm_user_proc)
   - 否则删除orphans
   > do_purge(dlm_ls, nodeid, pid)
   
* requestqueue.c

** rq_entry
   #+begin_src 
	struct list_head list;
	uint32_t recover_seq;
	int nodeid;
	struct dlm_message request;   
	//在recover过程中收到的消息暂存起来,recovery完成后处理
   #+end_src

** dlm_add_requestqueue(dlm_ls, nodeid, dlm_message)
   - 构造rq_entry, 保存整个dlm_message
   - 设置rq_entry->recover_seq = dlm_ls->ls_recover_seq, nodeid
   - 把它放到dlm_ls->ls_requestqueue队列中

** dlm_process_requestqueue(dlm_ls)
   - 处理之前的rq_entry/dlm_message
   - 循环处理队列dlm_ls->ls_requestqueue, 直到队列为空
   > dlm_receive_message_saved(dlm_ls, rq_entry->dlm_message, rq_entry->recover_seq)
   - 检查dlm_ls是否应该停止 ??  dlm_ls->ls_flags & LSFL_RUNNING, 退出循环

** dlm_wait_requestqueue(dlm_ls)
   - 等待dlm_ls->ls_requestqueue队列为空

** purge_request(dlm_ls, dlm_message, nodeid)
   - 判断dlm_message是否应该purge??
   - dlm_ls->ls_count是什么?
   - nodeid不在dlm_ls中? 
   > dlm_is_removed(dlm_ls, nodeid)
   - dlm_message->m_type是DLM_MSG_REMOVE或DLM_MSG_LOOKUP或DLM_MESSAGE_LOOKUP_REPLY
   - 最后dlm_ls没有dir??
   > dlm_no_directory(dlm_ls)

** dlm_purge_requestqueue(dlm_ls)
   - 遍历dlm_ls->ls_requestqueue上面的dlm_message, 如果可以删除,就释放它们,不会处理!! 
   > purge_request(dlm_ls, dlm_message, nodeid)
   

* recover.c 

** dlm_wait_function(dlm_ls, int testfn(dlm_ls))
   - 在dlm_ls->ls_wait_general队列上等待, 等待条件是
   > testfn(dlm_ls)
   > dlm_recovery_stopped(dlm_ls)
   - 每隔dlm_config->ci_recover_timer 检查一遍

** dlm_recover_status(dlm_ls)
   - 获取dlm_ls->ls_recover_status?? 
     
** _set_recover_status(dlm_ls, status)
   - 设置dlm_ls->ls_recover_status = status 

** dlm_set_recover_statsu(dlm_ls, status)
   > _set_recover_status(dlm_ls, status)

** wait_status_all(dlm_ls, wait_status, save_slots)
   - 等待dlm_ls->ls_nodes的所有dlm_member的状态是wait_status
   - 通过rcom通信,同步节点的状态
   - 遍历dlm_ls->ls_nodes中的dlm_member
   - 循环使用rcom查询状态,直到它们的状态包含wait_status 
   - 只能在recovery中查询??
   - dlm_recovery_stopped(dlm_ls)
   > dlm_rcom_status(dlm_ls, dlm_member->nodeid, 0)
   - 如果save_slots !=0, 保存结果
   > dlm_slot_save(dlm_ls, dlm_rcom, dlm_member)
   - 如果dlm_rcom->rc_result & wait_status !=0, 可以处理下一个

** wait_status_low(dlm_ls, wait_status, status_flags)
   - 获取dlm_ls->ls_low_nodeid, 检查这一个节点的状态
   > dlm_recovery_stopped(dlm_ls)
   > dlm_rcom_status(dlm_ls, nodeid, status_flags)
   - dlm_rcom->rc_result & wait_status !=0, 结束等待

** wait_status(dlm_ls, status)
   - 如果dlm_ls->ls_low_nodeid == dlm_our_nodeid
   - 当前nodeid是最小的, 需要等待所有的
   > wait_status_all(dlm_ls, status, 0)
   - 然后修改状态
   > dlm_set_recover_status(dlm_ls, status << 1)
   - 否则等待最小的nodeid 
   > wait_status_low(dlm_ls, status<<1, 0)

** dlm_recover_members_wait(dlm_ls)
   - 恢复members信息?? 
   - 如果dlm_ls->ls_low_nodeid == dlm_our_nodeid()
   - 先等待所有dlm_member到DLM_RS_NODES状态
   > wait_status_all(dlm_ls, DLM_RS_NODES, 1)
   - 分配slot 
   > dlm_slot_assign(dlm_ls, num_slots, slots_size, slots, gen)
   - 唤醒其他dlm_member 
   > _set_recover_status(dlm_ls, DLM_RS_NODES_ALL)
   - 如果不是最小dlm_member 
   > wait_status_low(dlm_ls, DLM_RS_NODES_ALL, DLM_RSF_NEED_SLOTS)
   - 获取slot信息
   > dlm_slots_copy_in(dlm_ls)

** dlm_recoveer_directory_wait(dlm_ls)
   - 所有dlm_member同步为DLM_RS_DIR状态
   > wait_status(dlm_ls, DLM_RS_DIR)

** dlm_recover_locks_wait(dlm_ls)
   > wait_status(dlm_ls, DLM_RS_LOCKS)

** dlm_recover_done_wait(dlm_ls)
   > wait_status(dlm_ls, DLM_RS_DONE)

** recover_list_empty(dlm_ls)
   - 检查dlm_ls->ls_recover_list是否为空

** recover_list_add(dlm_rsb)
   - 把dlm_rsb->res_recover_list放到dlm_ls->ls_recover_list

** recover_list_del(dlm_rsb)
   - 删除dlm_rsb->res_recover_list链表关系

** recover_list_clear(dlm_ls)
   - 删除dlm_ls->ls_recover_list中的所有dlm_rsb 
   > dlm_put_rsb(dlm_rsb)

** recover_idr_empty(dlm_ls)
   - 检查是否有recover的dlm_rsb. dlm_ls->ls_recover_list_count表示dlm_ls->ls_recover_list链表中dlm_rsb的数量

** recover_idr_add(dlm_rsb)
   - 为dlm_rsb->res_id是dlm_ls->ls_recover_idr中的id

** recover_idr_del(dlm_rsb)
   - 从dlm_ls->ls_recover_idr中释放dlm_rsb指针

** recover_idr_find(dlm_ls)
   - 根据id查找dlm_rsb 

** recover_idr_clear(dlm_ls)
   - 遍历idr中的dlm_rsb, 释放它们
   > dlm_put_rsb(dlm_rsb)

** set_lock_master(list_head, nodeid)
   - 遍历list_head中的dlm_lkb->lkb_statequeue, 如果不是master copy, 设置nodeid. 那就是process copy
   - 设置dlm_lkb->lkb_nodeid = nodeid, dlm_lkb->lkb_remid = 0

** set_master_lkbs(dlm_rsb)
   - 设置使用dlm_rsb的所有dlm_lkb的nodeid
   > set_lock_master(dlm_rsb->res_grantqueue, dlm_rsb->res_nodeid)
   - 还有convertqueue / waitqueue 

** set_new_master(dlm_rsb)
   - 先设置nodeid 
   > set_master_lkbs(dlm_rsb)
   - 设置dlm_rsb->rsb_flags的RSB_NEW_MASTER | RSB_NEW_MASTER2

** recover_master(dlm_rsb, count)
   - 处理master nodeid失效的dlm_rsb. 
   - 检查dlm_rsb->res_nodeid是否失效
   > dlm_is_removed(dlm_ls, dlm_rsb->res_nodeid)
   - 如果没有失效,而且dlm_rsb->res_nodeid没有RSB_NEW_MASTER, 不需要处理
   - 计算dir_nodeid
   > dlm_dir_nodeid(dlm_rsb)
   - 如果dir_nodeid == our_nodeid, 直接修改本地的dlm_rsb 
   - 如果dlm_res->res_nodeid失效,使用our_nodeid, 也就是dir_nodeid 
   - 设置dlm_rsb->res_master_nodeid = our_nodeid, dlm_rsb->res_nodeid = 0
   - 设置dlm_lkb
   > set_new_master(dlm_rsb)
   - 如果不是dir_nodie, 使用rcom消息恢复
   > recover_idr_add(dlm_rsb)
   > dlm_send_rcom_lookup(dlm_rsb, dir_nodeid)

** recover_master_static(dlm_rsb, count)
   - 删除所有的master copy 的dlm_lkb 
   > dlm_purge_mstcpy_locks(dlm_rsb)
   - 重新计算dlm_rsb的dir_nodeid 
   > dlm_dir_nodeid(dlm_rsb)
   - 设置dlm_rsb->res_master_nodeid = dir_nodeid, dlm_rsb->res_nodeid = dir_nodeid, 当然如果dir_nodeid是our_nodeid, 改为0
   > set_new_master(dlm_rsb)

** dlm_recover_masters(dlm_ls)
   - 处理dlm_ls->ls_root_list链表中的dlm_rsb 
   > lock_rsb(dlm_rsb)
   - 如果dlm_ls不支持dir
   > recover_master_static(dlm_rsb, count)
   - 否则使用rcom
   > recover_master(dlm_rsb, count)
   - 等待没有恢复的dlm_rsb 
   > dlm_wait_function(dlm_ls, recover_idr_empty)

** dlm_recover_master_reply(dlm_ls, dlm_rcom)
   - 处理dlm_rcom消息?  
   - 根据dlm_rcom->rc_id查找dlm_rsb 
   > recover_idr_find(dlm_ls, dlm_rcom->rc_id)
   - 根据dlm_rcom->rc_result设置master nodeid
   - 设置dlm_rsb->res_master_nodeid / res_nodeid
   > set_new_master(dlm_rsb)
   > recover_idr_del(dlm_rsb)

** recover_locks_queue(dlm_rsb, list_head)
   - 针对master nodeid改变的dlm_rsb, 重新创建使用他的process copy的dlm_lkb, 也就是本地的dlm_lkb
   - 遍历list_head上面的dlm_lkb
   > dlm_send_rcom_lock(dlm_rsb, dlm_lkb)
   - 统计恢复的dlm_lkb的个数 dlm_rsb->res_recover_locks_count

** recover_locks(dlm_rsb)
   - 处理dlm_rsb的3个队列
   - 如果dlm_rsb->res_recover_locks_count > 0, 说明本地还使用这个锁, 需要恢复它
   > recover_list_add(dlm_rsb)
   - 否则清除它的RSB_NEW_MASTER, recover不再处理他

** dlm_recover_locks(dlm_ls)
   - 处理dlm_ls->ls_root_list中的所有dlm_rsb 
   - 对于master是our_nodeid的,不再处理
   - 如果没有RSB_NEW_MASTER, 不再处理
   - 恢复dlm_lkb 
   > recover_locks(dlm_rsb)
   - 等待dlm_rsb恢复完成
   > dlm_wait_function(dlm_ls, recover_list_empty)

** dlm_recoverd_lock(dlm_rsb)
   - 应该是dlm_lkb恢复后调用的, 唤醒等待的任务
   - 减小dlm_rsb->res_recover_locks_count
   - 如果减为0, 清除RSB_NEW_MASTER, 在recover中删除他
   > recover_list_del(dlm_rsb)
   - 如果dlm_ls没有恢复的dlm_rsb
   > recover_list_empty(dlm_ls)
   - 唤醒dlm_rsb->dlm_ls->ls_wait_general)

** recover_lvb(dlm_rsb)
   - 恢复lvb, 设置dlm_rsb的RSB_VALNOTVALID标志
   - 如果dlm_rsb没有RSB_NEW_MASTER2, 而且有RSB_RECOVER_LVB_INVAL, 直接设置RSB_VALNOTVALID标志, 返回. RSB_RECOVER_LVB_INVAL是什么? 
   - 如果没有RSB_NEW_MASTER2,直接返回. 否则our_nodeid就是master nodeid
   - 遍历dlm_rsb->res_grantqueue队列, 如果有dlm_lkb->lkb_exflags 带有DLM_LKF_VALBLK, 说明存在有效的lvb   lock_lvb_exists = 1
   - 如果dlm_lkb->lkb_grmode > DLM_LOCK_CR, 根据他的值设置lvb  big_lock_exists = 1
   - 遍历convertqueue队列, 和上面一样
   - 如果big_lock_exits == 0, 说明没有锁决定他的lvb, 设置RSB_VALNOTVALID
   - 否则把dlm_lkb->lkb_lvbptr的值给dlm_rsb
   - 如果没有把lvbseq最大的dlm_lkb的值设置上

** recover_conversion(dlm_rsb)
   - 处理带有RECOVER_CONVERT的dlm_rsb
   - 为何设置它们的dlm_lkb->lkb_grmode??

** recover_grant(dlm_rsb)
   - 如果dlm_rsb->res_waitqueue / res_convertqueue不是empty, 设置RSB_RECOVER_GRANT标志
   > rsb_set_flags(dlm_rsb, RSB_RECOVER_GRANT)

** dlm_recover_rsbs(dlm_ls)
   - 遍历dlm_ls->ls_root_list队列中的dlm_rsb
   - 只处理master nodeid是our nodeid的
   - 如果dlm_rsb包含RSB_RECOVER_CONVERT 
   > recover_conversion(dlm_rsb)
   - 恢复lvb 
   > recover_lvb(dlm_rsb)
   - 如果有RSB_NEW_MASTER2, 恢复grant 
   > recover_grant(dlm_rsb)

** dlm_create_root_list(dlm_ls)
   - 根据dlm_ls的所有dlm_restable->keep, 重建dlm_ls->ls_root_list链表

** dlm_release_root_list(dlm_ls)
   - 释放dlm_ls->ls_root_list链表中的dlm_rsb
   > dlm_put_rsb(dlm_rsb)

** dlm_clear_toss(dlm_ls)
   - 清除所有的dlm_restable->toss中的dlm_rsb
   > del_free_rsb(dlm_rsb)











