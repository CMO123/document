nfs客户端的delegation管理   

nfs_delegation:
* list_head super_list: 使用nfs_server管理所有的delegation
* rpc_cred cred
* inode inode: nfs_inode->delegation找到inode的delegation
* nfs4_stateid stateid: delegation是一种状态数据, nfs4_stateid是一个16字节的id,里面有seqid
* fmode_t type: 文件访问方式
* loff_t maxsize: 这是什么大小??
* __u64 change_attr: ???
* flags: 标志包括NFS_DELEGATION_NEED_RECLAIM/RETURN/REFERENCED
* lock, rcu

nfs4_state
* list_head open_states: 某个stateowner关联的所有state
* list_head inode_states: inode关联的所有state
* list_head lock_states: 这个state关联的lock
* nfs4_state_owner *owner: stateowner
* inode inode: 
* flags
* seqlock
* nfs4_stateid stateid: 主要是这个东西,它是server返回的stateid,可能是某个delegation,可能是open state.
* nfs4_stateid open_stateid: open???
* n_rdonly, n_wronly, n_rdwr
* state, count

nfs_open_context 它是open时创建的,代表open的状态,在rfc中没有这个的说明,它应该和server的open状态对应. 在每次打开时(nfs4_file_open)创建一个新的nfs_open_context给file, 然后调用rpc call填充这个nfs_open_context,主要是处理nfs_state相关的东西..
* nfs_lock_context lock_context: ???
* dentry dentry: 为何不是inode???
* rpc_cred cred
* nfs4_state state: 打开使用了哪种state?? open/delegation/lock???
* fmode_t mode
* flags, error
* list_head list: 与同一个nfs_inode关联的nfs_open_context
* nfs4_threshold mdsthreshold


1. nfs_delegation_claim_locks(nfs_open_context, nfs4_state) 重新申请nfs_open_context关联的文件锁,申请时使用nfs4_state,这里的nfs4_state复杂的多.
  获取nfs4_state->inode, 遍历它的file_lock队列,如果file_lock->fl_file使用nfs_open_context, 则重新向nfs server申请锁
  -> nfs4_lock_delegation_recall(nfs4_state, file_lock) 文件锁和delegation有和关系??? 这个函数在下面调用

2. nfs_delegation_claim_opens(inode, nfs4_stateid) nfs4_stateid应该是某个delegation的stateid, 检查打开inode文件的nfs_open_context,如果它使用的nfs_state使用这个delegation的stateid,重新执行打开操作. 这里操作的意义是要释放nfs4_stateid这个delegation.
  -> nfs4_open_delegation_recall(nfs_open_context, nfs4_state, nfs4_stateid) 调用OPEN,重新声明之前的delegation. nfs_state对于inode(某个用户/stateowner)来说是唯一的,里面记录inode的打开情况,这里相当于重新打开一遍所有和delegation相关的nfs_open_context. 执行OPEN操作,claim模式是NFS4_OPEN_CLAIM_DELEGATE_CUR, 下面还有模式NFS4_OPEN_CLAIM_PREVIOUS的结果处理.
  -> nfs_delegation_claim_locks(nfs_open_context, nfs_state) 重新申请inode文件上的锁

3. nfs_inode_reclaim_delegation(inode, rpc_cred, nfs_openres) 这个函数在OPEN调用返回时使用,如果OPEN是重新申请open state, 根据返回的stateid更新nfs_inode->delegation. 对任何OPEN, server都可能会返回delegation,根据它更新和创建nfs_inode->delegation. 这个函数是更新操作,原来的delegation->flags必须包含NFS_DELEGATION_NEED_RECLAIM标志
  -> 如果nfs_inode已有delegation, 更新stateid,delegation_type,cred 
  -> 如果没有,创建一个新的  nfs_inode_set_delegation
这个操作在状态管理的任务中使用,检查状态的有效,如果发现stateid无效,就使用它重新申请状态,如果server同时给了delegation,就使用这些操作把delegation保存起来..

4. nfs_do_return_delegation(inode, nfs_delegation, issync)调用RPC DELEGRETURN,仅仅设计stateid.
  -> nfs4_proc_delegreturn(inode, cred, stateid, issync)
  nfs_inode_return_delegation_noreclaim(inode) 仅仅释放nfs_delegatin的关系和归还delegation,不会对打开的状态有操作. 对上面函数最简单的包装..

5. nfs_detach_delegation_locked(nfs_inode, nfs_server) 释放nfs_delegation的管理关系..
  nfs_detach_delegation

6. nfs_inode_set_delegation(inode, rpc_cred, nfs_openres)创建新的nfs_delegation,同时设置nfs_inode->cache_validity的NFS_INO_REVAL_FORCED

7. __nfs_inode_return_delegation(inode, nfs_delegation, issync)
  -> nfs_delegation_claim_opens(inode, nfs_delegation->stateid) 重新打开?? 在使用delegation时,打开操作可以在本地执行,但现在要归还delegation,所以那些open操作需要告诉server.
  -> nfs_do_return_delegation(inode, nfs_delegation, issync) 释放delegation
  nfs4_inode_return_delegation(inode) 释放nfs_delegation,包含写回操作
    -> nfs_wb_all(inode)
    -> nfs_detach_delegation
    -> __nfs_inode_return_delegation(inode, nfs_delegation, 1)  同步释放..

8. nfs_client_return_marked_delegations(nfs_client) 释放nfs_client的一些nfs_delegation, nfs_delegation->flags包含NFS_DELEGATION_RETURN.
  -> nfs_detach_delegation(nfs_inode, nfs_server)
  -> __nfs_inode_return_delegation(nfs_inode, nfs_delegation, 0) 这个过程不会创建新的nfs_delegation...

9. nfs_mark_return_delegation(nfs_server, nfs_delegation) 设置nfs_server->nfs_client->cl_state的NFS4CLNT_DELEGRETURN, 和nfs_delegation->flags的NFS_DELEGATION_RETURN..  设置nfs_delegation标志,下次清除操作会清楚它,设置nfs_client的标志,启动清楚操作

10. nfs_server_return_all_delegation(nfs_server) 设置nfs_server所有关联的nfs_delegation的NFS_DELEGATION_RETURN标志. 这个函数在释放nfs_server时使用..
  -> nfs_client_return_marked_delegation(nfs_client) 发起归还操作
  -> nfs4_schedule_state_manager(nfs_client) 如果上面的没有完成,启动异步任务...

11. nfs_mark_return_all_delegation_types(nfs_server, fmode_t) 归还访问模式为fmode_t的nfs_delegation
  -> nfs_mark_return_delegation(server, nfs_delegation)

12. nfs_client_mark_return_all_delegation_types(nfs_client, fmode_t)
  -> nfs_mark_return_all_delegation_types(....)

13. nfs_delegation_run_state_manager(nfs_client) 检查nfs_client->cl_state的NFS4CLNT_DELEGRETURN标志
  -> nfs4_schedule_state_manager(nfs_client)

14. nfs_remove_bad_delegation(inode) 删除nfs_inode->nfs_delegation, 这个函数在错误处理中使用,一般发生NFS4ERR_BAD_STATEID错误时,删除相应inode上的delegation
  -> nfs_detach_delegation(nfs_inode)
  -> nfs_inode_find_state_and_remove(inode, nfs_delegation->stateid) 这个函数检查是否有delegation关联的nfs_open_context,如果有出发state manager线程工作. 但这里没有设置nfs_client->state的标志..
  -> nfs_free_delegation(nfs_delegation)

15. nfs_expire_all_delegation_types(nfs_client, fmode_t)
  -> nfs_client_mark_return_all_delegation_types(nfs_client, flags) 设置对应fmode_t的delegation无效..
  -> nfs_delegation_run_state_manager(nfs_client) 启动state manager任务

  nfs_expire_all_delegations(nfs_client) 包装上面的函数,在renew,和callback无效时,归还所有delegation.  而且CALLBACK有一个process,归还所有的delegation,用到它.

16. nfs_mark_return_referenced_delegations(nfs_server) 
  -> nfs_mark_return_delegation(nfs_server, nfs_delegation) 清楚nfs_delegation->flags的NFS_DELEGATION_REFERENCED标志,如果之前就没有,归还这个nfs_delegation..

  nfs_expire_unreferenced_delegations(nfs_client) 包装上面的函数.. 这算是一个回收函数,在renew操作中调用,回收长期没有使用的delegation...
    -> nfs_delegation_run_state_manager(nfs_client) 而且会触发state manager.  

17. nfs_async_inode_return_delegation(inode, nfs4_stateid)异步的释放nfs_delegation, 设置标志,然后出发state manager. 上面的函数nfs_do_return_delegation会调用rpc process, 但它会被state manager简介调用到. 这个函数在callback process中调用到,用来归还delegation
  -> nfs_mark_return_delegation ..
  -> nfs_delegation_run_state_manager(nfs_client)

18. nfs_delegation_find_inode_server(nfs_server, nfs_fh) 在nfs_server的所有nfs_delegation中找一个，它关联的nfs_inode和nfs_fh符合..
  nfs_delegation_find_inode(nfs_client, nfs_fh) 在nfs_client上找一个, 这个是为callback process服务的函数..

19. nfs_delegation_mark_reclaim_server(nfs_server) / nfs_delegation_mark_reclaim(nfs_client) 给关联的nfs_delegation设置NFS_DELEGATION_NEED_RECLAIM. 这个操作比较危险,再发生严重错误的调用..

20. nfs_delegation_reap_unclaimed(nfs_client) 在reboot recovery操作之后,删除没有恢复的nfs_delegation, 不用rpc process.
  -> nfs_delegation_grab_inode
  -> nfs_detach_delegation(...)
  -> nfs_free_delegation(..)


delegation只有server主动给client,不能client去主动申请. 目前仅看到open操作时会给client一个delegation.. 但client拿到这个delegation在自己的read/write/open时好像会有所操作. 在delegation归还时,仅仅重新执行一些和delegation关联的open操作,没有close操作.. 而且nfs_open_context怎么和delegation关联起来??? 只有client主动放弃delegation,即使server发送CB命令,也是client异步发送一个delegreturn命令. 这里仅仅包含delegation的管理,还要学习open/IO/cache的操作中delegation的作用,还有renew操作中.

对于一个nfs client, delegation属于某个文件的,它在server端应该也是属于某个client的, 在client,它属于某个super_block/nfs_server, 它是全局唯一的,仅仅依靠不同的文件,就能区分. 而对于open的share state,它属于某个打开者,应该是某个文件使用者,用户.所以一个文件可能有多个share state,属于不同的用户,对应这stateowner.
