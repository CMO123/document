* pnfs_dev.c

** nfs4_deviceid
   #+begin_src 
	char data[NFS4_DEVICEID4_SIZE];
   #+end_src

** nfs4_deviceid_node
  #+begin_src 
	struct hlist_node		node;
	struct hlist_node		tmpnode;
	const struct pnfs_layoutdriver_type *ld; 
	const struct nfs_client		*nfs_client;
	unsigned long 			flags;
	unsigned long			timestamp_unavailable;
	struct nfs4_deviceid		deviceid;
	atomic_t			ref;
	//他表示ds节点？
  #+end_src


** _lookup_deviceid(pnfs_layoutdriver_type, nfs_client, nfs4_deviceid, hash)
   - nfs4_deviceid_node使用hash表管理, nfs4_deviceid_hash
   - 根据nfs4_deviceid / nfs_client / pnfs_layoutdriver_type 区别

** _find_get_deviceid(pnfs_layoutdriver_type
   > _lookup_deviceid(pnfs_layoutdriver_type, nfs_client, nfs4_deviceid, hash)
   - 使用rcu hash锁

** nfs4_find_get_deviceid(pnfs_layoutdriver_type, nfs_client, nfs4_deviceid)
   - 根据nfs4_deviceid计算hash
   > _find_get_deviceid(pnfs_layoutdriver_type, nfs_client, .)

** nfs4_delete_deviceid(pnfs_layoutdriver_type, nfs_client, nfs4_deviceid)
   - 都释放了,为何不直接操作?
   - 先找到nfs4_deviceid_node 
   > _lookup_deviceid(pnfs_layoutdriver_type, nfs_client, nfs4_deviceid, hash)
   - rcu hash表操作 
   > hlist_del_init_rcu(nfs4_deviceid->node)
   - 释放它的使用计数?  nfs4_deviceid_node->ref 
   > pnfs_layoutdriver_type->free_deviceid_node(nfs4_deviceid_node)

** nfs4_init_deviceid_node(nfs4_deviceid_node, pnfs_layoutdriver_type, nfs_client, nfs4_deviceid)
   - 初始化，关联数据结构 

** nfs4_insert_deviceid_node(nfs4_deviceid_node)
   - 创建新的nfs4_deviceid_node, 插入到hash表中
   - 先查找,是否有重复的
   > _find_get_deviceid(pnfs_layoutdriver_type, nfs_client
   
** nfs4_put_deviceid_node(nfs4_deviceid_node)
   - 直接释放,减小nfs4_deviceid_node->ref
   > nfs4_deviceid_node->pnfs_layoutdriver_type->free_deviceid_node(nfs4_deviceid_node)

** nfs4_mark_deviceid_unavailable(nfs4_deviceid_node)
   - 设置nfs4_deviceid_node->timestamp_unavailable = jiffies
   - flags的NFS_DEVICEID_UNAVAILABLE

** nfs4_test_deviceid_unavailable(nfs4_deviceid_node)
   - 检查nfs4_deviceid_node是否不可使用?
   - 首先nfs4_deviceid_node->flags有NFS_DEVICEID_UNAVAILABLE
   - 而且失
效时间不能太久?
   > jiffies - timestamp_unavailable < PNFS_DEVICE_RETRY_TIMEOUT
   - 否则,去掉NFS_DEVICEID_UNAVAILABLE??

** _deviceid_purge_client(nfs_client, hash)
   - 释放nfs_client关联的nfs4_deviceid_node

** nfs4_deviceid_purge_client(nfs_client)
   - 便利hash链表
   > _deviceid_purge_client(nfs_client, hash)

** nfs4_deviceid_mark_client_invalid(nfs_client)
   - 把nfs_client关联的nfs4_deviceid_node设为无效
   - 设置nfs4_deviceid_node->flags的NFS_DEVICEID_INVALID

* pnfs.c

** pnfs_layoutdriver_type 
   #+BEGIN_SRC 
	//表示layout解析驱动
	struct list_head pnfs_tblid;
	const u32 id;
	const char *name;
	struct module *owner;
	unsigned flags;

	int (*set_layoutdriver) (struct nfs_server *, const struct nfs_fh *);
	int (*clear_layoutdriver) (struct nfs_server *);

	struct pnfs_layout_hdr * (*alloc_layout_hdr) (struct inode *inode, gfp_t gfp_flags);
	void (*free_layout_hdr) (struct pnfs_layout_hdr *);

	struct pnfs_layout_segment * (*alloc_lseg) (struct pnfs_layout_hdr *layoutid, struct nfs4_layoutget_res *lgr, gfp_t gfp_flags);
	void (*free_lseg) (struct pnfs_layout_segment *lseg);

	/* test for nfs page cache coalescing */
	const struct nfs_pageio_ops *pg_read_ops;
	const struct nfs_pageio_ops *pg_write_ops;

	struct pnfs_ds_commit_info *(*get_ds_info) (struct inode *inode);
	void (*mark_request_commit) (struct nfs_page *req,
				     struct pnfs_layout_segment *lseg,
				     struct nfs_commit_info *cinfo);
	void (*clear_request_commit) (struct nfs_page *req,
				      struct nfs_commit_info *cinfo);
	int (*scan_commit_lists) (struct nfs_commit_info *cinfo,
				  int max);
	void (*recover_commit_reqs) (struct list_head *list,
				     struct nfs_commit_info *cinfo);
	int (*commit_pagelist)(struct inode *inode,
			       struct list_head *mds_pages,
			       int how,
			       struct nfs_commit_info *cinfo);

	/*
	 * Return PNFS_ATTEMPTED to indicate the layout code has attempted
	 * I/O, else return PNFS_NOT_ATTEMPTED to fall back to normal NFS
	 */
	enum pnfs_try_status (*read_pagelist) (struct nfs_read_data *nfs_data);
	enum pnfs_try_status (*write_pagelist) (struct nfs_write_data *nfs_data, int how);

	void (*free_deviceid_node) (struct nfs4_deviceid_node *);

	void (*encode_layoutreturn) (struct pnfs_layout_hdr *layoutid,
				     struct xdr_stream *xdr,
				     const struct nfs4_layoutreturn_args *args);

	void (*cleanup_layoutcommit) (struct nfs4_layoutcommit_data *data);

	void (*encode_layoutcommit) (struct pnfs_layout_hdr *layoutid,
				     struct xdr_stream *xdr,
				     const struct nfs4_layoutcommit_args *args);   
   #+END_SRC

** pnfs_layout_hdr
   #+begin_src 
	atomic_t		plh_refcount;
	struct list_head	plh_layouts;   /* other client layouts */
	struct list_head	plh_bulk_recall; /* clnt list of bulk recalls */
	struct list_head	plh_segs;      /* layout segments list */
	nfs4_stateid		plh_stateid;
	atomic_t		plh_outstanding; /* number of RPCs out */
	unsigned long		plh_block_lgets; /* block LAYOUTGET if >0 */
	u32			plh_barrier; /* ignore lower seqids */
	unsigned long		plh_retry_timestamp;
	unsigned long		plh_flags;
	loff_t			plh_lwb; /* last write byte for layoutcommit */
	struct rpc_cred		*plh_lc_cred; /* layoutcommit cred */
	struct inode		*plh_inode;
   #+end_src

** pnfs_device
   #+begin_src 
	struct nfs4_deviceid dev_id;
	unsigned int  layout_type;
	unsigned int  mincount;
	struct page **pages;
	unsigned int  pgbase;
	unsigned int  pglen;
   #+end_src

** pnfs_layout_segment
   #+begin_src
 	struct list_head pls_list;
	struct list_head pls_lc_list;
	struct pnfs_layout_range pls_range;
	atomic_t pls_refcount;
	unsigned long pls_flags;
	struct pnfs_layout_hdr *pls_layout;
   #+end_src

** pnfs_layout_range
   #+begin_src
 	u32 iomode;
	u64 offset;
	u64 length;
   #+end_src

** nfs4_pnfs_ds
   #+begin_src 
	struct list_head	ds_node;  /* nfs4_pnfs_dev_hlist dev_dslist */
	u32			ds_ip_addr;
	u32			ds_port;
	struct nfs_client	*ds_clp;
	atomic_t		ds_count;
	//仅仅包含ds的网络地址
   #+end_src

** nfs4_file_layout_dsaddr
   #+begin_src 
	struct nfs4_deviceid_node	id_node;
	unsigned long			flags;
	u32				stripe_count;
	u8				*stripe_indices;
	u32				ds_num;
	struct nfs4_pnfs_ds		*ds_list[1];
	//应该是layout所使用的数据地址信息.. GETDEVINFO..
   #+end_src

** nfs4_filelayout_segment
   #+begin_src 
	struct pnfs_layout_segment generic_hdr;
	u32 stripe_type;
	u32 commit_through_mds;
	u32 stripe_unit;
	u32 first_stripe_index;
	u64 pattern_offset;
	struct nfs4_file_layout_dsaddr *dsaddr; /* Point to GETDEVINFO data */
	unsigned int num_fh;
	struct nfs_fh **fh_array;
	// layout segment??
   #+end_src

** nfs4_filelayout
   #+begin_src 
	struct pnfs_layout_hdr generic_hdr;
	struct pnfs_ds_commit_info commit_info;
   #+end_src

** pnfs_commit_bucket
   #+begin_src 
	struct list_head written;
	struct list_head committing;
	struct pnfs_layout_segment *wlseg;
	struct pnfs_layout_segment *clseg;
	// commit使用的东西..??
   #+end_src

** pnfs_ds_commit_info
   #+begin_src 
	int nwritten;
	int ncommitting;
	int nbuckets;
	struct pnfs_commit_bucket *buckets;
   #+end_src

** find_pnfs_driver_locked(id)
   - id是pnfs_layoutdriver_type->id
   - 使用pnfs_modules_tbl管理pnfs_layoutdriver_type->pnfs_tblid
   - 查找pnfs_layoutdriver_type

** find_pnfs_driver(id)
   - 使用全局索pnfs_spinlock
   - 根据id查找pnfs_layoutdriver_type
   > find_pnfs_driver_locked(id)

** unset_pnfs_layoutdriver(nfs_server)
   - nfs_server->pnfs_curr_ld关联pnfs_layoutdriver_type
   - 释放对应的pnfs资源? 
   > pnfs_layoutdriver_type->clear_layoutdriver(nfs_server)
   - nfs_server->nfs_client->cl_mds_count表示什么资源? 释放mds? nfs_client应该是mds
   - 释放它使用的nfs4_deviceid_node, 看来nfs4_deviceid_node只是管理deviceid资源,而不能管理ds
   > nfs4_deviceid_purge_client(nfs_client)
   - 释放pnfs_layoutdriver_type 
   > module_put(pnfs_layoutdriver_type->owner)

** set_pnfs_layoutdriver(nfs_server, nfs_fh, id)
   - 设置nfs_server的pnfs资源
   - 检查nfs_server->nfs_client->cl_exchange_flags的EXCHGID4_FLAG_USE_NON_PNFS | EXCHGID4_FLAG_USE_NFS_MDS ?
   - 这里怎么是EXCHGID4_FLAG_USE_NON_PNFS??
   - 查找pnfs_layoutdriver_type 
   > find_pnfs_driver(id)
   - 如果找不到,查找驱动模块
   - 初始化使用nfs_fh? 
   > pnfs_layoutdriver_type->set_layoutdriver(nfs_server, nfs_fh)
   - 增加nfs_client->cl_mds_count
   - nfs_server->nfs_client应该是mds

** pnfs_register_layoutdriver(pnfs_layoutdriver_type)
   - 把pnfs_layoutdriver_type->pnfs_tblid放到pnfs_modules_tbl链表中 

** pnfs_unregister_layoutdriver(pnfs_layoutdriver_type)
   - 释放链表

** pnfs_get_layout_hdr(pnfs_layout_hdr)
   - 增加pnfs_layout_hdr->plh_refcount, 
   - 他管理inode的layout资源
   
** pnfs_alloc_layout_hdr(inode, gfp_flags)
   > nfs_client->pnfs_layoutdriver_type->alloc_layout_hdr(inode, gfp_flags)

** pnfs_free_layout_hdr(pnfs_layout_hdr)
   - pnfs_layout_hdr->plh_layouts在nfs_server->layouts
   - 释放这个链表 
   > put_rpccred(pnfs_layout_hdr->plh_lc_cred)

** pnfs_detach_layout_hdr(pnfs_layout_hdr)
   - 没有资源释放,直接设置nfs_inode->layout / write_io / read_io ?? 

** pnfs_put_layout_hdr(pnfs_layout_hdr)
   - 减小pnfs_layout_hdr->plh_refcount使用计数
   - 先释放nfs_inode   
   > pnfs_detach_layout_hdr(pnfs_layout_hdr)
   - 释放pnfs_layout_hdr, 使用回调函数
   > pnfs_free_layout_hdr(pnfs_layout_hdr)

** pnfs_iomode_to_fail_bit(iomode)
   - iomode只有3种, 错误有2种? 
   - IOMODE_RW/IOMODE_READ/IOMODE_ANY
   - NFS_LAYOUT_RO_FIALED / NFS_LAYOUT_RW_FAILED

** pnfs_layout_set_fail_bit(pnfs_layout_hdr, fail_bit)
   - 设置pnfs_layout_hdr->plh_retry_timestamp = jiffies 
   - 设置pnfs_layout_hdr->plh_flags的fail_bit
   - 如果原来没有,增加pnfs_layout_hdr->plh_refcount

** pnfs_layout_clear_fail_bit(pnfs_layout_hdr, fail_bit)
   - 清除pnfs_layout_hdr->plh_flags的fail_bit
   - 同时减小pnfs_layout_hdr->plh_refcount 

** pnfs_layout_io_set_failed(pnfs_layout_hdr, iomode)
   - 设置错误标志, 还要释放pnfs_layout_range资源 ?
   > pnfs_layout_set_fail_bit(pnfs_layout_hdr, pnfs_iomode_to_fail_bit(iomode)
   - 构造全局pnfs_layout_range, 用来获取目前所有的layout
   > pnfs_mark_matching_lsegs_invalid(pnfs_layout_hdr, list_head, pnfs_layout_range)
   - 释放他们  
   > pnfs_free_lseg_list(list_head)

** pnfs_layout_io_test_failed(pnfs_layout_hdr, iomode)


** GETDEVICEINFO, 根据deviceid4获取一个关于网络地址的2维队列. 
   device_addr4
   layouttype4  da_layout_type
   opaque     da_addr_body<>   

   da_addr_body的结构是
   nfsv4_1_file_layout_ds_addr4
    uint32_t  nflda_stripe_indices<>  数组大小就是stripe count
    multipath_list4 nflda_multipath_ds_list<>  这是二维数组,第一维是数据分布，第二维是数据分发备份.


** LAYOUTGET, 根据一些访问信息(layout_type,file,clientid,stateid,iomode,offset,length),获取layout的信息,虽然也返回stateid,但它会更新client已经获取的layout的stateid.  这里返回的是一串layout4,也就是说一个文件可以有多个layout4.

layout4
  offset4
  length4
  layoutiomode4
  layout_content4 lo_content
    layouttype4 loc_type
    opaque loc_body

loc_body的结构是: nfsv4_1_file_layout4
  deviceid4 nfl_deviceid
  nfl_util4 nfl_util   #unit size
  uint32_t  nfl_first_stripe_index  
  offset4   nfl_pattern_offset
  nfs_fh4   nfl_fh_list<>  #这里表示每个服务器上存储文件
  
从上面看来，还是很灵活的数据结构.


nfsv4_1_file_layout4

nfsv4_1_file_layout_ds_addr4

        //地址内容为tcp 和 ipv4/6
        struct netaddr4 {
                /* see struct rpcb in RFC 1833 */
                string na_r_netid<>; /* network id */
                string na_r_addr<>;  /* universal address */
        };

        typedef netaddr4 multipath_list4<>;

        /*
         * Encoded in the da_addr_body field of
         * data type device_addr4:
         */
********struct nfsv4_1_file_layout_ds_addr4 {
                //应该时一个strip中，每个unit对应的server在ds_list中的索引
                uint32_t        nflda_stripe_indices<>;
                //一系列data server的网络地址
                multipath_list4 nflda_multipath_ds_list<>;
        };

        //用于GETDEVICEINFO操作，获得nfs4_1_file_layout_ds_addr4
        const NFS4_DEVICEID4_SIZE = 16;
        typedef opaque  deviceid4[NFS4_DEVICEID4_SIZE];

        //表示一个layout
********struct nfsv4_1_file_layout4 {
            deviceid4      nfl_deviceid;
            //NFL4_UFLG_DENSE,NFL4_UFLG_COMMIT_THRU_MDS, stripe unit size
            nfl_util4      nfl_util;
            //strip中的unit从此开始计数
            uint32_t       nfl_first_stripe_index;
            offset4        nfl_pattern_offset;
            //file handle for data server in nflda_multipath_ds_list
            nfs_fh4        nfl_fh_list<>;
        };

        使用这两个数据结构，可决定访问某个unit的数据使用的data server地址和filehandler.



