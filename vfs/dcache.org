* dcache.c

** dentry
   #+BEGIN_SRC 
	/* RCU lookup touched fields */
	unsigned int d_flags;		/* protected by d_lock */
	seqcount_t d_seq;		/* per dentry seqlock */
	struct hlist_bl_node d_hash;	/* lookup hash list */
	struct dentry *d_parent;	/* parent directory */
	struct qstr d_name;
	struct inode *d_inode;		/* Where the name belongs to - NULL is
					 * negative */
	unsigned char d_iname[DNAME_INLINE_LEN];	/* small names */

	/* Ref lookup also touches following */
	unsigned int d_count;		/* protected by d_lock */
	spinlock_t d_lock;		/* per dentry lock */
	const struct dentry_operations *d_op;
	struct super_block *d_sb;	/* The root of the dentry tree */
	unsigned long d_time;		/* used by d_revalidate */
	void *d_fsdata;			/* fs-specific data */

	struct list_head d_lru;		/* LRU list */
	/*
	 * d_child and d_rcu can share memory
	 */
	union {
		struct list_head d_child;	/* child of parent list */
	 	struct rcu_head d_rcu;
	} d_u;
	struct list_head d_subdirs;	/* our children */
	struct hlist_node d_alias;	/* inode alias list */   
   #+END_SRC

** dentry_operations
   #+BEGIN_SRC 
	int (*d_revalidate)(struct dentry *, unsigned int);
	int (*d_weak_revalidate)(struct dentry *, unsigned int);
	int (*d_hash)(const struct dentry *, struct qstr *);
	int (*d_compare)(const struct dentry *, const struct dentry *,
			unsigned int, const char *, const struct qstr *);
	int (*d_delete)(const struct dentry *);
	void (*d_release)(struct dentry *);
	void (*d_prune)(struct dentry *);
	void (*d_iput)(struct dentry *, struct inode *);
	char *(*d_dname)(struct dentry *, char *, int);
	struct vfsmount *(*d_automount)(struct path *);
	int (*d_manage)(struct dentry *, bool);   
   #+END_SRC

** d_hash(dentry, hash)
   - 计算dentry在dentry_hashtable中的hash索引

** __d_free(rcu_head)
   - 使用rcu释放dentry内存, 还有dentry->d_name
   - 这是保证dentry->d_alias不在hash表中?

** d_free(dentry)
   - 释放dentry, 要求dentry->d_count == 0
   > dentry->dentry_operations->d_release(dentry)
   - 如果dentry->d_flags有DCACHE_RCUACCESS, 表示使用rcu访问过
   - 在路径查找中有2种,一种是rcu, 一种是锁方式
   - 如果有DCACHE_RCUACCESS, 使用rcu释放
   > call_rcu(dentry->d_u->d_rcu, __d_free)
   - 否则直接释放 
   > __d_free(dentry->d_u.d_rcu)
   - 在d_kill中使用

** dentry_rcuwalk_barrier(dentry)
   - 使rcu遍历方式失效, rcu怎么使用seq??
   > write_seqcount_barrier(dentry->d_seq)

** dentry_iput 
   - 在d_kill中使用,它是释放dentry和inode的关系
   - 设置dentry->d_inode = NULL, d_alias现在成了hash表
   > hlist_del_init(dentry->d_alias)
   - 如果inode->i_nlink ==0, 同法fsnotify消息?
   > fsnotify_inoderemove
   - d_iput就是调用了iput,释放inode->i_count计数
   - 如果没有使用, 放到lru队列中
   - nfs实现了，释放sillyrename和子目录的缓存
   > d_op->d_iput(dentry, inode)

** dentry_unlink_inode(dentry)
   - 和上面一样, 释放dentry->d_alias
   - ruc的访问方式和seq_lock一块,无效这种访问方式
   > dentry_rcuwalk_barrier(dentry)
   - 释放inode计数 
   > dentry->d_op->d_iput(dentry, inode)
   - 在d_delete中使用, 在删除inode时使用
   - 变为negative的dentry

** dentry_lru_add(dentry)
   - 把dentry->d_lru放到super_block->s_dentry_lru队列中
   - 增加super_block->s_nr_dentry_unused计数
   - 在dput中调用

** __dentry_lru_del(dentry) 
   - 释放dentry->d_lru链表
   - 去掉dentry->d_flags的DCACHE_SHRINK_LIST标志
   - 减小super_block->d_nr_dentry_unused

** dentry_lru_del(dentry)
   - 使用dcache_lru_lock锁
   > __dentry_lru_del(dentry)
   - dentry->d_lru不仅仅放到super_block中,还有用来收集需要释放的dentry

** dentry_lru_move_list(dentry, list_head)
   - list_head用来收集需要释放的dentry 
   - 如果dentry->d_lru为空,把它放到list_head链表中
   - 否则移动到最后面

** d_kill(dentry, dentry parent) 
   - 释放dentry的内存,现在已经在hash和lru中释放
   - 释放dentry->d_u->d_child, 从父目录中释放
   - 设置dentry->d_flags 的DCACHE_DISCONNECT, 表示不再可用
   - 只有在回朔删除父dentry时才使用
   - 释放和inode的关系
   > dentry_iput(dentry) 
   - 释放自己
   > d_free(dentry) 

** __d_shrink(dentry)
   - 释放hash表关系, 如果不在hash表中,直接返回
   > d_unhashed(dentry)
   - dentry使用2中hash链表
   - 一个是suepr_block->s_anon, 另一个是dentry_table
   - 释放时需要hash表头的锁
   - dentry->d_flags的DCACHE_DISCONNECTED表示在anon链表中
   > hlist_bl_lock(hlist_bl_head)
   > __hlist_bl_del(dentry->d_hash)

** __d_drop(dentry)
   - 这里是释放hash表, 至少使dentry无法访问
   - 检查是否在hash表中
   > d_unhashed(dentry)
   > __d_shrink(dentry)
   > dentry_rcuwalk_barrier(dentry)

** d_drop(dentry)
   - 释放dentry->d_lock锁住 
   > __d_drop(dentry)

** dentry_kill(dentry, ref)
   - 释放dentry, 返回d_parent,可以回朔回收
   - 先找到父目录, 锁住inode->i_lock和parent->d_lock
   - 如果ref有效, 减小dentry->d_count
   - 如果dentry->flags有DCACHE_OP_PRUNE
   - 通知文件系统dentry要释放
   > dentry->d_op->d_prune(dentry)
   - 释放lru链表
   > dentry_lru_del(dentry)
   - 释放hash表
   - __d_drop(dentry)
   - 释放inode, 父dentry, 还有自己
   - d_kill(dentry, parent)

** dput(dentry)  
   - 减小dentry->d_count, 如果d_count减到0,则释放它
   - 如果d_count没有到0，则返回
   - 如果dentry->flags有DCACHE_OP_DELETE,回调函数决定是否直接删除
   - 对于nfs来说,检查对应的inode是否有错误 nfs_dentry_delete
   > d_ops->d_delete(dentry)
   - 如果不在hash表中, 直接释放
   > d_unhashed(dentry)
   - 否则不会释放,放到lru队列中,设置DCACHE_REFERENCED标志.
   > dentry_lru_add(dentry)
   > dentry->d_count --
   - 如果要释放, 函数返回d_parent, 回朔释放
   > dentry_kill(dentry, 1)

** d_invalidate(dentry)
   - 如果dentry不在hash表中,则不处理, 已经无效
   - 如果dentry->d_subdirs不是空,有子dentry
   - 去遍历它的子树，收集没有使用的释放
   - shrink_dcache_parent(dentry) 
   - 如果dentry->d_count > 1, 而且inode有效, 而且是目录,返回-EBUSY
   - 释放hash表关系, 表示不在vfs的树中,只是没有释放
   > __d_drop(dentry) 

** 总结
   - 释放有很多种
   - 一种是放到lru队列中 dput
   - 一种是有条件的直接释放 kill
   - 一种是释放hash表关系, invalidate/drop
   - 下面还有一种,释放整个super_block的dentry
   - 如果没有关联inode,是negative, 而且没有使用者, 虽然在hash表里面

** __dget_dlock / __dget(dentry) 
   - 修改dentry->d_count

** dget_parent(dentry) 
   - 使用dentry->d_lock锁住
   - 增加d_parent的计数

** __d_find_alias(inode, want_discon)
   - 找一个inode关联的dentry,增加计数
   - 遍历inode->i_dentry链表中的dentry
   - 过滤掉不是文件夹也不在hash表中的, 那些是无效的
   - 如果want_discon=1, 必须找一个root,而且是DCACHE_DISCONNECTED的dentry
   - 否则必须找一个不是root, 而且不带DCACHE_DISCONNECTED的
   > __dget_dlock(dentry)

** d_find_alias(inode)
   - 使用dinode->i_lock锁住, 找一个正常的dentry
   > __d_find_alias(inode, 0)

** d_prune_aliases(inode)
   - 释放inode关联的dentry 
   - 遍历inode->i_dentry链表中的dentry
   - 只处理dentry->d_count ==0的 
   > __dget_dlock(dentry)
   - 释放hash表关系
   > __d_drop(dentry)
   - 再释放计数, 如果没有其他人使用,这时应该会释放
   - 因为d_drop释放hash关系
   > dput(dentry)

** try_prune_one_dentry(dentry) 
   - 这个dentry已经不再使用, 这是使用lru回收的
   - 先释放自己
   > dentry_kill(dentry, 0)
   - 如果parent->d_count>1,有别人使用它
   - 减小计数, 直接返回
   - 否则继续回朔释放
   - dentry_kill(dentry, 1)  

** 总结
   - dentry释放的锁有4种
   - 上面的操作应该是获取dentry->d_lock
   - 在开始释放时,获取inode/parent的索
   - 里面有hash操作,使用自己的索
   - 然后释放d_child链表, 设置DCACHE_DENTRY_KILLED, 释放parent->d_lock
   - 然后释放inode关系,释放inode锁
   - 最后再释放自己之前,释放d_lock

** shrink_dentry_list(list_head) 
   - 删除一队列的dentry, 队列使用d_lru, 遍历这些dentry
   - 如果dentry->d_count > 0, 不能释放
   - 只是释放lru链表,从当前链表中释放
   - 否则释放它,而且释放父dentry
   > try_prune_one_dentry(dentry)

** shrink_dcache_sb(super_block, count) 
   - 尝试super_block中空闲的dentry
   - 遍历super_block->s_dentry_lru
   - 如果dentry带标志DCACHE_REFERENCED,则把它放回去
   - 否则放到临时链表中,最后集中释放
   - 这里使用dcache_lru_lock保护,和上面的lru操作很想
   - shrink_dentry_list(list)

** shrink_dcache_sb(super_block)
   - 释放整个super_block->s_dentry_lru链表, 直到为空
   > shrink_dentry_list(list_head)

** shrink_dcache_for_umount_subtree(dentry) 
   - umount时使用,释放super_block的所有dentry
   - dentry必须是root
   - 使用树的深度优先遍历, 删除dentry
   - 开始循环, 先到最底层的dentry, d_subdirs为空
   - 通知fs
   > d_op->d_prune(dentry)
   - 释放lru和hash关系
   > dentry_lru_prune(dentry)
   > __d_shrink(dentry)
   - 如果dentry->d_count >0, 报错
   - 释放父dentry的关系
   - list_del(dentry->d_u->d_child)
   - 释放inode关系
   > hlist_del_init(dentry->d_alias)
   > d_op->d_iput(dentry, inode)
   - 最后释放自己
   > d_free(dentry)
   - 这里没有使用任何锁??

** shrink_dcache_for_umount(super_block)
   - 首先释放super_block->s_root对应的子树
   > shrink_dcache_for_umount_subtree(dentry)
   - 然后是super_block->s_anon链表上的
   - 链表使用dentry->d_hash?? 上面可能有遗漏的
    -这里不会干扰上面的释放,因为不会增加计数
   - 遍历hash表上的dentry
   > shrink_dcache_for_umount_subtree(dentry)
   - 在关闭super_block中调用
   > kill_anon_super(super_block)
   > generic_shutdown_super(super_block)
   > shrink_dcache_for_umount(super_block)
	
** try_to_ascend(old, locked, seq) 
   - 找dentry->d_parent 
   - 如果old->flags有DCACHE_DENTRY_KILLED, 或者seq和rename_lock不一致, 返回NULL

** have_submounts(parent)
   - 检查parent的子树的文件夹中,是否有mountpoint
   - dentry->d_flags的DCACHE_MOUNTPOINT表示它是mountpoint
   > d_mountpoint(dentry)
   - 因为这里是有序树,而且遍历的时候树的结构不会改变, 可以使用循环的方式表示递归
   - 刚才写了python, 不需要有序,但删除的操作,也可实现

** select_parent(dentry, list_head ) 
   - 遍历dentry的子树,回收d_count为0的dentry
   - 如果d_count>0, 从lru队列中释放
   > dentry_lru_del(dentry)
   - 如果dcache->d_flags没有DCACHE_SHRINK_LIST,说明没有在回收
   - 可以放到参数链表中,防止循环,添加DCACHE_SHRINK_LIST标志
   > dentry_lru_move_list(dentry, dispose) 
   - 这个dentry应该是最下层,否则它的计数不能为0
   - 这里遍历使用2遍,第一次是read方式的rename_lock, 第二遍是write方式的rename_lock
   - 在遍历回朔时, 检查parent关系是否改变,以及rename_lock是否改动
   - 遍历时会检查d_parent是否为NULL, 
   - 但d_lru链表的修改使用dentry->d_lock

** shrink_dcache_parent(dentry)
   - 回收dentry目录下不使用的dentry 
   > select_parent(parent, list_head)
   - 不使用的直接释放
   > shrink_dentry_list(list_head)

** __d_alloc(sb, name) 
   - 创建dentry
   - 根据参数这里只设置super_block和name, 还有super_block->d_ops
   - 会增加parent的计数, 同时把dentry放到parent->d_u.d_child队列中.

** d_alloc(parent, name)  
   - 创建dentry
   > __d_alloc(parent->super_block, name)
   - 增加parent->d_count计数
   > __dget_dlock(parent)
   - 把dentry->d_u->d_child放到parent->d_subdirs链表中

** d_alloc_pseudo(super_block, name)
   - 创建一个dentry 
   > __d_alloc(super_block, name)
   - 设置dentry->d_flags的DCACHE_DISCONNECTED
   
** d_alloc_name(parent, name)
   - 上面的name都是qstr, 这里包装一下
   > d_alloc(parent, dentry)

** d_set_d_op(dentry, dentry_operations)
   - 设置dentry->d_op = dentry_operations
   - 每个dentry_operations的函数对应一个标志DCACHE_

** __d_instantiate(dentry, inode) 
   - 建立dentry和inode的关系, 把dentry放到inode->i_dentry队列中
   - 如果inode是AUTOMOUNT,设置dentry->d_flags的DCACHE_NEED_AUTOMOUNT
   > dentry_rcuwalk_barrier(dentry)

** d_instantiate(dentry, inode) 
   - 有了inode的dentry就不是negative的dentry, 但dentry的计数还是不变
   - 必须保证dentry不在hash表中, 也就是无效的
   > hlist_unhashed(dentry->d_alias)
   > __d_instantiate(dentry, inode)

** __d_instantiate_unique(dentry, inode)
   - 而对inode的使用计数在外部已经增加
   - 和上面的区别时,这里先遍历inode->i_dentry链表
   - 比较是否有重复的, hash, d_parent, name
   > __d_instantiate(dentry, inode)

** d_instantiate_unique(dentry, inode)
   - 关联inode/dentry, 如果有重复的,返回已经关联的dentry 
   > __d_instantiate_unique(dentry, inode)

** d_make_root(inode) 
   - 创建dentry,name="/",然后关联inode
   > __d_alloc(inode->i_sb, name)
   > d_instantiate(dentry, inode)
   - 这里也没有增加inode计数??

** __d_find_any_alias(inode) 
   - 从inode->i_dentry队列上去一个dentry
   > hlist_entry(inode->i_dentry.first, struct dentry, d_alias)
   - 增加使用计数
   - __dget(dentry)

** d_find_any_alias(inode)
   - 锁住inode 
   > __d_find_any_alias(inode)

** d_obtain_alias(inode)
   - 先查找一个
   > d_find_any_alias(inode)
   - 如果找不到,就创建一个
   > __d_alloc(inode->i_sb, string) 
   - 设置DCACHE_DISCONNECTED, 关联inode和dentry的关系, 把这个创建的dentry放到inode->i_sb->s_anon中
   - 这个dentry是临时的,没有在parent的树中,也没有在hash表中
   - 名字是'/', 也是anonymous

** d_splice_alias(inode, dentry) 
   - 关联inode和dentry
   - 如果inode是目录,首先找是否有DCACHE_DISCONNECTED的dentry
   - __d_find_alias_inode(inode, 1)
   - 把找到的dentry放到参数dentry的位置,而且切换name
   - d_move(new, dentry)
   - 没有空闲的，就关联这两个 
   > __d_instantiate(dentry, inode)
   - 重新插入到hash表中
   > d_rehash(dentry)
   - 对于普通文件,就直接关联,同时重新计算hash表位置
   > d_add(dentry,inode) 

** d_add_ci(dentry, inode, name)
   - 首先在父目录下面找一个name的文件
   > d_hash_and_lookup(dentry->d_parent, name) 
   - 如果没找到，就创建一个
   > d_alloc(dentry->d_parent, name)
   - 然后建立和inode的联系
   > d_splice_alias(inode, new)
   - 如果找到了,而且关联同样的inode,返回找到的dentry
   - 应该没有关联inode, 也就是negative的
   - d_splice_alias(inode, dentry)
   - 只有ntfs和xfs使用

** 总结
   - 创建有两种，一种指定parent, 另一种不指定
   - 两种都要有super_block
   - 使用parent的，创建后就会放到parent的孩子队列中
   - 然后可以关联inode，同时把它inode的alias队列中
   - 然后考虑放到hash队列中,但放到hash队列中
   - 主要在find操作中使用,检查是否已有存在的dentry,有的话用存在的
   - 没有的话创建新的,并关联inode，放到hash队列中.

** __d_lookup_rcu(parent, name, seq, inode) 
   - 在parent下面找name对应的dentry
   - 这里不是遍历dentry->d_subdirs, 而是使用hash表??
   - 使用dentry->d_seq包含
   - 过滤掉不在hash表中的dentry
   > d_unhashed(dentry)
   - 比较name和dentry->d_name 
   > slow_dentry_cmp(parent, dentry, seq, name)

** d_lookup(parent, name)
   - 使用rename_lock保护 
   > __d_lookup(parent, name)

** __d_lookup(dentry, name)
   - 和__d_lookup_rcu相同, 不过这里使用ruc的锁
   > rcu_read_lock()
   - 没有使用seq锁, 如果找到,增加dentry->d_count 

** d_hash_and_lookup(dentry, name)
   - 在dentry目录下,查找name对应的dentry 
   > d_lookup(dentry, name)
   - 这里是增加dentry->d_count

** d_validate(dentry, parent) 
   - 通过查找parent->d_subdir, 验证dentry没问题
   - 增加dentry的计数，没人用！

** d_delete(dentry) 
   - 在删除文件时删除dentry
   - 如果dentry没人用, 把dentry变为negative的
   - 否则把它在hash队列中删除
   - 如果dentry->d_count ==1,变成一个negative的文件
   - 只有当前操作路径在使用?
   - 锁住d_lock, inode->i_lock, 这里会循环等待锁
   - 去掉dentry->d_flags的DCACHE_CANT_MOUNT??
   - 释放和inode的关系, 仅仅变成negative的
   - dentry_unlink_inode(dentry)
   - 否则, d_count会是多少??
   - 如果dentry在hash表中, 释放hash表关系 
   > d_unhashed(dentry)
   > __d_drop(dentry)

** __d_rehash(dentry, hlist_bl_head)
   - 设置dentry->d_flags的DCACHE_RCUACCESS, 重新把dentry放到hash队列中

** _d_rehash(dentry, hlist_bl_head)
   > __d_rehash(dentry)

** d_rehash(dentry)
   - 使用dentry->d_lock锁 
   > _d_rehash(dentry)

** __d_move(dentry, target) 
   - 交换两个dentry, 包括name,parent,subdir,hash. 
   - target虽然没有释放,但不在hash队列中
   - 只要回收函数一看，就立即释放它， 但另一个会进入hash队列

** d_move(dentry, target)
   - 使用rename_lock保护
   > __d_move(dentry, target)
   - 这就是rename的实现??

** d_ancestor(dentry p1, p2)
   - 使用dentry->d_parent向上遍历,检查p1是否是p2的上层目录

** __d_unalias(inode, dentry, alias)
   - 修改inode的文件名? 这里的锁非常复杂
   > __d_move(alias, dentry)


** __d_materialise_dentry(dentry, anon) 
   - 好像也是交换dentry和anon的内容,去掉anon的DCACHE_DISCONNECTED
   - 没有hash表的操作, 只有d_child/d_subdirs的操作

** d_materialise_unique(dentry, inode) 
   - 同样是关联dentry和inode
   - 如果inode是目录, 必须保证只有一个dentry
   - 查找是否存在dentry
   > __d_find_alias(inode, 0)
   - 如果是root,直接代替原来的, 而且需要调整hash表的位置
   > __d_materialise_dentry(dentry, alias)
   - 释放原来的dentry
   - __d_drop(dentry)
   - 如果是正常的dentry, 相当于rename操作?
   > __d_unalias(inode, dentry, alias) 
   - 如果找不到alias,或者是非目录,允许多个dentry?
   > __d_instantiate_unique(dentry, inode)
   - 最后调整hash队列
   > _d_rehash(dentry) 


** 总结
   dcache->flags的DCACHE_DISCONNECTED到底是什么时候使用??

* namei.c

  - dcache中树的查找有两种
  - 一种使用rcu/seqcount,另一种是refcount
  - 第二种更安全一些,因为它在查找时增加dentry的计数.

** path 
   #+BEGIN_SRC 
	struct vfsmount *mnt;
	struct dentry *dentry;   
   #+END_SRC

** path_get(path)
   > mntget(path->mnt)
   > dget(path->dentry)

** path_put(path)
   > dput(path->dentry)
   > mntput(path->mnt)

** nameidata
   #+BEGIN_SRC 
	struct path	path;
	struct qstr	last;
	struct path	root;
	struct inode	*inode; /* path.dentry.d_inode */
	unsigned int	flags;
	unsigned	seq;
	int		last_type;
	unsigned	depth;
	char *saved_names[MAX_NESTED_LINKS + 1];   

	enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};

	LOOKUP_FOLLOW(symlink)
	LOOKUP_DIRECTORY  找一个directory
	LOOKUP_AUTOMOUNT 不错在的目录?
	LOOKUP_PARENT ??
	LOOKUP_REVAL : 需要验证dcache中的目录信息
	LOOKUP_RCU ??

	LOOKUP_ROOT ??
	LOOKUP_OPEN  打开目录?
	LOOKUP_CREATE
	LOOKUP_EXCL
	LOOKUP_RENAME_TARGET ?? 
	LOOKUP_JUMPED 在绝对路径跳转时,设置这个标志
	LOOKUP_EMPTY

   #+END_SRC

** unlock_rcu_walk()
   - 锁住vfsmount_lock, lock/global锁
   > rcu_read_lock

** unlock_rcu_walk()
   > rcu_read_unlock()
   > br_read_unlock(vfsmount_lock)

** __d_rcu_to_refcount(dentry, seq)
   - 如果seq == dentry->d_seq, 表示没有改变,可以使用
   - 增加dentry->d_count

** unlazy_walk(nameidata, dentry)
   - 从rcu-walk变为ref-walk
   - dentry是nameidata->path->dentry的子dentry
   - nameidata->flags必须有LOOKUP_RCU
   - 检查nameidata->root, 如果nameidata->flags没有LOOKUP_ROOT 
   - 则设置want_root = 1, 而且比较nameidata->root和current->fs, 如果不一致返回错误?
   - 当前位置是nameidata->path下面, 它只想nameidata->inode
   - 如果dentry == NULL, 表示没找到?
   - 检查parent是否改变
   - __d_rcu_to_refcount(dentry, seq) 
   - 如果dentry有效
   - 检查dentry->parent是否和nameidata->parent一致
   - 检查dentry是否改变,增加dentry的计数
   > __d_rcu_to_refcount(dentry, nameidata->seq)
   - 如果没有改变,还要增加parent->d_count??
   - 如果上面设置want_root =1, 增加naemidata->root计数
   > path_get(nameidata->root)
   - 最后增加vsfmount计数, 所以dentry和vfsmount的计数都增加了
   > mntget(nameidata->path->mnt)
   - 最后去掉LOOKUP_RCU
   - 如果上面检查有错误,都返回-ECHILD

** d_revalidate(dentry, flags)
   - 检查是否有效?
   > dentry->d_op->d_revalidate(dentry, flags)

** complete_walk(nameidata) 
   - 查找路径完成时的操作
   - 如果是rcu-walk, 转变为ref-walk
   - 如果nameidata->flags没有LOOKUP_ROOT, 设置nameidata->root->mnt = NULL?? 
   - 检查当前目录的有效性 nameidata->path->dentry
   > __d_rcu_to_refcount(dentry, nameidata->seq)
   - 如果返回错误,说明有路径变化,返回-ECHILD
   - 否则继续,增加nameidata->path->mnt计数, 又和dentry一致
   - mntget(nameidata->path.mnt)
   - 如果nameidata->flags没有LOOKUP_JUMPTED?? 可以返回?
   - 最后验证, 为何不用d_revalidate?
   - 只有nfs使用它?
   > d_op->d_weak_revalidate(dentry, namiedata->flags)

** set_root(nameidata)
   - 如果nameidata->root->mnt == NULL??
   - 设置nameidata->root = current->fs->root
   - 同时增加path的计数

** set_root_rcu(namiedata)
   - rcu-walk方式，设置nameidata->root
   - nameidata->root = current->fs->root
   - nameidata->seq = nameidata->root->dentry->d_seq
   - 并没有增加计数

** __vfs_follow_link(nameidata, link_name)
   - 如果link_name是绝对路径(以"/"开头), 重新设置nameidata 
   - 使用ref-walk方式?
   > set_root(nameidata)
   - 当前路径改为root, nameidata->path = nameidata->root
   - 增加计数, 设置LOOKUP_JUMPTED
   - path_get(nd->path)
   - 设置nameidata->inode = nameidata->path->dentry->inode
   - 开始查找
   > link_path_walk(link, nd)

** path_put_conditional(path, nameidata)
   - 释放path的计数
   > dput(path->dentry)
   - vfsmount只有和当前的不一样时,才释放, path->mnt != nameidata->path->mnt
   > mntput(path->mnt)
   
** path_to_nameidata(path, nameidata)
   - 修改nameidata的当前目录??
   - 如果不是rcu-walk, 还要释放已有的计数
   > dput(nameidata->path->dentry)
   - 如果nameidata和path->mnt相同,不用释放
   > mntput(nameidata->path->mnt)
   - 但不会增加参数path的计数,rcu-walk和ref-walk都可使用
   - ref-walk需要在外部增加

** nd_jump_link(nameidata, path)
   - 直接设置nameidata的当前目录, 应该是ref-walk方式
   > path_put(nameidata->path)
   - 设置nameidata->path/inode,还有LOOKUP_JUMPED

** put_link(nameidata, path, cookie)
   - cookie里面时symlink的路径,释放它 
   > inode->i_op->put_link(dentry, nameidata, cookie)
   - 释放path计数
   > path_put(link)

** may_follow_link(path, nameidata)
   - path指向symlink文件,检查是否可以展开?
   - 如果有问题,返回-EACCESS

** safe_hardlink_source(inode)
   - link操作时的检查

** may_linkat(path)
   - 在linkat的syscall中,检查是否满足条件
   - 这里在内存在已经关联?
   - 文件是path->dentry->d_inode, 位置就是dentry

** follow_link(path link, nameidata, p)
   - 展开symlink, 必须是ref-walk方式查找
   - link和nameidata->path什么关系?  
   - link应该是当前目录下的一个文件
   - 使用i_ops, 获取symlink文件的路径
   - 把它放到nameidata->saved_names[depth]中
   > dentry->d_inode->i_op->follow_link(dentry, nameidata)
   - 开始遍历展开
   > __vfs_follow_link(nameidata, string)

** follow_up_rcu(path) 
   - 使用rcu保护的路径向上走,跨越mount
   - 如果path->mnt没有父mount,则返回0
   - 更换path = {path->mnt=>mnt_parent->mnt_mountpoint, path->mnt=>mnt_parent->mnt}

** follow_up(path)
   - ref-walk方式的向上查找
   - 同样跨越mount
   - 使用mnt->mnt_mountpoint, mnt_parent->mnt
   - 同时增加新的计数,释放老的计数

** follow_automount(path, flags, need_mntput)
   - 检查是否要去mount 
   - flags中没有LOOKUP_PARENT/LOOKUP_DIRECTORY/LOOKUP_OPEN/LOOKUP_CREAT/LOOKUP_AUTOMOUNT, 而且dentry->inode有效,不再mount
   - 根据注释,这是statde操作
   - 获取vfsmount
   > path->dentry->d_op->d_automount(path)
   - 挂在到dentry上面
   > finish_automount(mnt, path) 
   - 切换path, 指向新的vfs的根dentry

** follow_managed(path, flags) 
   - 处理特殊的dentry 
   - dentry->d_flags包括DCACHE_MOUNTED, DCACHE_NEED_AUTOMOUNT, DCACHE_MANAGE_TRANSIT
   - 对于DCACHE_MANAGE_TRANSIT
   - d_op->d_manage(path->dentry, false) 
   - 对于DCACHE_MOUNTED, 表示它是mountpoint,需要跨越vfs
   - 先找到mountpoint的vfsmount
   > lookup_mnt(path)
   - 更新path指向的dentry/vfsmount
   - 对于DCACHE_NEED_AUTOMOUNT,里面回更新path
   - follow_automount(path, flags, need_mntput) 
   - 这里返回是否需要释放path原来的vfsmount的计数???

** follow_down_one(path)
   - 向下查找，跨越mountpoint
   > lookup_mnt(path)
   - 更新path, 同时修改计数

** managed_dentry_might_block(dentry)
   - 执行DCACHE_MANAGE_TRANSIT对应的操作
   > d_op->d_manage(dentry, true)

** __follow_mount_rcu(nameidata, path, inode)
   - rcu的方式向下查找, 用来跨越mountpoint
   - 循环查找mountpoint 
   - 首先检查d_manage, 只有autofs使用, 而且不允许rcu-walk
   > managed_dentry_might_block(dentry)
   - 如果是autofs,直接返回false
   - 查找vfsmount 
   > __lookup_mnt(path->mnt, path->dentry, 1)
   - 切换path, 没有计数操作
   - 添加nameidata->flags的LOOKUP_JUMPED
   - 设置nameidata->seq = path->dentry->d_seq

** follow_mount_rcu(nameidata)
   - 不考虑d_manage的扩展
   - 循环查找nameidata->path的mountpoint, 直接修改当前路径?
   > __lookup_mnt(nameidata->path->mnt
   - 更新path/seq

** follow_dotdot_rcu(nameidata)
   - 这里是循环处理,跳过mountpoint
   - 如果nameidata->path和nameidata->root一样，直接退出
   - 如果nameidata->path->dentry不是path->vfsmount->mnt_root,可以向上查找
   - 首先检查nameidata->seq和path->dentry->s_seq, 如果不一致返回-ECHILD
   - 直接更新nameidata->path->dentry, seq, 这两个必须是一致的
   - 然后直接退出
   - 否则它需要向上跨越mountpoint
   > follow_up_rcu(nameidata->path)
   - 然后检查新的dentry是否被别人mount??
   > follow_mount_rcu(nameidata)

   - 基本上是先向上查找
   - 遇到nameidata->root退出
   - 遇到vfsmount->root,向上跳过vfsmount, 而且继续.
   - 否则向上d_parent, 然后退出
   - 退出之后检查是否是mountpoint

** follow_down(path)  
   - 这个函数和follow_managed类似,但这里不会处理DCACHE_NEED_AUTOMOUNT,nfsd使用它.
   - 处理DCACHE_MANAGE_TRANSID, 对应d_ops->d_manage
   - 处理DCAHCE_MOUNTED,向下跨越mountpoint

** follow_mount(path)
   - 只跨越mountpoint, 检查dentry->d_flags的DCACHE_MOUNTED标志
   - 这里是计数模式的遍历

** follow_dotdot(nameidata)
   - nameidata->root->mnt表示root是否无效?
   - 使用current->fs_struct->root
   > set_root(nameidata)
   - 如果nameidata->path不是root节点,更新nameidata->path->dentry
   - 否则向上跳跃,然后再向上遍历
   > follow_up(nameidata->path)
   - 然后处理mountpoint 
   > follow_mount(nameidata->path)

** lookup_dcache(qstr name, dentry dir, flags, need_lookup)
   - 从dir下面查找name对应的dentry
   - 去hash表中查找
   > d_lookup(dentry, name)
   - 如果找到，而且dentry->d_flags有DCACHE_OP_REVALIDATE
   > d_revalidate(dentry, flags)
   - 如果返回0,返回的dentry无效,释放它 
   > dput(dentry)
   - 如果<0, 返回错误
   - 如果找不到,创建一个, 设置need_lookup=true
   > d_alloc(dir, name)

** lookup_real(inode, dentry, flags)
   - 使用i_ops操作, inode是目录,dentry是子文件
   > dentry->inode->lookup(dir, dentry, flags)

** __lookup_hash(name, dentry parent, flags)
   - 先在hash中查找 
   > lookup_dcache(name, parent, flags, need_lookup)
   - 如果上面没有找到,也就是need_lookup = 1, 使用i_ops查找
   - 所以下面dentry是新创建的
   > lookup_real(dentry->inode, dentry/name, flags)

** lookup_fast(nameidata, path, inode)
   - 在nameidata->path目录下面查找nemaidata->last
   - 如果使用rcu模式遍历, nameidata->flags包含LOOKUP_RCU
   - 在hash表中查找,seq是返回的dentry->d_seq
   > __d_lookup_rcu(parent, nameidata->last, seq)
   - 找到dentry, 替换nameidata->path
   - 先检查seq, 包括刚找到的,还有nameidata->seq
   > __read_seqcount_retry(dentry->d_seq, seq)
   - 调用DCACHE_OP_REVALIDATE
   > d_revalidate(dentry, nameidata->flags)
   - 处理mountpoint, 同时修改path/inode/seq
   - 只会跨越mountpoint和DCACHE_MANAGE_TRANSIT
   > __follow_mount_rcu(nameidata, path, inode)
   - 然后检查DCACHE_NEED_AUTOMOUNT, 如果没有可以直接退出
   - 上面的所有操作如果不是-ECHILD错误,都会转化为ref模式
   > unlazy_walk(nameidata, dentry)
   - 这里dentry不一定是有效的
   - 去掉nameidata->flags的LOOKUP_RCU, 而且增加nameidata->path/dentry的计数
   - 如果nameidata->root->mnt有效,而且flags没有LOOKUP_ROOT,还有增加nameidata->root的计数
   - 它必须是current->fs_struct->root
   - 如果开始不是rcu模式
   - 同样是查找,找到后立即增加dentry->d_count
   > __d_lookup(parent, nameidata->last)
   - 然后处理DCACHE_OP_REVALIDATE
   > d_revalidate(dentry, nameidata->flags)
   - 如果上面返回0,说明什么? 
   > d_invalidate(dentry)
   - 处理mountpoint, 处理DCACHE_MANAGED_DENTRY的所有情况
   > follow_managed(path, namiedata->flags)
   - 如果上面2种情况都没找到, 返回1,应该会调用i_ops的查找

** lookup_slow(nameidata, path)
   - 这里当然使用ref模式查找
   - 先查找hash表,查找失败时,使用i_ops操作
   > __lookup_hash(nameidata->last, parent, nameidata->flags)
   - 处理mountpoint
   - follow_managed(path, nameidata->flags)
   - 如果跨越了mountpoint, 设置nameidata->flags的LOOKUP_JUMPTED

** may_lookup(nameidata)
   - 检查permission?
   - 如果是rcu模式 
   > inode_permission(nameidata->inode, MAY_EXEC|MAY_NOT_BLOCK)
   - 如果返回不是-ECHILD, 直接返回
   - 否则变为ref模式
   - unlazy_walk(nameidata, NULL)
   - 然后重新检查
   > inode_permission(nameidata->inode, MAY_EXEC)

** handle_dots(nameidata, type)
   - 只处理type == LAST_DOTDOT的情况?
   - 如果是rcu模式, nameidata->flags包含LOOKUP_RCU 
   - 再处理path指针时,都没有增加计数
   > follow_dotdot_rcu(nameidata)
   - 如果是ref模式
   > follow_dotdot(nameidata)
   - 直接处理nameidata->path, 同时修改inode/seq

** terminate_walk(nameidata)
   - 停止遍历?
   - 如果是ref模式
   > path_put(nameidata->path)
   - 如果是rcu模式, 释放rcu的读锁
   - 还有如果nameidata->flags没有LOOKUP_ROOT,设置nameidata->root->mnt = NULL
   > unlock_rcu_walk()

** should_follow_link(inode, follow)
   - 如果i_ops->follow_link无效,就设置inode->i_opflags的IOP_NOFOLLOW
   - 用此来减小一点检查??

** walk_component(nameidata, path, follow)
   - 处理nameidata->last?
   - 如果这个字符串不是普通的,也就是dot?
   - nameidata->last_type != LAST_NORM 
   > handle_dots(nameidata, nameidata->last_type)
   - 否则,先使用fast模式, 基本上在hash中查找
   > lookup_fast(nameidata, path, inode)
   - 如果查找失败,可能是没找到,也可能是-ECHILD
   - 如果没找到,使用slow模式
   > lookup_slow(nameidata, path)
   - 上面会同时获取inode, 如果没找到inode, 返回-ENOENT
   - 检查follow_link
   > should_follow_link(inode, follow)
   - 如果需要处理link, 变成ref模式, 而且返回1
   > unlazy_walk(nameidata, path->dentry)
   - 否则返回0,把找到的path/inode给nameidata
   > path_to_nameidata(path, nameidata)

** nested_symlink(path, nameidata)
   - 循环遍历symlink的路径
   - path指向的文件是symlink文件
   - 获取symlink的字符串, 并遍历下去
   > follow_link(path, nameidata, char)
   - 然后怎么返回继续的遍历的??
   > walk_component(nameidata, path, LOOKUP_FOLLOW)
   - 然后释放symlink 
   > put_link(nameidata, path, char)

** can_lookup(inode)
   - 如果inode->i_ops->lookup操作无效,使用IOP_LOOKUP标记
   - 这里检查时,先确认inode->i_opflags的IOP_LOOKUP

** link_path_walk(name, nameidata)
   - 开始遍历路径?
   - 跳过name开始的'/'
   - 处理name的每一段路径
   - 并没有完全截取,只是计算一段的长度,和hash值
   > hash_name(name, qstr->hash)
   - 根据截取的设置nameidata->last
   - 如果name是'..'或'.', 设置nameidata->last_type = LAST_DOT/LAST_DOTDOT
   - 否则设置LAST_NORM
   - 如果name是最后一部分,name[len] == '0', 直接返回
   - 最后一部分不处理?
   - 开始遍历
   > walk_component(nameidata, dentry, LOOKUP_FOLLOW)
   - 如果上面返回1, 需要处理follow 
   > nested_symlink(dentry, nameidata)
   - 最后结束遍历
   > terminate_walk(nameidata)

** path_init(dfd, name, flags, nameidata, file)
   - 这里应该是初始化nameidata
   - 设置nameidata->last_type = LAST_ROOT
   - 如果flags中包含LOOKUP_ROOT, 表示查找root?
   - 检查nameidata->root指向的dentry/inode是否可用 
   > can_lookup(nameidata->root->dentry->d_inode)
   > inode_permission(inode, MAY_EXEC)
   - 然后设置nameidata->path = nameidata->root
   - 设置inode, 如果是rcu模式, 获取seq, 否则增加计数
   - 然后直接返回
   - 否则就没有LOOKUP_ROOT? 设置nameidata->root->mnt = NULL
   - 如果name是'/'开始的路径
   - 先找到root位置, 同样针对2种模式
   - 这里获取的是current->fs_struct的root
   > set_root_rcu(nameidata)
   > set_root(nameidata)
   - 对于ref模式,增加计数
   > path_get(nameidata->root)
   - 然后设置nameidata->path = nameidata->root, 退出开始遍历
   - 如果dfd == AT_FDCWD, name是相对路径
   - 设置nameidata->path = current->fs_struct->pwd
   - 否则dfd是一个文件, 先找到它指向的dentry 
   > fdget_raw(dfd)
   - 检查是否能遍历它
   > can_lookup(dentry->d_inode)
   - 如果可以使用, 设置nameidata->path = file->f_path
  
** lookup_last(nameidata, path)
   - 如果nameidata->last_type == LAST_NORM, 而且last不是最后一部分?
   - 路径字符串后面还有? 应该是什么?
   - 设置nameidata->flags的LOOKUP_FOLLOW|LOOKUP_DIRECTORY
   - 去掉nameidata->flags的LOOKUP_PARENT
   - 继续遍历???
   > walk_component(nameidata, path, nameidata->flags & LOOKUP_FOLLOW)

** path_lookupat(dfd, name, flags, nameidata)
   - 首先初始化nameidata? 主要是path/inode/seq
   > path_init(dfd, name, flags|LOOKUP_PARENT, nameidata, file)
   - 开始遍历
   > link_path_walk(name, nameidata)
   - 如果上面没有错误,而且flags没有LOOKUP_PARENT, 处理last name? 
   > lookup_last(nameidata, path)
   - 如果返回>0, 需要follow link 
   > may_follow_link(path, nameidata)
   - 设置nameidata->flags的LOOKUP_PARENT??
   > follow_link(path, nameidata, void)
   - 继续查找 
   > lookup_last(path, nameidata, void) 
   - 释放symlink 
   > put_link(path, nameidata, cookie)
   - 结束遍历
   > complete_walk(nameidata)
   - 如果nameidata->root->mnt有效? 谁设置的? 而且nameidata->flags没有LOOKUP_ROOT
   - 释放nameidata->root 
   > path_put(nameidata->root)

** filename_lookup(dfd, filename, flgs, nameidata)
   - 首先使用rcu模式遍历 
   > path_lookupat(dfd, filename->name, flags|LOOKUP_RCU, nameidata)
   - 如果返回-ECHILD, 使用普通方式 
   > path_lookupat(dfd, name, flags, nameidata)
   - 如果返回-ESTALE, 再换一种
   > path_lookupat(dfd, name, flags|LOOKUP_REVAL, nameidata)

** do_path_lookup(dfd, name, flags, nameidata)
   > filename_lookup(dfd, filename, flags, nameidata)

** kern_path_locked(name, path)
   - 遍历路径,剩下最后一段? 
   > do_path_lookup(AT_FDCWD, name, LOOKUP_PARENT, nameidata)
   - 检查nameidata->last_type != LAST_NORM, 返回-EINVAL
   - 单独查找hash表或i_ops
   > __lookup_hash(nameidata->last, nameidata->path->dentry, 0)
   - 返回参数是找到的dentry, path是父目录??

** kern_path(name, flags, path)
   - 这里传入参数flags 
   > do_path_lookup(AT_FDCWD, name, flags, nameidata)
   - 如果没有问题,传回path是最后的??
   - 这里nameidata是局部变量,不会返回

** vfs_path_lookup(dentry, vfsmount, name, flags, path)
   - 前2个参数限定nameidata->root, 从它下面查找name, 结果给path
   - 下面使用LOOKUP_ROOT, 表示在开始查找时不用再计算nameidata->root
   - 这里已经指定
   > do_path_lookup(AT_FDCWD, name, flags | LOOKUP_ROOT, nameidata)

** lookup_hash(nameidata)
   - 查找last指向的dentry
   - flags会传给d_op->d_revalidate, 以及i_op->lookup
   > __lookup_hash(nameidata->last, nameidata->path->dentry, nameidata->flags)

** lookup_one_len(name, dentry, len)
   - len表示文件名字,不包含路径的'/'
   > __lookup_hash(qstr, dentry, 0)

** user_path_at_empty(dfd, name, flags, path, empty)
   - 先从userspace中获取filename
   - 查找dentry, 给path 
   > filename_lookup(dfd, filename, flags, nameidata)

** user_path_at(dfd, name, flags, path)
   > user_path_at_empty(dfd, name, flags, path, NULL)

** user_path_parent(dfd, name, nameidata, flags)
   - 从userspace获取name 
   > getname(name)
   - 只使用flags中的LOOKUP_REVAL 
   > filename_lookup(dfd, filename, flags | LOOKUP_PARENT, nameidata)

** open_flags 
   #+BEGIN_SRC 
	int open_flag;
	umode_t mode;
	int acc_mode;
	int intent;
	int lookup_flags;   
   #+END_SRC

** atomic_open(nameidata, dentry, path, file, open_flags, got_write, need_lookup, opened)
   - 获取open_flag
   > open_to_namei_flags(open_flags->open_flag)
   - 如果open_flag包含O_EXCL&O_CREAT, 去掉O_TRUNC??
   - got_write是什么?
   - 打开文件 ?
   - 在nameidata指向的目录下面
   > nameidata->path->dentry->inode->i_op->atomic_open(dir, dentry, file, open_flags, mode, opened)
   - 再检查打开权限? 
   > may_open(file->f_path, acc_mode, open_flag)

** lookup_open(nameidata, path, file, open_flags, got_write, opened)
   - got_write表示文件系统是否可写?
   - 先查找nameidata最后指向的文件
   - 这里仅仅在hash中查找, 如果找不到need_lookup = true
   > lookup_dcache(nameidata->last, dir, nameidata->flags, need_lookup)
   - 如果已经找到,而且有inode
   - need_lookup = fasle, dentry->d_inode != NULL
   - 直接把找到的dentry/nameidata->path->mnt给path返回
   - 如果nameidata->flags有LOOKUP_OPEN? 使用atomic_open 
   > atomic_open(nameidata, dentry, path, file, op, got_write, need_lookup, opened)
   - 如果没有LOOKUP_OPEN, 或没有atomic_open, 继续处理
   - 如果需要查找need_lookup == true, 使用i_op查找 
   > lookup_real(dir_inode, dentry, nameidata->flags)
   - 找到dentry, 检查negative
   - dentry->inode无效,而且open_flag有O_CREAT, 创建文件
   > vfs_create(dir->d_inode, dentry, mode, nameidata->flags & LOOKUP_EXCL)
   - 最后返回dentry/mnt

** do_last(nameidata, path, file, open_flags, opened, filename)
   - 同样处理路进改的最后一段, nameidata->last
   - 检查nameidata->last_type, 如果不是LAST_NORM, 那就是LAST_DOTDOT 
   > handle_dots(nameidata, nameidata->last_type)
   - 如果是LAST_NORM继续
   - 如果open_flag没有O_CREAT, 是正常的打开
   - 如果last不是路径的最后一段,后面应该有'/'??
   - 设置nameidata->flags的 LOOKUP_DIRECTORY|LOOKUP_FOLLOW
   - 如果open_flag没有O_PATH?, 而且nameidata->flags没有LOOKUP_FOLLOW, 表示处理symlink文件?
   - 打开文件?
   > lookup_fast(nameidata, path, inode)
   - 如果open_flag有O_CREAT, 是创建文件
   - 停止遍历
   > complete_walk(nameidata)
   - last必须是最后的字符串, 他最后必须是'0'
   - 如果open_flag有O_CREAT|O_TRUNC|O_WRONLY|O_RDWR, 检查是否可写 
   > mnt_want_write(nameidata->path->mnt)
   - 如果支持写,设置got_write = true, 但不能写也没有返回?
   - 继续查找? 
   > lookup_open(nameidata, path, file, open_flag, got_write, opened)
   - 如果返回0,表示文件已经打开, 直接跳到最后?
   - 如果返回<0, 返回操作失败
   - 如果返回>0? 如果opened有FILE_CREATED, 表示创建文件
   - 设置nameidata->path, 去掉open_flag的O_RUNC
   - 这里可能有4个步骤, lookup, creae, open
   - 上面是找到文件,而且没有打开创建操作?
   - 如果open_flag包含O_EXCL|O_CREAT, 直接退出?
   - 返回-EEXIST, 因为文件已经存在,不需要创建
   - 跳跃mountpoint 
   > follow_managed(path, nameidata->flags)
