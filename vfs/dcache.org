* dcache.c

** dentry
   #+BEGIN_SRC 
	/* RCU lookup touched fields */
	unsigned int d_flags;		/* protected by d_lock */
	seqcount_t d_seq;		/* per dentry seqlock */
	struct hlist_bl_node d_hash;	/* lookup hash list */
	struct dentry *d_parent;	/* parent directory */
	struct qstr d_name;
	struct inode *d_inode;		/* Where the name belongs to - NULL is
					 * negative */
	unsigned char d_iname[DNAME_INLINE_LEN];	/* small names */

	/* Ref lookup also touches following */
	unsigned int d_count;		/* protected by d_lock */
	spinlock_t d_lock;		/* per dentry lock */
	const struct dentry_operations *d_op;
	struct super_block *d_sb;	/* The root of the dentry tree */
	unsigned long d_time;		/* used by d_revalidate */
	void *d_fsdata;			/* fs-specific data */

	struct list_head d_lru;		/* LRU list */
	/*
	 * d_child and d_rcu can share memory
	 */
	union {
		struct list_head d_child;	/* child of parent list */
	 	struct rcu_head d_rcu;
	} d_u;
	struct list_head d_subdirs;	/* our children */
	struct hlist_node d_alias;	/* inode alias list */   
   #+END_SRC
   
   - dentry的状态标志
   - d_count数量, 即使为0也不大会释放
   - d_hash节点位置
   - d_parent / d_child的状态, 一般不会改变?
   - d_inode和d_alias的状态, 如果没有关联inode就是negative
   - d_lru状态: 在回收时使用它

** dentry_operations
   #+BEGIN_SRC 
	int (*d_revalidate)(struct dentry *, unsigned int);
	int (*d_weak_revalidate)(struct dentry *, unsigned int);
	int (*d_hash)(const struct dentry *, struct qstr *);
	int (*d_compare)(const struct dentry *, const struct dentry *,
			unsigned int, const char *, const struct qstr *);
	int (*d_delete)(const struct dentry *);
	void (*d_release)(struct dentry *);
	void (*d_prune)(struct dentry *);
	void (*d_iput)(struct dentry *, struct inode *);
	char *(*d_dname)(struct dentry *, char *, int);
	struct vfsmount *(*d_automount)(struct path *);
	int (*d_manage)(struct dentry *, bool);   
   #+END_SRC

** d_hash(dentry, hash)
   - 计算dentry在dentry_hashtable中的hash索引

** __d_free(rcu_head)
   - 使用rcu释放dentry内存, 还有dentry->d_name
   - 这是保证dentry->d_alias不在hash表中?

** d_free(dentry)
   - 在d_kill中使用, 释放dentry
   - 要求dentry->d_count == 0
   > dentry->dentry_operations->d_release(dentry)
   - 如果dentry->d_flags有DCACHE_RCUACCESS, 表示使用rcu访问过
   - 在路径查找中有2种,一种是rcu模式, 一种是ref模式
   - 如果有DCACHE_RCUACCESS, 使用rcu释放
   > call_rcu(dentry->d_u->d_rcu, __d_free)
   - 否则直接释放 
   > __d_free(dentry->d_u.d_rcu)
   - 在__d_rehash中设置,只要把它放到dentry_hashtable中就会设置

** dentry_rcuwalk_barrier(dentry)
   - 使rcu遍历方式失效, rcu模式也和seq配合使用
   > write_seqcount_barrier(dentry->d_seq)
   - 在关联inode或断开inode时设置, 或者释放d_hash节点时设置

** dentry_iput 
   - 在d_kill中使用,它是释放dentry和inode的关系
   - 设置dentry->d_inode = NULL, 释放d_alias节点, d_alias现在成了hash表
   > hlist_del_init(dentry->d_alias)
   - 如果inode->i_nlink ==0, 发送fsnotify消息
   > fsnotify_inoderemove
   - 最后释放inode的使用计数
   - 如果有回调函数
   > d_op->d_iput(dentry, inode)
   - 如果没有 
   > iput(inode)
   - 这里可能会释放inode
   - d_iput就是调用了iput,释放inode->i_count计数
   - nfs实现了，释放sillyrename和子目录的缓存

** dentry_unlink_inode(dentry)
   - 和上面一样, 释放dentry->d_alias, 设置dentry->d_inode = NULL
   - 无效rcu的访问方式
   > dentry_rcuwalk_barrier(dentry)
   - 释放inode计数 
   > dentry->d_op->d_iput(dentry, inode)
   - 在d_delete中使用, 在删除inode时使用
   - 变为negative的dentry
   - 和上面的区别是多了dentry->d_seq操作

** dentry_lru_add(dentry)
   - 把dentry->d_lru放到super_block->s_dentry_lru队列中
   - 增加super_block->s_nr_dentry_unused计数
   - 在dput中调用

** __dentry_lru_del(dentry) 
   - 释放dentry->d_lru链表
   - 去掉dentry->d_flags的DCACHE_SHRINK_LIST标志
   - 减小super_block->d_nr_dentry_unused

** dentry_lru_del(dentry)
   - 使用dcache_lru_lock锁
   > __dentry_lru_del(dentry)
   - dentry->d_lru不仅仅放到super_block中,还有用来收集需要释放的dentry
   - 这里要把dentry从lru中释放,可能是因为又使用起来,也可能即将释放
   - DCACHE_SHRINK_LIST表示在临时的hash表中,即将释放
   - 无论从什么lru队列中,都会占用super_block->s_nr_dentry_unused计数,因为在释放dentry时还会释放lru节点,改变这个计数

** dentry_lru_move_list(dentry, list_head)
   - list_head用来收集需要释放的dentry 
   - 如果dentry->d_lru为空,把它放到list_head链表中
   - 否则移动到最后面

** d_kill(dentry, dentry parent) 
   - 释放dentry的内存,现在已经在hash和lru中释放
   - dput调用之后会释放parent的计数, 会返回parent, 然后回朔释放
   - 释放dentry->d_u->d_child, 从父目录中释放, 但没有设置dentry->d_parent
   - 设置dentry->d_flags 的DCACHE_DENTRY_KILLED, 表示不再可用
   - 释放和inode的关系
   > dentry_iput(dentry) 
   - 释放自己
   > d_free(dentry) 

   - 释放顺序是
   - dentry_operations->d_delete(dentry) 决定是否直接释放,还是缓存在lru中
   - d_count == 1, 而且unhash, 直接释放
   - 减小d_count
   - dentry->d_op->d_prune(dentry)
   - dentry_lru_del(dentry)
   - __d_drop(dentry)
   - parent->d_subdirs / parent->d_u->d_child
   - dentry_iput(dentry)  释放inode
   - dentry->d_op->d_release(dentry)
   - __d_free(dentry)   释放自己

** __d_shrink(dentry)
   - 释放hash表关系, 如果不在hash表中,直接返回
   > d_unhashed(dentry)
   - dentry使用2中hash链表
   - 一个是suepr_block->s_anon, 另一个是dentry_table
   - 释放时需要hash表头的锁
   - dentry->d_flags的DCACHE_DISCONNECTED表示在anon链表中
   > hlist_bl_lock(hlist_bl_head)
   > __hlist_bl_del(dentry->d_hash)

** __d_drop(dentry)
   - 这里是释放hash表, 至少使dentry无法访问
   - 检查是否在hash表中
   > d_unhashed(dentry)
   > __d_shrink(dentry)
   > dentry_rcuwalk_barrier(dentry)

** d_drop(dentry)
   - 释放dentry->d_lock锁住 
   > __d_drop(dentry)

** dentry_kill(dentry, ref)
   - 释放dentry, 返回d_parent,可以回朔回收
   - 这里为释放做准备, 获取inode和dentry的锁
   - 先找到父目录, 锁住inode->i_lock和parent->d_lock
   - 如果ref有效, 减小dentry->d_count
   - 如果dentry->flags有DCACHE_OP_PRUNE
   - 通知文件系统dentry要释放
   > dentry->d_op->d_prune(dentry)
   - 释放lru链表
   > dentry_lru_del(dentry)
   - 释放hash表
   - __d_drop(dentry)
   - 继续释放
   - d_kill(dentry, parent)

** dput(dentry)  
   - 减小dentry->d_count, 如果d_count减到0,则释放它
   - 如果d_count没有到0，则返回
   - 如果dentry->flags有DCACHE_OP_DELETE,回调函数决定是否直接删除
   - 对于nfs来说,检查对应的inode是否有错误 nfs_dentry_delete
   > d_ops->d_delete(dentry)
   - 如果不在hash表中, 直接释放
   > d_unhashed(dentry)
   - 否则不会释放,放到lru队列中,设置DCACHE_REFERENCED标志.
   > dentry_lru_add(dentry)
   > dentry->d_count --
   - 如果要释放, 函数返回d_parent, 回朔释放
   > dentry_kill(dentry, 1)

** d_invalidate(dentry)
   - 使dentry无效,在dentry_hashtable中释放, 但也没有放到super_block->s_anon中?
   - 在revalidate操作无效后使用, 相当于错误处理
   - 如果dentry不在hash表中,则不处理, 已经无效
   - 如果dentry->d_subdirs不是空,有子dentry
   - 去遍历它的子树，收集没有使用的释放
   - shrink_dcache_parent(dentry) 
   - 如果dentry->d_count > 1, 而且inode有效, 而且是目录,返回-EBUSY
   - 释放hash表关系, 表示不在vfs的树中,只是没有释放
   > __d_drop(dentry) 

** 总结
   - 释放有很多种
   - 一种是放到lru队列中 dput
   - 一种是有条件的直接释放 kill
   - 一种是释放hash表关系, invalidate/drop
   - 下面还有一种,释放整个super_block的dentry

** __dget_dlock / __dget(dentry) 
   - 修改dentry->d_count

** dget_parent(dentry) 
   - 使用dentry->d_lock锁住
   - 增加d_parent的计数

** __d_find_alias(inode, want_discon)
   - 找一个inode关联的dentry,增加计数
   - 遍历inode->i_dentry链表中的dentry
   - 过滤掉不是文件夹也不在hash表中的, 那些是无效的??
   - 如果want_discon=1, 必须找一个root,而且是DCACHE_DISCONNECTED的dentry
   - 否则必须找一个不是root, 而且不带DCACHE_DISCONNECTED的
   > __dget_dlock(dentry)

** d_find_alias(inode)
   - 使用dinode->i_lock锁住, 找一个正常的dentry
   > __d_find_alias(inode, 0)

** d_prune_aliases(inode)
   - 释放inode关联的dentry 
   - 遍历inode->i_dentry链表中的dentry
   - 只处理dentry->d_count ==0的,没有使用的dentry
   - 首先增加计数,下面再减小计数释放
   > __dget_dlock(dentry)
   - 释放hash表关系, 后面肯定直接kill
   > __d_drop(dentry)
   > dput(dentry)

** try_prune_one_dentry(dentry) 
   - 这个dentry已经不再使用, 这是使用lru回收的
   - 先释放自己
   > dentry_kill(dentry, 0)
   - 如果parent->d_count>1,有别人使用它, 不再释放, 只减小计数
   - 否则继续回朔释放
   - dentry_kill(dentry, 1)  

** 总结
   - dentry释放的锁有4种
   - 上面的操作应该是获取dentry->d_lock
   - 在开始释放时,获取inode/parent的索
   - 里面有hash操作,使用自己的索
   - 然后释放d_child链表, 设置DCACHE_DENTRY_KILLED, 释放parent->d_lock
   - 然后释放inode关系,释放inode锁
   - 最后再释放自己之前,释放d_lock

** shrink_dentry_list(list_head) 
   - 删除一队列的dentry, 队列使用d_lru, 遍历这些dentry
   - 如果dentry->d_count > 0, 不能释放, 又开始使用了??
   - 只是释放lru链表,从当前链表中释放
   - 否则释放它,而且释放父dentry
   > try_prune_one_dentry(dentry)

** prune_dcache_sb(super_block, count)
   - 有不是一个kernel版本了??
   - 释放super_block->s_dentry_lru上面的dentry
   - 如果dentry->d_flags有DCACHE_REFERENCED，把它放回到链表
   - 否则把它放到临时链表中,设置DCACHE_SHRINK_LIST
   - 最后集中释放 
   > shrink_dentry_list(list)

** shrink_dcache_sb(super_block, count) 
   - 尝试super_block中空闲的dentry
   - 遍历super_block->s_dentry_lru
   - 如果dentry带标志DCACHE_REFERENCED,则把它放回去
   - 否则放到临时链表中,最后集中释放
   - 这里使用dcache_lru_lock保护,和上面的lru操作很想
   - shrink_dentry_list(list)

   - 果然版本不一样了..

** shrink_dcache_sb(super_block)
   - 释放整个super_block->s_dentry_lru链表, 直到为空
   > shrink_dentry_list(list_head)

** shrink_dcache_for_umount_subtree(dentry) 
   - umount时使用,释放super_block的所有dentry
   - dentry必须是root
   - 使用树的深度优先遍历, 删除dentry, 释放d_subdirs/d_child遍历
   - 开始循环, 先到最底层的dentry, d_subdirs为空
   - 释放的顺序和dput类似
   - 通知fs
   > d_op->d_prune(dentry)
   - 释放lru和hash关系
   > dentry_lru_prune(dentry)
   > __d_shrink(dentry)
   - 如果dentry->d_count >0, 报错, 这里不会处理计数!!??
   - 释放父dentry的关系
   - list_del(dentry->d_u->d_child)
   - 释放inode关系
   > hlist_del_init(dentry->d_alias)
   > d_op->d_iput(dentry, inode)
   - 最后释放自己
   > d_free(dentry)
   - 这里没有使用任何锁??

** shrink_dcache_for_umount(super_block)
   - 首先释放super_block->s_root对应的子树
   > shrink_dcache_for_umount_subtree(dentry)
   - 然后是super_block->s_anon链表上的
   - 链表使用dentry->d_hash?? 上面可能有遗漏的
    -这里不会干扰上面的释放,因为不会增加计数
   - 遍历hash表上的dentry
   > shrink_dcache_for_umount_subtree(dentry)
   - 在关闭super_block中调用
   > kill_anon_super(super_block)
   > generic_shutdown_super(super_block)
   > shrink_dcache_for_umount(super_block)

   - 只有在创建root的dentry时才会把dentry放到super_block->s_anon中,这里怎么有这些操作?
	
** try_to_ascend(old, locked, seq) 
   - 找dentry->d_parent 
   - 如果old->flags有DCACHE_DENTRY_KILLED, 或者seq和rename_lock不一致, 返回NULL

** have_submounts(parent)
   - 检查parent的子树的文件夹中,是否有mountpoint
   - dentry->d_flags的DCACHE_MOUNTPOINT表示它是mountpoint
   > d_mountpoint(dentry)
   - 因为这里是有序树,而且遍历的时候树的结构不会改变, 可以使用循环的方式表示递归
   - 刚才写了python, 不需要有序,但删除的操作,也可实现

** select_parent(dentry, list_head ) 
   - 遍历dentry的子树,回收d_count为0的dentry
   - 如果d_count>0, 从lru队列中释放
   > dentry_lru_del(dentry)
   - 如果dcache->d_flags没有DCACHE_SHRINK_LIST,说明没有在回收
   - 可以放到参数链表中,防止循环,添加DCACHE_SHRINK_LIST标志
   > dentry_lru_move_list(dentry, dispose) 
   - 这个dentry应该是最下层,否则它的计数不能为0
   - 这里遍历使用2遍,第一次是read方式的rename_lock, 第二遍是write方式的rename_lock
   - 在遍历回朔时, 检查parent关系是否改变,以及rename_lock是否改动
   - 遍历时会检查d_parent是否为NULL, 
   - 但d_lru链表的修改使用dentry->d_lock

** shrink_dcache_parent(dentry)
   - 回收dentry目录下不使用的dentry 
   > select_parent(parent, list_head)
   - 不使用的直接释放
   > shrink_dentry_list(list_head)

** __d_alloc(sb, name) 
   - 创建dentry
   - 根据参数这里只设置super_block和name, 还有super_block->d_ops

** d_alloc(parent, name)  
   - 创建dentry
   > __d_alloc(parent->super_block, name)
   - 增加parent->d_count计数
   > __dget_dlock(parent)
   - 把dentry->d_u->d_child放到parent->d_subdirs链表中

** d_alloc_pseudo(super_block, name)
   - 创建一个dentry 
   > __d_alloc(super_block, name)
   - 设置dentry->d_flags的DCACHE_DISCONNECTED
   - 但也没有把d_hash放到super_block->s_anon?
   
** d_alloc_name(parent, name)
   - 上面的name都是qstr, 这里包装一下
   > d_alloc(parent, dentry)

** d_set_d_op(dentry, dentry_operations)
   - 设置dentry->d_op = dentry_operations
   - 每个dentry_operations的函数对应一个标志DCACHE_

** __d_instantiate(dentry, inode) 
   - 建立dentry和inode的关系, 把dentry->d_alias放到inode->i_dentry队列中
   - 设置dentry->d_inode = inode
   - 如果inode是AUTOMOUNT,设置dentry->d_flags的DCACHE_NEED_AUTOMOUNT
   - 通知rcu遍历的task重新遍历
   > dentry_rcuwalk_barrier(dentry)

** d_instantiate(dentry, inode) 
   - 有了inode的dentry就不是negative的dentry, 但dentry的计数还是不变
   - 必须保证dentry不在hash表中, 也就是无效的??
   > hlist_unhashed(dentry->d_alias)
   > __d_instantiate(dentry, inode)

** d_add(dentry, inode)
   - 先建立dentry和inode联系
   > d_instantiate(dentry, inode)
   - 在把它放到dentry_hashtable中
   > d_rehash(dentry)
   - 在open中会用到这个操作

** __d_instantiate_unique(dentry, inode)
   - 而对inode的使用计数在外部已经增加
   - 和上面的区别时,这里先遍历inode->i_dentry链表
   - 比较是否有重复的, hash, d_parent, name
   > __d_instantiate(dentry, inode)

** d_instantiate_unique(dentry, inode)
   - 同样检查dentry不能在dentry_hashtable中
   - 关联inode/dentry, 如果有重复的,返回已经关联的dentry 
   > __d_instantiate_unique(dentry, inode)

** d_make_root(inode) 
   - 创建dentry,name="/",然后关联inode
   > __d_alloc(inode->i_sb, name)
   > d_instantiate(dentry, inode)
   - 这里也没有增加inode计数??

** __d_find_any_alias(inode) 
   - 从inode->i_dentry队列上去一个dentry
   > hlist_entry(inode->i_dentry.first, struct dentry, d_alias)
   - 增加使用计数
   - __dget(dentry)

** d_find_any_alias(inode)
   - 锁住inode->i_lock
   > __d_find_any_alias(inode)

** d_obtain_alias(inode)
   - 先查找一个
   > d_find_any_alias(inode)
   - 如果找不到,就创建一个, 但名字是'/'?
   > __d_alloc(inode->i_sb, string) 
   - 设置DCACHE_DISCONNECTED, 关联inode和dentry的关系, 把这个创建的dentry放到inode->i_sb->s_anon中
   - 这个dentry是临时的,没有在parent的树中,也没有在hash表中
   - 名字是'/', 也是anonymous
   - 一半在创建root inode/dentry时使用

** d_splice_alias(inode, dentry) 
   - 关联inode和dentry, 在lookup中使用
   - 根据dentry查找对应的inode, 然后关联他们
   - 如果inode是目录,首先找是否有DCACHE_DISCONNECTED的dentry
   - __d_find_alias_inode(inode, 1)
   - 把找到的dentry放到参数dentry的位置,而且切换name
   - d_move(new, dentry)
   - 如果没找到就直接关联他们
   > __d_instantiate(dentry, inode)
   - 重新插入到hash表中
   > d_rehash(dentry)
   - 对于普通文件,就直接关联,同时重新计算hash表位置
   > d_add(dentry,inode) 

** d_add_ci(dentry, inode, name)
   - 先查找name对应的dentry, 为何不直接使用参数?
   - 然后如果没找到, 就创建dentry, 然后关联他们
   - 首先在父目录下面找一个name的文件
   > d_hash_and_lookup(dentry->d_parent, name) 
   - 如果没找到，就创建一个
   > d_alloc(dentry->d_parent, name)
   - 然后建立和inode的联系
   > d_splice_alias(inode, new)
   - 如果找到了,而且关联同样的inode,返回找到的dentry
   - 应该没有关联inode, 也就是negative的
   - d_splice_alias(inode, dentry)
   - 只有ntfs和xfs使用

** 总结
   - 创建有两种，一种指定parent, 另一种不指定
   - 两种都要有super_block
   - 使用parent的，创建后就会放到parent的孩子队列中
   - 然后可以关联inode，同时把它inode的alias队列中
   - 然后考虑放到hash队列中,但放到hash队列中
   - 主要在find操作中使用,检查是否已有存在的dentry,有的话用存在的
   - 没有的话创建新的,并关联inode，放到hash队列中.

** __d_lookup_rcu(parent, name, seq, inode) 
   - 在parent下面找name对应的dentry
   - 这里不是遍历dentry->d_subdirs, 而是使用dentry_hashtable
   - 使用dentry->d_seq包含
   - 过滤掉不在hash表中的dentry
   > d_unhashed(dentry)
   - 比较name和dentry->d_name 
   > slow_dentry_cmp(parent, dentry, seq, name)

** d_lookup(parent, name)
   - 使用rename_lock保护 
   > __d_lookup(parent, name)

** __d_lookup(dentry, name)
   - 和__d_lookup_rcu相同, 不过这里使用ruc的锁
   > rcu_read_lock()
   - 没有使用seq锁, 如果找到,增加dentry->d_count 

** d_hash_and_lookup(dentry, name)
   - 在dentry目录下,查找name对应的dentry 
   > d_lookup(dentry, name)
   - 这里是增加dentry->d_count

** d_validate(dentry, parent) 
   - 通过验证parent->d_subdir, 验证dentry没问题
   - 增加dentry的计数，没人用！

** d_delete(dentry) 
   - 在删除文件时删除dentry
   - 如果dentry没人用, 把dentry变为negative的
   - 否则把它在hash队列中删除
   - 如果dentry->d_count ==1,变成一个negative的dentry
   - 只有当前操作路径在使用?
   - 锁住d_lock, inode->i_lock, 这里会循环等待锁
   - 去掉dentry->d_flags的DCACHE_CANT_MOUNT??
   - 释放和inode的关系, 仅仅变成negative的
   - dentry_unlink_inode(dentry)
   - 否则, d_count会是多少??
   - 如果dentry在hash表中, 释放hash表关系 
   > d_unhashed(dentry)
   - 从dentry_hashtable中释放
   > __d_drop(dentry)

** __d_rehash(dentry, hlist_bl_head)
   - 设置dentry->d_flags的DCACHE_RCUACCESS, 重新把dentry放到hash队列中

** _d_rehash(dentry, hlist_bl_head)
   > __d_rehash(dentry)

** d_rehash(dentry)
   - 使用dentry->d_lock锁 
   > _d_rehash(dentry)

** __d_move(dentry, target) 
   - 交换两个dentry, 包括name,parent,subdir,hash. 
   - target虽然没有释放,但不在hash队列中
   - 只要回收函数一看，就立即释放它， 但另一个会进入hash队列

** d_move(dentry, target)
   - 使用rename_lock保护
   > __d_move(dentry, target)
   - 这就是rename的实现??

** d_ancestor(dentry p1, p2)
   - 使用dentry->d_parent向上遍历,检查p1是否是p2的上层目录

** __d_unalias(inode, dentry, alias)
   - 修改inode的文件名? 这里的锁非常复杂
   > __d_move(alias, dentry)

** __d_materialise_dentry(dentry, anon) 
   - 好像也是交换dentry和anon的内容,去掉anon的DCACHE_DISCONNECTED
   - 没有hash表的操作, 只有d_child/d_subdirs的操作

** d_materialise_unique(dentry, inode) 
   - 同样是关联dentry和inode
   - 如果inode是目录, 必须保证只有一个dentry
   - 查找是否存在dentry
   > __d_find_alias(inode, 0)
   - 如果是root,直接代替原来的, 而且需要调整hash表的位置
   > __d_materialise_dentry(dentry, alias)
   - 释放原来的dentry
   - __d_drop(dentry)
   - 如果是正常的dentry, 相当于rename操作?
   > __d_unalias(inode, dentry, alias) 
   - 如果找不到alias,或者是非目录,允许多个dentry?
   > __d_instantiate_unique(dentry, inode)
   - 最后调整hash队列
   > _d_rehash(dentry) 


** 总结
   - dcache->flags的DCACHE_DISCONNECTED表示dentry没有在hash表中,而是在super_block->s_anon中

* namei.c

  - dcache中树的查找有两种
  - 一种使用rcu/seqcount,另一种是refcount
  - 第二种更安全一些,因为它在查找时增加dentry的计数.

** path 
   #+BEGIN_SRC 
	struct vfsmount *mnt;
	struct dentry *dentry;   
   #+END_SRC

** path_get(path)
   > mntget(path->mnt)
   > dget(path->dentry)

** path_put(path)
   > dput(path->dentry)
   > mntput(path->mnt)

** nameidata
   #+BEGIN_SRC 
	struct path	path;
	struct qstr	last;
	struct path	root;
	struct inode	*inode; /* path.dentry.d_inode */
	unsigned int	flags;
	unsigned	seq;
	int		last_type;
	unsigned	depth;
	char *saved_names[MAX_NESTED_LINKS + 1];   

	enum {LAST_NORM, LAST_ROOT, LAST_DOT, LAST_DOTDOT, LAST_BIND};

	LOOKUP_FOLLOW(symlink)
	LOOKUP_DIRECTORY  找一个directory
	LOOKUP_AUTOMOUNT //在查找碰到automount时,如果没有它可能不会mount
	LOOKUP_PARENT //表示查找的状态, 是否处理最后一段, 在automount失败时,可返回-eremote错误
	LOOKUP_REVAL //nfs使用, 需要验证dcache中的目录信息
	LOOKUP_RCU //rcu模式遍历

	LOOKUP_ROOT //表示nameidata->root已经设置,如果没有这个标志,nameidata->root->mnt必须是NULL
	LOOKUP_OPEN //遍历是为了open, 最里面根据它调用atomic_open
	LOOKUP_CREATE //遍历是为了create?? 但好像没人使用?
	LOOKUP_EXCL  //只有nfs使用,通过i_ops->lookup传递
	LOOKUP_RENAME_TARGET 
	LOOKUP_JUMPED //表示跨越了mountpoint?
	LOOKUP_EMPTY

   #+END_SRC

** unlock_rcu_walk()
   - 锁住vfsmount_lock, lock/global锁
   > rcu_read_lock

** unlock_rcu_walk()
   > rcu_read_unlock()
   > br_read_unlock(vfsmount_lock)

** __d_rcu_to_refcount(dentry, seq)
   - 如果seq == dentry->d_seq, 表示没有改变,可以使用
   - 增加dentry->d_count

** unlazy_walk(nameidata, dentry)
   - 从rcu模式变为ref模式
   - dentry是nameidata->path->dentry的子dentry
   - nameidata->flags必须有LOOKUP_RCU
   - 如果nameidata->flags没有LOOKUP_ROOT, 而且nameidata->root->mnt不是NULL ?? 
   - 则设置want_root = 1
   - 比较nameidata->root和current->fs, 如果不一致返回错误?
   - 当前位置是nameidata->path下面, nameidata->path->dentry指向nameidata->inode
   - 如果dentry == NULL, 表示还没找到当前的路径名?
   - 检查parent->d_seq是否改变, 如果改变返回错误
   - 这里的错误都是ECHILD
   - __d_rcu_to_refcount(dentry, nameidata->seq) 
   - 如果dentry有效
   - 检查dentry->parent是否和nameidata->path->dentry一致
   - 检查dentry是否改变,增加dentry的计数, 这里nameidata->seq却是dentry的?
   > __d_rcu_to_refcount(dentry, nameidata->seq)
   - 增加parent->d_count, 就像dentry无效一样
   - 如果上面设置want_root =1, 增加naemidata->root计数
   > path_get(nameidata->root)
   - 最后增加vsfmount计数, 所以nameidata->path->dentry/vfsmount的计数都增加了
   > mntget(nameidata->path->mnt)
   - 最后去掉LOOKUP_RCU
   - 如果上面检查有错误,都返回-ECHILD

** d_revalidate(dentry, flags)
   - 检查是否有效?
   > dentry->d_op->d_revalidate(dentry, flags)

** complete_walk(nameidata) 
   - 遍历完成时的操作
   - 如果是rcu模式, 需要获取相应的计数, 就像变为ref模式
   - 去掉LOOKUP_RCU
   - 如果没有LOOKUP_ROOT, 直接nameidata->root->mnt = NULL
   - 估计本来也没用它的计数, 只有ref模式才使用它的计数
   - 增加nameidata->path->dentry的计数 
   > __d_rcu_to_refcount(dentry, nameidata->seq)
   - 增加nameidata->path->mnt计数
   - 在ref模式, nameidata->path的计数都要有
   - 如果nameidata->flags没有LOOKUP_JUMPTED, 直接返回
   - 最后使用d_weak_revalidate验证,对应d_flags的DCACHE_OP_WEAK_REVALIDATE
   - 只有nfs使用它
   > d_op->d_weak_revalidate(dentry, namiedata->flags)

** set_root(nameidata)
   - 如果nameidata->root->mnt == NULL,才设置
   - 设置nameidata->root = current->fs->root
   - 同时增加path的计数

** set_root_rcu(namiedata)
   - rcu模式，设置nameidata->root
   - nameidata->root = current->fs->root
   - nameidata->seq = nameidata->root->dentry->d_seq
   - 并没有增加计数

** __vfs_follow_link(nameidata, link_name)
   - 如果link_name是绝对路径(以"/"开头), 重新设置nameidata 
   - 使用ref模式方式?
   > set_root(nameidata)
   - 当前路径改为root, nameidata->path = nameidata->root
   - 有增加计数一遍
   - path_get(nd->path)
   - 设置LOOKUP_JUMPTED
   - 设置nameidata->inode = nameidata->path->dentry->inode
   - 开始查找
   > link_path_walk(link, nd)
   - 这个函数的执行是递归的

** path_put_conditional(path, nameidata)
   - 释放path的计数， 在出错时处理?
   > dput(path->dentry)
   - vfsmount只有和当前的不一样时,才释放, path->mnt != nameidata->path->mnt
   > mntput(path->mnt)
   - path和nameidata->path什么关系?
   
** path_to_nameidata(path, nameidata)
   - 修改nameidata的当前目录
   - 如果不是rcu模式, 还要释放已有的计数nameidata->path
   > dput(nameidata->path->dentry)
   - 如果nameidata和path->mnt相同,不用释放
   > mntput(nameidata->path->mnt)
   - 但不会增加参数path的计数,rcu模式和ref模式都使用
   - ref模式应该已经增加了path的计数

** nd_jump_link(nameidata, path)
   - 直接设置nameidata的当前目录
   > path_put(nameidata->path)
   - 设置nameidata->path/inode,还有LOOKUP_JUMPED
   - 原来的和现在的vfsmount肯定不一样

** put_link(nameidata, path, cookie)
   - cookie里面时symlink的路径,释放symlink使用的资源
   > inode->i_op->put_link(dentry, nameidata, cookie)
   - 释放path计数
   > path_put(link)

** may_follow_link(path, nameidata)
   - path指向symlink文件,检查是否可以展开?
   - 如果有问题,返回-EACCESS
   - inode->i_mode, uid

** safe_hardlink_source(inode)
   - link操作时的检查
   - 检查inode->i_mode 
   > inode_permission(inode, MAY_READ|MAY_WRITE)

** may_linkat(path)
   - 在linkat的syscall中,检查是否满足条件
   - 这里在内存在已经关联?
   - 文件是path->dentry->d_inode, 位置就是dentry
   - 检查uid等, capable
   > safe_hardlink_source(inode)

** follow_link(path link, nameidata, p)
   - 展开symlink, 必须是ref模式
   - link应该在nameidata->path目录下面
   - 如果link和nameidata->path使用同一个vfsmount, 增加它计数 
   > mntget(link->mnt)
   - 修改symlink文件到atime 
   > touch_atime(link)
   - 设置nameidata->saved_names[nameidata->path] = NULL, 需要它来放置symlink的信息?
   > nd_set_link(nameidata, NULL)
   - 使用i_ops, 获取symlink文件的路径
   - 把它放到nameidata->saved_names[depth]中
   > dentry->d_inode->i_op->follow_link(dentry, nameidata)
   - 开始遍历展开, 使用的就是nameidata->saved_names[depth]
   > __vfs_follow_link(nameidata, string)

** follow_up_rcu(path) 
   - 使用rcu保护的路径向上走,跨越mountpoing
   - 跨越mountpoint也支持rcu模式??
   - 检查path->mnt->mnt_parent
   - 如果path->mnt没有父mount,则返回0
   - 更换path = {path->mnt->mnt_mountpoint, path->mnt=>mnt_parent->mnt}
   - 这里要同时使用mount/vfsmount数据结构

** follow_up(path)
   - ref模式方式的向上遍历
   - 同样跨越mountpoint
   - 使用mnt->mnt_mountpoint, mnt_parent->mnt
   - 同时增加新的计数,释放老的计数

** follow_automount(path, flags, need_mntput)
   - 检查是否要去mount 
   - 如果遍历的目的没有这些标志,说明没有必要挂载
   - flags中没有LOOKUP_PARENT/LOOKUP_DIRECTORY/LOOKUP_OPEN/LOOKUP_CREAT/LOOKUP_AUTOMOUNT, 而且dentry->inode有效,不再mount, 而是返回-ISDIR
   - 根据注释,这是statde操作
   - 获取vfsmount
   > path->dentry->d_op->d_automount(path)
   - 挂在到dentry上面
   > finish_automount(mnt, path) 
   - 切换path, 指向新的vfs的根dentry

** follow_managed(path, flags) 
   - 处理特殊的dentry 
   - dentry->d_flags包括DCACHE_MOUNTED, DCACHE_NEED_AUTOMOUNT, DCACHE_MANAGE_TRANSIT
   - 对于DCACHE_MANAGE_TRANSIT
   - d_op->d_manage(path->dentry, false) 
   - 对于DCACHE_MOUNTED, 表示它是mountpoint,需要跨越mountpoint
   - 先找到mountpoint的vfsmount
   > lookup_mnt(path)
   - 更新path指向的{vfsmount, vfsmount->mnt_root}
   - 对于DCACHE_NEED_AUTOMOUNT,里面回更新path
   - follow_automount(path, flags, need_mntput) 
   - 这里需要维护path->mnt的计数, 如果path->mnt没有改变,不需要增加它的计数

** follow_down_one(path)
   - 向下查找，跨越mountpoint
   > lookup_mnt(path)
   - 更新path, 同时修改计数

** managed_dentry_might_block(dentry)
   - 执行DCACHE_MANAGE_TRANSIT对应的操作
   > d_op->d_manage(dentry, true)

** __follow_mount_rcu(nameidata, path, inode)
   - rcu模式向下遍历, 用来跨越mountpoint
   - 首先检查d_manage, 只有autofs使用, 而且不允许rcu模式
   > managed_dentry_might_block(dentry)
   - 如果是autofs,直接返回false
   - 查找是mountpoint, 直接返回true
   > __lookup_mnt(path->mnt, path->dentry, 1)
   - 切换path, 没有计数操作
   - 并没有把path更新到nameidata->path
   - 添加nameidata->flags的LOOKUP_JUMPED
   - 设置nameidata->seq = path->dentry->d_seq
   - 设置参数inode = path->dentry->d_inode

** follow_mount_rcu(nameidata)
   - 不考虑d_manage的扩展
   - 循环查找nameidata->path的mountpoint, 直接修改当前路径?
   > __lookup_mnt(nameidata->path->mnt
   - 更新path/seq

** follow_dotdot_rcu(nameidata)
   - 这里是循环处理,跳过mountpoint
   - 如果nameidata->path和nameidata->root一样，直接退出 
   - 已经是root,无法向上遍历
   - 如果nameidata->path->dentry不是path->vfsmount->mnt_root,可以向上查找
   - 首先检查nameidata->seq和path->dentry->s_seq, 如果不一致返回-ECHILD
   - 直接更新nameidata->path->dentry, seq, 这两个必须是一致的, 直接退出
   - 否则它需要向上跨越mountpoint
   > follow_up_rcu(nameidata->path)
   - 然后检查新的dentry是否被别人mount??
   > follow_mount_rcu(nameidata)

   - 基本上是先向上查找
   - 遇到nameidata->root退出
   - 遇到vfsmount->root,向上跳过vfsmount, 而且继续.
   - 否则向上d_parent, 然后退出
   - 退出之后检查是否是mountpoint

** follow_down(path)  
   - 这个函数和follow_managed类似,但这里不会处理DCACHE_NEED_AUTOMOUNT,nfsd使用它.
   - 处理DCACHE_MANAGE_TRANSID, 对应d_ops->d_manage
   - 处理DCAHCE_MOUNTED,向下跨越mountpoint
   - 这里需要修改dentry/vfsmount的计数

** follow_mount(path)
   - 只跨越mountpoint, 检查dentry->d_flags的DCACHE_MOUNTED标志
   - 这里是计数模式的遍历

** follow_dotdot(nameidata)
   - nameidata->root->mnt表示root是否无效??
   - 还不确认为何什么时候设置,什么时候不设置??
   - 使用current->fs_struct->root
   > set_root(nameidata)
   - 如果nameidata->path不是root节点,更新nameidata->path->dentry
   - 这里却直接更新nameidata->path
   - 否则向上跳过mountpoint,然后再向上遍历
   > follow_up(nameidata->path)
   - 然后向下跳过mountpoint
   > follow_mount(nameidata->path)
   - 向上遍历,不再检查dentry的automount之类的, 但向下检查需要?

** lookup_dcache(qstr name, dentry dir, flags, need_lookup)
   - 从dir下面查找name对应的dentry
   - 在dentry_hashtable中查找
   > d_lookup(dentry, name)
   - 如果找到，而且dentry->d_flags有DCACHE_OP_REVALIDATE
   > d_revalidate(dentry, flags)
   - 如果返回0,返回的dentry无效, 释放它子树的dentry
   > d_invalidate(dentry)
   - 上面会从dentry_hashtable中释放,如果没人使用这里就直接删除!
   > dput(dentry)
   - 如果<0, 返回错误
   - 如果找不到,创建一个, 设置need_lookup=true
   > d_alloc(dir, name)

** lookup_real(inode, dentry, flags)
   - 使用i_ops操作, inode是目录,dentry是子文件
   > dentry->inode->lookup(dir, dentry, flags)

** __lookup_hash(name, dentry parent, flags)
   - 先在hash中查找 
   > lookup_dcache(name, parent, flags, need_lookup)
   - 如果上面没有找到,也就是need_lookup = 1, 使用i_ops查找
   - 所以下面dentry是新创建的
   > lookup_real(dentry->inode, dentry/name, flags)

** lookup_fast(nameidata, path, inode)
   - 在nameidata->path目录下面查找nemaidata->last
   - 如果使用rcu模式遍历, nameidata->flags包含LOOKUP_RCU
   - 在hash表中查找,seq是返回的dentry->d_seq
   > __d_lookup_rcu(parent, nameidata->last, seq)
   - 找到dentry, 替换nameidata->path
   - 先检查seq, 包括刚找到的,还有nameidata->seq
   > __read_seqcount_retry(dentry->d_seq, seq)
   - 调用DCACHE_OP_REVALIDATE
   > d_revalidate(dentry, nameidata->flags)
   - 处理mountpoint, 同时修改path/inode/seq
   - 只会跨越mountpoint
   - 如果碰到DCACHE_MANAGE_TRANSIT, 就跳转到下面使用ref模式
   > __follow_mount_rcu(nameidata, path, inode)
   - 如果没有问题,直接退出,继续ref模式遍历
   - 如果碰到DCACHE_NEED_AUTOMOUNT, 跳转到下面使用ref模式
   - 上面的所有操作如果不是-ECHILD错误,都会转化为ref模式
   > unlazy_walk(nameidata, dentry)
   - 这里dentry不一定是有效的
   - 去掉nameidata->flags的LOOKUP_RCU, 而且增加nameidata->path/dentry的计数
   - 如果nameidata->root->mnt有效,而且flags没有LOOKUP_ROOT,还有增加nameidata->root的计数
   - 它必须是current->fs_struct->root
   - 如果开始不是rcu模式
   - 同样是查找,找到后立即增加dentry->d_count
   > __d_lookup(parent, nameidata->last)
   - 然后处理DCACHE_OP_REVALIDATE
   > d_revalidate(dentry, nameidata->flags)
   - 如果上面返回0,说明dentry是无效的??
   - 释放这个dentry
   > d_invalidate(dentry)
   > dput(dentry)
   - 处理mountpoint, 处理DCACHE_MANAGED_DENTRY的所有情况
   > follow_managed(path, namiedata->flags)
   - 如果上面2种情况都没找到, 返回1,应该会调用i_ops的查找

   - 查找的操作包括3部分,查找dentry_hashtable, revalidate, 检查mountpoint

** lookup_slow(nameidata, path)
   - 这里应该完全是ref操作
   - 先查找hash表,查找失败时,使用i_ops操作
   > __lookup_hash(nameidata->last, parent, nameidata->flags)
   - 处理mountpoint
   > follow_managed(path, nameidata->flags)
   - 如果跨越了mountpoint, 设置nameidata->flags的LOOKUP_JUMPTED
   - 这里只是更新path, 还没有更新nameidata

** may_lookup(nameidata)
   - 如果是rcu模式 
   > inode_permission(nameidata->inode, MAY_EXEC|MAY_NOT_BLOCK)
   - 如果返回不是-ECHILD, 直接返回
   - 否则变为ref模式
   - unlazy_walk(nameidata, NULL)
   - 然后重新检查
   > inode_permission(nameidata->inode, MAY_EXEC)

** handle_dots(nameidata, type)
   - 只处理type == LAST_DOTDOT的情况?
   - 如果是rcu模式, nameidata->flags包含LOOKUP_RCU 
   - 再处理path指针时,都没有增加计数
   > follow_dotdot_rcu(nameidata)
   - 如果是ref模式
   > follow_dotdot(nameidata)
   - 处理nameidata->path, 同时修改inode/seq, 直接修改nameidata

** terminate_walk(nameidata)
   - 停止遍历
   - 如果是ref模式, 因为找到了最后一部分的dentry??
   > path_put(nameidata->path)
   - 如果是rcu模式, 释放rcu的读锁
   - 还有如果nameidata->flags没有LOOKUP_ROOT,设置nameidata->root->mnt = NULL
   - 这里是恢复开始状态, 没有修改计数?
   > unlock_rcu_walk()

** should_follow_link(inode, follow)
   - 如果i_ops->follow_link无效,就设置inode->i_opflags的IOP_NOFOLLOW
   - 用此来减小一点检查
   - 如果支持,返回follow, 这里只是加一个根据i_op的限制

** walk_component(nameidata, path, follow)
   - 处理nameidata->last, path和nameidata->path什么关系?
   - 如果这个字符串不是普通类型
   - nameidata->last_type != LAST_NORM 
   > handle_dots(nameidata, nameidata->last_type)
   - 如果是正常的普通类型LAST_NORM
   - 先使用fast模式, 基本上在hash中查找
   > lookup_fast(nameidata, path, inode)
   - 上面把查找的结果放到path中, nameidata只是保存seq
   - 如果查找失败,可能是没找到,也可能是-ECHILD
   - 如果没找到,使用slow模式
   > lookup_slow(nameidata, path)
   - 上面会同时获取inode
   - 上面fast遍历传递inode, slow没有, 可能对于rcu模式,需要seq保护获取inode 
   - 而且fast的ref模式,或者slow,使用计数保护,可以随时获取inode
   - 如果没找到inode, 返回-ENOENT
   - 检查follow_link
   > should_follow_link(inode, follow)
   - 如果需要处理link, 变成ref模式, 而且返回1
   > unlazy_walk(nameidata, path->dentry)
   - 否则返回0,把找到的path/inode给nameidata
   - 如果ref模式会释放nameidata->path的计数, 当然不用增加计数,因为上面查找时已经增加
   > path_to_nameidata(path, nameidata)
   
   - 这里对于nameidata->path->mnt的计数的维护
   - 开始遍历时怎么处理root/path???
   - 跨越mountpoint时,如果path->mnt和root->mnt一样,不会增加 
   - 如果不一样, 在follow_managed时增加path->mnt, 在path_to_nameidata时释放nameidata->path->mnt
   - 在遍历结束时, 释放nameidata->path->mnt
   - 在处理symlink时, nameidata->root是不会改变  __vfs_follow_link
   - 如果从root开始遍历,重新设置nameidata->path = root, 而且完全的更新计数
   - 相当于重新开始遍历

   - 对于经过的mnt, 应该不会增加它的使用计数

   - 如果返回1, nameidata->path没有改变, 而且返回1,去处理symlink

** nested_symlink(path, nameidata)
   - 处理symlink的路径
   - path指向的文件是symlink文件
   - 增加nameidata->depth, 用来存储symlink的字符串
   - 获取symlink的字符串, 并遍历下去
   - 留下最后一个路径字段
   > follow_link(path, nameidata, char)
   - 处理最后一部分, 只是查找path
   > walk_component(nameidata, path, LOOKUP_FOLLOW)
   - 如果最后一个文件又是symlink, 循环处理,但不需要新的nameidata->saved_names
   - 虽然depth没有增加,但是内核不能处理超过40个symlink, 所以不会出现无线递归
   - 如果不是就给nameidata->path
   - 然后释放symlink 
   > put_link(nameidata, path, char)
   - 最后减小nameidata->path, 回朔遍历

** can_lookup(inode)
   - 如果inode->i_ops->lookup操作无效,使用IOP_LOOKUP标记
   - 这里检查时,先确认inode->i_opflags的IOP_LOOKUP

** link_path_walk(name, nameidata)
   - 为何没有把name给nameidata? 
   - 从nameidata->path开始,遍历name
   - 跳过name开始的'/'
   - 处理name的每一段路径
   - 并没有完全截取,只是计算一段的长度,和hash值
   > hash_name(name, qstr->hash)
   - 根据截取的设置nameidata->last
   - 如果name是'..'或'.', 设置nameidata->last_type = LAST_DOT/LAST_DOTDOT 
   - 否则设置LAST_NORM
   - 如果name是最后一部分,name[len] == '0', 或者后面是'/', 直接返回
   - 最后一部分不处理??
   - 开始遍历, 下面的参数path只有在symlink时使用
   > walk_component(nameidata, path, LOOKUP_FOLLOW)
   - 如果上面返回1, 需要处理follow_symlink
   > nested_symlink(dentry, nameidata)
   - 然后继续遍历, 知道碰到最后一段,或者dotdot??
   - 最后结束遍历
   > terminate_walk(nameidata)

** path_init(dfd, name, flags, nameidata, file)
   - 这里应该是初始化nameidata
   - 设置nameidata->last_type = LAST_ROOT
   - 只有rmdir处理它? 返回-ebusy
   - 如果flags中包含LOOKUP_ROOT, 表示nameidata->root已经设置
   - 检查nameidata->root指向的dentry/inode是否可用 
   > can_lookup(nameidata->root->dentry->d_inode)
   > inode_permission(inode, MAY_EXEC)
   - 然后设置nameidata->path = nameidata->root, 设置inode
   - 如果是rcu模式, 获取seq, 如果是ref模式, 增加计数
   - 然后直接返回, 这种情况下root/path应该都增加了相应的计数
   - 否则就没有LOOKUP_ROOT, 设置nameidata->root->mnt = NULL
   - 如果name是'/'开始的路径
   - 先找到root位置, 使用current->fs_struct的root
   - 如果是rcu模式
   - 直接使用fs_struct->root, 没有增加计数, 
   - 保存root->dentry->d_seq放到nameidata->seq
   > set_root_rcu(nameidata)
   - 对于ref模式,增加计数, 这里却增加了2次??
   > set_root(nameidata)
   > path_get(nameidata->root)
   - 然后设置nameidata->path = nameidata->root, 退出开始遍历
   - 如果dfd == AT_FDCWD, name是相对路径
   - 设置nameidata->path = current->fs_struct->pwd
   - 否则dfd是一个文件, 先找到它指向的dentry 
   > fdget_raw(dfd)
   - 检查是否能遍历它
   > can_lookup(dentry->d_inode)
   - 如果可以使用, 设置nameidata->path = file->f_path
   - 最后设置nameidata->inode = nameidata->path->dentry->inode
  
** lookup_last(nameidata, path)
   - 处理最后一段, 这里要找到对应的dentry
   - 如果nameidata->last_type == LAST_NORM, 而且last不是最后一部分?
   - 路径字符串后面还有? 应该是什么? '/'??
   - 设置nameidata->flags的LOOKUP_FOLLOW|LOOKUP_DIRECTORY
   - 去掉nameidata->flags的LOOKUP_PARENT
   - 查找dentry, 可能放到nameidata中
   > walk_component(nameidata, path, nameidata->flags & LOOKUP_FOLLOW)

** path_lookupat(dfd, name, flags, nameidata)
   - 首先初始化nameidata
   > path_init(dfd, name, flags|LOOKUP_PARENT, nameidata, file)
   - 开始遍历
   > link_path_walk(name, nameidata)
   - 如果上面没有错误,而且flags没有LOOKUP_PARENT, 继续查找最后一段
   > lookup_last(nameidata, path)
   - 如果返回>0, 最后一个路径是symlink, 而且nameidata->flags表示要遍历它 
   - 开始循环处理symlink
   - 这里是最后一段路径,不需要使用nameidata->saved_names保存,所以不需要改变nameidata->depth
   > may_follow_link(path, nameidata)
   - 设置nameidata->flags的LOOKUP_PARENT 
   > follow_link(path, nameidata, void)
   - 继续查找 
   > lookup_last(path, nameidata, void) 
   - 释放symlink 
   > put_link(path, nameidata, cookie)
   - 结束遍历, 从rcu模式变为ref模式
   > complete_walk(nameidata)
   - 释放nameidata->root 
   - 只有路径开头是'/'时才设置root, 其他情况不会设置
   > path_put(nameidata->root)

** filename_lookup(dfd, filename, flgs, nameidata)
   - 首先使用rcu模式遍历 
   > path_lookupat(dfd, filename->name, flags|LOOKUP_RCU, nameidata)
   - 如果返回-ECHILD, 使用普通方式 
   > path_lookupat(dfd, name, flags, nameidata)
   - 如果返回-ESTALE, 再换一种
   > path_lookupat(dfd, name, flags|LOOKUP_REVAL, nameidata)

** do_path_lookup(dfd, name, flags, nameidata)
   > filename_lookup(dfd, filename, flags, nameidata)

** kern_path_locked(name, path)
   - 遍历路径, 对于组后一段,查找他的dentry
   > do_path_lookup(AT_FDCWD, name, LOOKUP_PARENT, nameidata)
   - 检查nameidata->last_type != LAST_NORM, 返回-EINVAL
   - 最后查找nameidata->last的dentry
   > __lookup_hash(nameidata->last, nameidata->path->dentry, 0)
   - 返回参数是找到的dentry, 
   - nameidata->path是父目录,而且计数都没有释放
   
   - 给其他模块使用

** kern_path(name, flags, path)
   - 这里传入参数flags, 一般不会指定LOOKUP_PARENT
   > do_path_lookup(AT_FDCWD, name, flags, nameidata)
   - 如果没有问题,传回path是最后的位置

** vfs_path_lookup(dentry, vfsmount, name, flags, path)
   - 前2个参数限定nameidata->root, 从它下面查找name, 结果给path
   - 下面使用LOOKUP_ROOT, 表示在开始查找时不用再计算nameidata->root
   > do_path_lookup(AT_FDCWD, name, flags | LOOKUP_ROOT, nameidata)
   - 和上面一样,没有LOOKUP_PARENT, 一直遍历到最后
   - 返回nameidata->path, 也就是最终位置

** lookup_hash(nameidata)
   - 查找last指向的dentry
   - flags会传给d_op->d_revalidate, 以及i_op->lookup
   > __lookup_hash(nameidata->last, nameidata->path->dentry, nameidata->flags)

** lookup_one_len(name, dentry, len)
   - len表示文件名字,不包含路径的'/'
   > __lookup_hash(qstr, dentry, 0)

** user_path_at_empty(dfd, name, flags, path, empty)
   - 先从userspace中获取filename
   - 查找dentry, 给path 
   > filename_lookup(dfd, filename, flags, nameidata)

** user_path_at(dfd, name, flags, path)
   > user_path_at_empty(dfd, name, flags, path, NULL)

** user_path_parent(dfd, name, nameidata, flags)
   - 从userspace获取name 
   > getname(name)
   - 只使用flags中的LOOKUP_REVAL
   - 遍历会留下最后一段路径
   > filename_lookup(dfd, filename, flags | LOOKUP_PARENT, nameidata)

** open_flags 
   #+BEGIN_SRC 
	int open_flag;
	umode_t mode;
	int acc_mode;
	int intent;
	int lookup_flags;   
   #+END_SRC

** vfs_create(inode, dentry, mode, want_excl)
   - 检查权限 
   > may_create(inode, dentry)
   - 如果i_op->create为NULL, 返回-EACCESS
   > inode->i_op->create(inode, dentry, mode, want_excl)

** atomic_open(nameidata, dentry, path, file, open_flags, got_write, need_lookup, opened)
   - dentry表示最终的位置,应该是创建的negative的 
   - path是返回参数, file也是,表示需要打开的file
   - nameidata是dentry所在的位置
   - need_lookup表示dentry是negative的,它是新创建的
   - got_write表示获取的文件系统的写权限, 写计数, 因为打开标志中有write,create,trunc
   - 获取open_flag
   > open_to_namei_flags(open_flags->open_flag)
   - 如果没有O_CREAT, 直接去lookup, 再去open
   - 如果got_write ==0, 表示不允许写, 所以exclusive创建,或者trunc打开都必须失败
   - 如果没有O_CREAT, 跳到no_open, 哪里会继续查找
   - 如果有O_CREAT, 以及O_EXCL或者O_TRUNC, 跳到no_open, 而且会返回EROFS
   - 否则有O_CREAT, 但文件存在,就不用返回错误, 继续处理
   - 开始create,检查权限 MAY_WRITE|MAY_EXEC
   > may_o_create(nameidata->path, dentry, mode)
   - 打开文件
   > nameidata->path->dentry->inode->i_op->atomic_open(inode, dentry, file, open_flags, mode, opened)
   - 上面没有错误会返回0, 而且设置file
   - 如果失败, 再去looked_up
   - 如果没有错误, 检查file->path->dentry->inode的权限
   - 之所以在这里检查,因为上面没有获取inode
   > may_open(file->path, acc_mode, open_flag)
   - 然后返回检查的结果
   - 如果上面不是创建,跳到这里开始lookup
   - 如果need_lookup !=0, 使用i_op->lookup 
   > lookup_real(inode, dentry, nameidata->flags)
   - 如果找到dentry, 已经存在file, 而上面有各种错误, 这里返回哪些错误
   - 然后设置返回参数path, 而且返回1

** lookup_open(nameidata, path, file, open_flags, got_write, opened)
   - 先查找lookup, 然后打开open?
   - got_write表示获取文件系统的写权限
   - 先查找nameidata最后指向的文件
   - 这里仅仅在hash中查找, 如果找不到need_lookup = true
   > lookup_dcache(nameidata->last, dir, nameidata->flags, need_lookup)
   - 如果已经找到,而且有inode
   - need_lookup = fasle, dentry->d_inode != NULL
   - 直接把找到的dentry/nameidata->path->mnt给path, 返回1
   - 如果nameidata->flags有LOOKUP_OPEN 使用atomic_open, 不再处理
   > atomic_open(nameidata, dentry, path, file, op, got_write, need_lookup, opened)
   - 没有atomic_open, 就需要lookup, open??
   - 如果上面在dentry_hashtable中没有找到, need_lookup == true, 使用i_op查找 
   > lookup_real(dir_inode, dentry, nameidata->flags)
   - 如果找到的dentry是negative, 也就是文件不存在, 而且open_flag有O_CREAT, 创建文件
   > vfs_create(dir->d_inode, dentry, mode, nameidata->flags & LOOKUP_EXCL)
   - 最后返回dentry/mnt

** do_last(nameidata, path, file, open_flags, opened, filename)
   - 同样处理路径的最后一段, nameidata->last
   - 检查nameidata->last_type, 如果不是LAST_NORM, 那就是LAST_DOTDOT 
   > handle_dots(nameidata, nameidata->last_type)
   - 上面直接更新nameidata->path, 然后跳到后面处理 finish_open??
   - 否则就是LAST_NORM
   - 如果open_flag没有O_CREAT, 是正常的打开
   - 如果last不是路径的最后一段,后面应该有'/'
   - 设置nameidata->flags的 LOOKUP_DIRECTORY|LOOKUP_FOLLOW, 表示打开一个文件夹
   - 如果open_flag没有O_PATH, 仅仅打开文件,不会有IO
   - 如果open使用O_NOFOLLOW, 如果打开的文件是symlink返回失败
   - open会返回-ELOOP,但这里只是返回1
   - 但它不会影响遍历过程中的LOOKUP_FOLLOW, 只是影响最后一段
   - 但如果是O_PATH, 就可以使用O_NOFOLLOW, 这里设置symlink_ok = true
   - 查找最终的文件
   > lookup_fast(nameidata, path, inode)
   - 如果返回0, 表示文件找到, 跳到finish_lookup, 继续open操作
   - 如果返回1表示文件没找到
   - 如果open_flag有O_CREAT, 是创建文件
   - 停止遍历
   > complete_walk(nameidata)
   - last必须是最后的字符串, 他最后必须是'0', 否则返回-EISDIR
   - 如果open_flag有O_CREAT|O_TRUNC|O_WRONLY|O_RDWR, 检查文件系统是否可写
   > mnt_want_write(nameidata->path->mnt)
   - 如果支持写,设置got_write = true
   - 开始查找并打开操作
   - 里面会先尝试atomic_open
   - 如果不支持,而且文件不存在,则创建文件
   > lookup_open(nameidata, path, file, open_flag, got_write, opened)
   - 如果返回0,表示文件已经打开, 直接跳到最后 opened
   - 如果返回<0, 返回操作失败, 返回失败
   - 如果返回1, 表示没有open操作, 只是lookup或者create
   - 如果上面创建文件, 去掉O_TRUNC
   - 把path给nameidata->path, 跳到finish_open_created, 直接打开file
   - 如果open_flag包含O_EXCL|O_CREAT, 但没有创建, 直接退出
   - 返回-EEXIST, 因为文件已经存在
   - 跳跃mountpoint??
   > follow_managed(path, nameidata->flags)
   - 上面已经查找到需要的目标文件path, finish_lookup??
   - 如果path->dentry->d_inode == NULL, 说明是negative的,不存在这个文件
   - 设置nameidata, 返回-ENOENT, 跳到最后结束遍历
   > path_to_nameidata(path, nameidata)
   - 处理symlink, 是否需要展开
   - 决定于O_NOFOLLOW, O_PATH
   > should_follow_link(inode, !symlink_ok)
   - 如果需要展开, 直接返回1, 不需要结束遍历
   - 现在还是rcu模式, 变为ref模式
   > unlazy_walk(namiedata, path->dentry)
   - 否则打开symlink文件
   - 准备nameidata, inode
   - 这里结束遍历  finish_open
   > complete_walk(nameidata)
   - 检查权限
   - 如果open_flag包含O_CREAT, 而且inode是dir, 返回-EISDIR
   - 如果nameidata->flags包含LOOKUP_DIRECTORY, 但没有权限Lookup, 返回-ENOTDIR? 
   > can_lookup(nameidata->inode)
   - LOOKUP_DIRECTORY表示查找目标是目录
   - 上面完成打开/创建的检查  finish_open_created
   - 组装file, 建立file的关系
   > finish_open(file, nameidata->path->dentry, NULL, opened)
   - 最后处理打开之后的操作  opened
   - 检查是否支持dio和O_DIRECT
   > open_check_o_direct(file)
   - 检查truncate 
   > handle_truncate(file)
   - 最后释放nameidata的资源
   > terminate_walk(nameidata)

   - 打开的步骤包括
   - 找到父目录,也就是遍历的过程, 获取nameidata, last
   - 查找last, 获取dentry, 获取inode等
   - 如果是O_CREAT, 还要打开文件
   - 处理symlink, 结束遍历
   - 检查权限, 使用inode检查, 还有写,文件类型
   - 打开file  finish_open(..)
   - 打开之后的的操作, truncate, direct

** path_openat(dfd, filename, nameidata, open_flags, flags)
   - 先准备file, 保存file->f_flags = open_flags->open_flag
   > get_empty_filp() 
   - 如果是创建临时文件
   > do_tmpfile(dfd, pathname, nameidata, flags, open_flags, file, opened)
   - 否则就是正常的打开操作
   - 先初始化nameidata 
   > path_init(dfd, pathname->name, flags | LOOKUP_PARENT, nameidata, file)
   - 遍历路径 
   > link_path_walk(pathname->name, nameidata)
   - 然后处理路径的最后一段
   > do_last(nameidata, path, file, open_flags, opened, pathname)
   - 如果返回1, 表示最后一段是symlink
   > 如果nameidata->flags没有LOOKUP_FOLLOW, 返回-ELOOP
   - 不让处理symlink, 使用了O_NOFOLLOW
   - 检查inode是否支持symlink
   > may_follow_link(path, nameidata)
   - 如果不允许展开,返回-ELOOP, 否则继续遍历
   - 设置nameidata->flags的LOOKUP_PARENT
   - 去掉LOOKUP_OPEN|LOOKUP_CREATE|LOOKUP_EXCL
   - 遍历符号链接
   > follow_link(path, nameidata, void)
   - 剩下最后一段路径
   > do_last(nameidata, path, file, open_flags, opened, pathname)
   - 释放symlink的资源 
   > put_link(nameidata, path, cookie)
   - 上面会循环,知道返回的不是>0
   - 最后返回file
   - 最后清理唤醒, 如果没有LOOKUP_ROOT, 而且使用nameidata->root
   - 这里释放它 
   > path_put(nameidata->root)

** do_filp_open(dfd, filename, open_flags)
   - 这时open的syscall处理
   - nameidata的初始化在下面函数里面 
   - 外面传递了open_flags, 也就是open_flags->lookup_flags给nameidata->flags
   - 去open里面看一下flags的使用
   - 创建file, 首先使用rcu模式
   > path_openat(dfd, pathname, nameidata, open_flags, flags|LOOKUP_RCU)
   - 如果返回-ECHILD, 使用普通的模式, 也就是open_flags->lookup_flags
   > path_openat(dfd, pathname, nameidata, open_flags, flags)
   - 如果返回-ESTALE, 使用LOOKUP_REVAL
   > path_openat(dfd, pathname, nameidata, open_flags, flags | LOOKUP_REVAL)

** do_file_open_root(dentry, vfsmount, char* name, open_flags)
   - 这个函数提供查找的root, 而且从他开始
   - 设置nameidata->root = {dentry, vfsmount)
   - 使用的lookup_flag是 open_flags->lookup_flags | LOOKUP_ROOT
   - 如果dentry->inode->i_op->follow_link有效, 而且open_flags->intent有LOOUP_OPEN, 返回-ELOOP?
   - 然后开始打开操作, 和上面一样,尝试3种

** kern_path_create(dfd, pathname, path, lookup_flags)
   - 只是遍历路径, 使用的标志是
   - lookup_flags & LOOKUP_REVAL | LOOKUP_PARENT, 只使用LOOKUP_PARENT, 可能使用LOOKUP_REVAL
   > do_path_lookup(dfd, pathname, LOOKUP_PARENT|lookup_flags, nameidata)
   - 如果nameidata->last_type不是LAST_NORM 返回-EEXIST
   - 去掉nameidata->flags的LOOKUP_PARENT, 添加LOOKUP_CREATE|LOOKUP_EXCL
   - 检查文件系统是否只读
   > mnt_want_write(nameidata->path->vfsmount)
   - 然后查找最后一部分
   > lookup_hash(nameidata)
   - 如果dentry不是negative, dentry->inode有效, 返回-EEXIST
   - 如果nameidata->last不是最后一段, 后面还有'/'?? 而且开始要求创建的不是目录, 返回-ENOENT
   - 最后返回negative的dentry, path返回父目录
   - LOOKUP_DIRECTORY表示查找目标是目录

** done_path_create(path, dentry)
   - 在创建完成之后的操作? 
   > dput(dentry)
   > mnt_drop_write(path->mnt)
   > path_put(path)

** user_path_create(dfd, pathname, path, lookup_flags)
   > kern_path_create(dfd, filename->name, path, lookup_flags)

** vfs_mknode(inode, dentry, mode, dev)
   > inode->i_op->mknode(inode, dentry, mode, dev)

** mknodat(dfd, filename, mode, dev)
   - 检查权限 
   > may_mknod(mode)
   - 处理路径, 创建dentry, 找到目录path
   > user_path_create(dfd, filename, path, lookup_flags)
   - 如果是普通文件, 最后一个参数是excl
   > vfs_create(path->dentry->inode, dentry, mode, true)
   - 如果是chr/blk设备 
   > vfs_mknod(path->dentry->inode, dentry, mode, dev)
   - 如果是fifo/sock 
   > vfs_mknod(path->dentry->inode, dentry, mode, 0)
   - 最后释放dentry/path的计数
   > done_path_create(path, dentry)

** vfs_mkdir(inode, dentry, mode)
   - inode->i_op->mkdir(inode, dentry, mode)

** mkdirat(dfd, pathname, mode)
   - 和mknodat一样
   - 查找的flags是LOOKUP_DIRECTORY
   - 处理路径
   > user_path_create(dfd, pathname, path, lookup_flags)
   - 创建目录
   > vfs_mkdir(path->dentry->inode, dentry, mode)
   > done_path_create(path, dentry)

** dentry_unhash(dentry)
   - 释放dentry的hash表关系, 前提是dentry->d_count == 1
   > __d_drop(dentry)

** vfs_rmdir(inode, dentry)
   - 大量检查
   - i_op->rmdir无效, 返回-EPERM
   - dentry是mountpoint,返回-EBUSY
   - 释放dentry 
   > shrink_dcache_parent(dentry)
   - 删除 
   > inode->i_op->rmdir(inode, dentry)
   - 设置dentry->inode->i_flags的S_DEAD??  dentry->d_flags的DCACHE_CANT_MOUNT
   - 然后释放dentry 
   > dput(dentry)
   - 释放它, 应该是变为negative的? 或者变为unhash的?
   > d_delete(dentry)
 
** do_rmdir(dfd, pathname)
   - 先处理路径,找到dentry和所在的目录
   > user_path_parent(dfd, pathname, nameidata, lookup_flags)
   - 检查nameidata->last_type, 应该是LAST_NORM, 其他的返回相应的错误
   - 找到要删除的dentry
   > lookup_hash(nameidata)
   - 如果找不到,或者negative的返回错误
   - 删除目录 
   > vfs_rmdir(nameidata->path->dentry->inode, dentry)
   - 最后释放dentry, nameidata->path


** 总结
   - 对于改变文件属性的操作,不会打开文件, 比如truncate/chown等. 他会只会定位dentry直接操作
