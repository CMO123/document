* dcache.c

** dentry
   #+BEGIN_SRC 
	/* RCU lookup touched fields */
	unsigned int d_flags;		/* protected by d_lock */
	seqcount_t d_seq;		/* per dentry seqlock */
	struct hlist_bl_node d_hash;	/* lookup hash list */
	struct dentry *d_parent;	/* parent directory */
	struct qstr d_name;
	struct inode *d_inode;		/* Where the name belongs to - NULL is
					 * negative */
	unsigned char d_iname[DNAME_INLINE_LEN];	/* small names */

	/* Ref lookup also touches following */
	unsigned int d_count;		/* protected by d_lock */
	spinlock_t d_lock;		/* per dentry lock */
	const struct dentry_operations *d_op;
	struct super_block *d_sb;	/* The root of the dentry tree */
	unsigned long d_time;		/* used by d_revalidate */
	void *d_fsdata;			/* fs-specific data */

	struct list_head d_lru;		/* LRU list */
	/*
	 * d_child and d_rcu can share memory
	 */
	union {
		struct list_head d_child;	/* child of parent list */
	 	struct rcu_head d_rcu;
	} d_u;
	struct list_head d_subdirs;	/* our children */
	struct hlist_node d_alias;	/* inode alias list */   
   #+END_SRC

** dentry_operations
   #+BEGIN_SRC 
	int (*d_revalidate)(struct dentry *, unsigned int);
	int (*d_weak_revalidate)(struct dentry *, unsigned int);
	int (*d_hash)(const struct dentry *, struct qstr *);
	int (*d_compare)(const struct dentry *, const struct dentry *,
			unsigned int, const char *, const struct qstr *);
	int (*d_delete)(const struct dentry *);
	void (*d_release)(struct dentry *);
	void (*d_prune)(struct dentry *);
	void (*d_iput)(struct dentry *, struct inode *);
	char *(*d_dname)(struct dentry *, char *, int);
	struct vfsmount *(*d_automount)(struct path *);
	int (*d_manage)(struct dentry *, bool);   
   #+END_SRC

** d_hash(dentry, hash)
   - 计算dentry在dentry_hashtable中的hash索引

** __d_free(rcu_head)
   - 使用rcu释放dentry内存, 还有dentry->d_name
   - 这是保证dentry->d_alias不在hash表中?

** d_free(dentry)
   - 释放dentry, 要求dentry->d_count == 0
   > dentry->dentry_operations->d_release(dentry)
   - 如果dentry->d_flags有DCACHE_RCUACCESS, 表示使用rcu访问过
   - 在路径查找中有2种,一种是rcu, 一种是锁方式
   - 如果有DCACHE_RCUACCESS, 使用rcu释放
   > call_rcu(dentry->d_u->d_rcu, __d_free)
   - 否则直接释放 
   > __d_free(dentry->d_u.d_rcu)
   - 在d_kill中使用

** dentry_rcuwalk_barrier(dentry)
   - 使rcu遍历方式失效, rcu怎么使用seq??
   > write_seqcount_barrier(dentry->d_seq)

** dentry_iput 
   - 在d_kill中使用,它是释放dentry和inode的关系
   - 设置dentry->d_inode = NULL, d_alias现在成了hash表
   > hlist_del_init(dentry->d_alias)
   - 如果inode->i_nlink ==0, 同法fsnotify消息?
   > fsnotify_inoderemove
   - d_iput就是调用了iput,释放inode->i_count计数
   - 如果没有使用, 放到lru队列中
   - nfs实现了，释放sillyrename和子目录的缓存
   > d_op->d_iput(dentry, inode)

** dentry_unlink_inode(dentry)
   - 和上面一样, 释放dentry->d_alias
   - ruc的访问方式和seq_lock一块,无效这种访问方式
   > dentry_rcuwalk_barrier(dentry)
   - 释放inode计数 
   > dentry->d_op->d_iput(dentry, inode)
   - 在d_delete中使用, 在删除inode时使用
   - 变为negative的dentry

** dentry_lru_add(dentry)
   - 把dentry->d_lru放到super_block->s_dentry_lru队列中
   - 增加super_block->s_nr_dentry_unused计数
   - 在dput中调用

** __dentry_lru_del(dentry) 
   - 释放dentry->d_lru链表
   - 去掉dentry->d_flags的DCACHE_SHRINK_LIST标志
   - 减小super_block->d_nr_dentry_unused

** dentry_lru_del(dentry)
   - 使用dcache_lru_lock锁
   > __dentry_lru_del(dentry)
   - dentry->d_lru不仅仅放到super_block中,还有用来收集需要释放的dentry

** dentry_lru_move_list(dentry, list_head)
   - list_head用来收集需要释放的dentry 
   - 如果dentry->d_lru为空,把它放到list_head链表中
   - 否则移动到最后面

** d_kill(dentry, dentry parent) 
   - 释放dentry的内存,现在已经在hash和lru中释放
   - 释放dentry->d_u->d_child, 从父目录中释放
   - 设置dentry->d_flags 的DCACHE_DISCONNECT, 表示不再可用
   - 只有在回朔删除父dentry时才使用
   - 释放和inode的关系
   > dentry_iput(dentry) 
   - 释放自己
   > d_free(dentry) 

** __d_shrink(dentry)
   - 释放hash表关系, 如果不在hash表中,直接返回
   > d_unhashed(dentry)
   - dentry使用2中hash链表
   - 一个是suepr_block->s_anon, 另一个是dentry_table
   - 释放时需要hash表头的锁
   - dentry->d_flags的DCACHE_DISCONNECTED表示在anon链表中
   > hlist_bl_lock(hlist_bl_head)
   > __hlist_bl_del(dentry->d_hash)

** __d_drop(dentry)
   - 这里是释放hash表, 至少使dentry无法访问
   - 检查是否在hash表中
   > d_unhashed(dentry)
   > __d_shrink(dentry)
   > dentry_rcuwalk_barrier(dentry)

** d_drop(dentry)
   - 释放dentry->d_lock锁住 
   > __d_drop(dentry)

** dentry_kill(dentry, ref)
   - 释放dentry, 返回d_parent,可以回朔回收
   - 先找到父目录, 锁住inode->i_lock和parent->d_lock
   - 如果ref有效, 减小dentry->d_count
   - 如果dentry->flags有DCACHE_OP_PRUNE
   - 通知文件系统dentry要释放
   > dentry->d_op->d_prune(dentry)
   - 释放lru链表
   > dentry_lru_del(dentry)
   - 释放hash表
   - __d_drop(dentry)
   - 释放inode, 父dentry, 还有自己
   - d_kill(dentry, parent)

** dput(dentry)  
   - 减小dentry->d_count, 如果d_count减到0,则释放它
   - 如果d_count没有到0，则返回
   - 如果dentry->flags有DCACHE_OP_DELETE,回调函数决定是否直接删除
   - 对于nfs来说,检查对应的inode是否有错误 nfs_dentry_delete
   > d_ops->d_delete(dentry)
   - 如果不在hash表中, 直接释放
   > d_unhashed(dentry)
   - 否则不会释放,放到lru队列中,设置DCACHE_REFERENCED标志.
   > dentry_lru_add(dentry)
   > dentry->d_count --
   - 如果要释放, 函数返回d_parent, 回朔释放
   > dentry_kill(dentry, 1)

** d_invalidate(dentry)
   - 如果dentry不在hash表中,则不处理, 已经无效
   - 如果dentry->d_subdirs不是空,有子dentry
   - 去遍历它的子树，收集没有使用的释放
   - shrink_dcache_parent(dentry) 
   - 如果dentry->d_count > 1, 而且inode有效, 而且是目录,返回-EBUSY
   - 释放hash表关系, 表示不在vfs的树中,只是没有释放
   > __d_drop(dentry) 

** 总结
   - 释放有很多种
   - 一种是放到lru队列中 dput
   - 一种是有条件的直接释放 kill
   - 一种是释放hash表关系, invalidate/drop
   - 下面还有一种,释放整个super_block的dentry
   - 如果没有关联inode,是negative, 而且没有使用者, 虽然在hash表里面

** __dget_dlock / __dget(dentry) 
   - 修改dentry->d_count

** dget_parent(dentry) 
   - 使用dentry->d_lock锁住
   - 增加d_parent的计数

** __d_find_alias(inode, want_discon)
   - 找一个inode关联的dentry,增加计数
   - 遍历inode->i_dentry链表中的dentry
   - 过滤掉不是文件夹也不在hash表中的, 那些是无效的
   - 如果want_discon=1, 必须找一个root,而且是DCACHE_DISCONNECTED的dentry
   - 否则必须找一个不是root, 而且不带DCACHE_DISCONNECTED的
   > __dget_dlock(dentry)

** d_find_alias(inode)
   - 使用dinode->i_lock锁住, 找一个正常的dentry
   > __d_find_alias(inode, 0)

** d_prune_aliases(inode)
   - 释放inode关联的dentry 
   - 遍历inode->i_dentry链表中的dentry
   - 只处理dentry->d_count ==0的 
   > __dget_dlock(dentry)
   - 释放hash表关系
   > __d_drop(dentry)
   - 再释放计数, 如果没有其他人使用,这时应该会释放
   - 因为d_drop释放hash关系
   > dput(dentry)

** try_prune_one_dentry(dentry) 
   - 这个dentry已经不再使用, 这是使用lru回收的
   - 先释放自己
   > dentry_kill(dentry, 0)
   - 如果parent->d_count>1,有别人使用它
   - 减小计数, 直接返回
   - 否则继续回朔释放
   - dentry_kill(dentry, 1)  

** 总结
   - dentry释放的锁有4种
   - 上面的操作应该是获取dentry->d_lock
   - 在开始释放时,获取inode/parent的索
   - 里面有hash操作,使用自己的索
   - 然后释放d_child链表, 设置DCACHE_DENTRY_KILLED, 释放parent->d_lock
   - 然后释放inode关系,释放inode锁
   - 最后再释放自己之前,释放d_lock

** shrink_dentry_list(list_head) 
   - 删除一队列的dentry, 队列使用d_lru, 遍历这些dentry
   - 如果dentry->d_count > 0, 不能释放
   - 只是释放lru链表,从当前链表中释放
   - 否则释放它,而且释放父dentry
   > try_prune_one_dentry(dentry)

** shrink_dcache_sb(super_block, count) 
   - 尝试super_block中空闲的dentry
   - 遍历super_block->s_dentry_lru
   - 如果dentry带标志DCACHE_REFERENCED,则把它放回去
   - 否则放到临时链表中,最后集中释放
   - 这里使用dcache_lru_lock保护,和上面的lru操作很想
   - shrink_dentry_list(list)

** shrink_dcache_sb(super_block)
   - 释放整个super_block->s_dentry_lru链表, 直到为空
   > shrink_dentry_list(list_head)

** shrink_dcache_for_umount_subtree(dentry) 
   - umount时使用,释放super_block的所有dentry
   - dentry必须是root
   - 使用树的深度优先遍历, 删除dentry
   - 开始循环, 先到最底层的dentry, d_subdirs为空
   - 通知fs
   > d_op->d_prune(dentry)
   - 释放lru和hash关系
   > dentry_lru_prune(dentry)
   > __d_shrink(dentry)
   - 如果dentry->d_count >0, 报错
   - 释放父dentry的关系
   - list_del(dentry->d_u->d_child)
   - 释放inode关系
   > hlist_del_init(dentry->d_alias)
   > d_op->d_iput(dentry, inode)
   - 最后释放自己
   > d_free(dentry)
   - 这里没有使用任何锁??

** shrink_dcache_for_umount(super_block)
   - 首先释放super_block->s_root对应的子树
   > shrink_dcache_for_umount_subtree(dentry)
   - 然后是super_block->s_anon链表上的
   - 链表使用dentry->d_hash?? 上面可能有遗漏的
    -这里不会干扰上面的释放,因为不会增加计数
   - 遍历hash表上的dentry
   > shrink_dcache_for_umount_subtree(dentry)
   - 在关闭super_block中调用
   > kill_anon_super(super_block)
   > generic_shutdown_super(super_block)
   > shrink_dcache_for_umount(super_block)
	
** try_to_ascend(old, locked, seq) 
   - 找dentry->d_parent 
   - 如果old->flags有DCACHE_DENTRY_KILLED, 或者seq和rename_lock不一致, 返回NULL

** have_submounts(parent)
   - 检查parent的子树的文件夹中,是否有mountpoint
   - dentry->d_flags的DCACHE_MOUNTPOINT表示它是mountpoint
   > d_mountpoint(dentry)
   - 因为这里是有序树,而且遍历的时候树的结构不会改变, 可以使用循环的方式表示递归
   - 刚才写了python, 不需要有序,但删除的操作,也可实现

** select_parent(dentry, list_head ) 
   - 遍历dentry的子树,回收d_count为0的dentry
   - 如果d_count>0, 从lru队列中释放
   > dentry_lru_del(dentry)
   - 如果dcache->d_flags没有DCACHE_SHRINK_LIST,说明没有在回收
   - 可以放到参数链表中,防止循环,添加DCACHE_SHRINK_LIST标志
   > dentry_lru_move_list(dentry, dispose) 
   - 这个dentry应该是最下层,否则它的计数不能为0
   - 这里遍历使用2遍,第一次是read方式的rename_lock, 第二遍是write方式的rename_lock
   - 在遍历回朔时, 检查parent关系是否改变,以及rename_lock是否改动
   - 遍历时会检查d_parent是否为NULL, 
   - 但d_lru链表的修改使用dentry->d_lock

** shrink_dcache_parent(dentry)
   - 回收dentry目录下不使用的dentry 
   > select_parent(parent, list_head)
   - 不使用的直接释放
   > shrink_dentry_list(list_head)

** __d_alloc(sb, name) 
   - 创建dentry
   - 根据参数这里只设置super_block和name, 还有super_block->d_ops
   - 会增加parent的计数, 同时把dentry放到parent->d_u.d_child队列中.

** d_alloc(parent, name)  
   - 创建dentry
   > __d_alloc(parent->super_block, name)
   - 增加parent->d_count计数
   > __dget_dlock(parent)
   - 把dentry->d_u->d_child放到parent->d_subdirs链表中

** d_alloc_pseudo(super_block, name)
   - 创建一个dentry 
   > __d_alloc(super_block, name)
   - 设置dentry->d_flags的DCACHE_DISCONNECTED
   
** d_alloc_name(parent, name)
   - 上面的name都是qstr, 这里包装一下
   > d_alloc(parent, dentry)

** d_set_d_op(dentry, dentry_operations)
   - 设置dentry->d_op = dentry_operations
   - 每个dentry_operations的函数对应一个标志DCACHE_

** __d_instantiate(dentry, inode) 
   - 建立dentry和inode的关系, 把dentry放到inode->i_dentry队列中
   - 如果inode是AUTOMOUNT,设置dentry->d_flags的DCACHE_NEED_AUTOMOUNT
   > dentry_rcuwalk_barrier(dentry)

** d_instantiate(dentry, inode) 
   - 有了inode的dentry就不是negative的dentry, 但dentry的计数还是不变
   - 必须保证dentry不在hash表中, 也就是无效的
   > hlist_unhashed(dentry->d_alias)
   > __d_instantiate(dentry, inode)

** __d_instantiate_unique(dentry, inode)
   - 而对inode的使用计数在外部已经增加
   - 和上面的区别时,这里先遍历inode->i_dentry链表
   - 比较是否有重复的, hash, d_parent, name
   > __d_instantiate(dentry, inode)

** d_instantiate_unique(dentry, inode)
   - 关联inode/dentry, 如果有重复的,返回已经关联的dentry 
   > __d_instantiate_unique(dentry, inode)

** d_make_root(inode) 
   - 创建dentry,name="/",然后关联inode
   > __d_alloc(inode->i_sb, name)
   > d_instantiate(dentry, inode)
   - 这里也没有增加inode计数??

** __d_find_any_alias(inode) 
   - 从inode->i_dentry队列上去一个dentry
   > hlist_entry(inode->i_dentry.first, struct dentry, d_alias)
   - 增加使用计数
   - __dget(dentry)

** d_find_any_alias(inode)
   - 锁住inode 
   > __d_find_any_alias(inode)

** d_obtain_alias(inode)
   - 先查找一个
   > d_find_any_alias(inode)
   - 如果找不到,就创建一个
   > __d_alloc(inode->i_sb, string) 
   - 设置DCACHE_DISCONNECTED, 关联inode和dentry的关系, 把这个创建的dentry放到inode->i_sb->s_anon中
   - 这个dentry是临时的,没有在parent的树中,也没有在hash表中
   - 名字是'/', 也是anonymous

** d_splice_alias(inode, dentry) 
   - 关联inode和dentry
   - 如果inode是目录,首先找是否有DCACHE_DISCONNECTED的dentry
   - __d_find_alias_inode(inode, 1)
   - 把找到的dentry放到参数dentry的位置,而且切换name
   - d_move(new, dentry)
   - 没有空闲的，就关联这两个 
   > __d_instantiate(dentry, inode)
   - 重新插入到hash表中
   > d_rehash(dentry)
   - 对于普通文件,就直接关联,同时重新计算hash表位置
   > d_add(dentry,inode) 

** d_add_ci(dentry, inode, name)
   - 首先在父目录下面找一个name的文件
   > d_hash_and_lookup(dentry->d_parent, name) 
   - 如果没找到，就创建一个
   > d_alloc(dentry->d_parent, name)
   - 然后建立和inode的联系
   > d_splice_alias(inode, new)
   - 如果找到了,而且关联同样的inode,返回找到的dentry
   - 应该没有关联inode, 也就是negative的
   - d_splice_alias(inode, dentry)
   - 只有ntfs和xfs使用

** 总结
   - 创建有两种，一种指定parent, 另一种不指定
   - 两种都要有super_block
   - 使用parent的，创建后就会放到parent的孩子队列中
   - 然后可以关联inode，同时把它inode的alias队列中
   - 然后考虑放到hash队列中,但放到hash队列中
   - 主要在find操作中使用,检查是否已有存在的dentry,有的话用存在的
   - 没有的话创建新的,并关联inode，放到hash队列中.

** __d_lookup_rcu(parent, name, seq, inode) 
   - 在parent下面找name对应的dentry
   - 这里不是遍历dentry->d_subdirs, 而是使用hash表??
   - 使用dentry->d_seq包含
   - 过滤掉不在hash表中的dentry
   > d_unhashed(dentry)
   - 比较name和dentry->d_name 
   > slow_dentry_cmp(parent, dentry, seq, name)

** d_lookup(parent, name)
   - 使用rename_lock保护 
   > __d_lookup(parent, name)

** __d_lookup(dentry, name)
   - 和__d_lookup_rcu相同, 不过这里使用ruc的锁
   > rcu_read_lock()
   - 没有使用seq锁, 如果找到,增加dentry->d_count 

** d_hash_and_lookup(dentry, name)
   - 在dentry目录下,查找name对应的dentry 
   > d_lookup(dentry, name)
   - 这里是增加dentry->d_count

** d_validate(dentry, parent) 
   - 通过查找parent->d_subdir, 验证dentry没问题
   - 增加dentry的计数，没人用！

** d_delete(dentry) 
   - 在删除文件时删除dentry
   - 如果dentry没人用, 把dentry变为negative的
   - 否则把它在hash队列中删除
   - 如果dentry->d_count ==1,变成一个negative的文件
   - 只有当前操作路径在使用?
   - 锁住d_lock, inode->i_lock, 这里会循环等待锁
   - 去掉dentry->d_flags的DCACHE_CANT_MOUNT??
   - 释放和inode的关系, 仅仅变成negative的
   - dentry_unlink_inode(dentry)
   - 否则, d_count会是多少??
   - 如果dentry在hash表中, 释放hash表关系 
   > d_unhashed(dentry)
   > __d_drop(dentry)

** __d_rehash(dentry, hlist_bl_head)
   - 设置dentry->d_flags的DCACHE_RCUACCESS, 重新把dentry放到hash队列中

** _d_rehash(dentry, hlist_bl_head)
   > __d_rehash(dentry)

** d_rehash(dentry)
   - 使用dentry->d_lock锁 
   > _d_rehash(dentry)

** __d_move(dentry, target) 
   - 交换两个dentry, 包括name,parent,subdir,hash. 
   - target虽然没有释放,但不在hash队列中
   - 只要回收函数一看，就立即释放它， 但另一个会进入hash队列

** d_move(dentry, target)
   - 使用rename_lock保护
   > __d_move(dentry, target)
   - 这就是rename的实现??

** d_ancestor(dentry p1, p2)
   - 使用dentry->d_parent向上遍历,检查p1是否是p2的上层目录

** __d_unalias(inode, dentry, alias)
   - 修改inode的文件名? 这里的锁非常复杂
   > __d_move(alias, dentry)


** __d_materialise_dentry(dentry, anon) 
   - 好像也是交换dentry和anon的内容,去掉anon的DCACHE_DISCONNECTED
   - 没有hash表的操作, 只有d_child/d_subdirs的操作

** d_materialise_unique(dentry, inode) 
   - 同样是关联dentry和inode
   - 如果inode是目录, 必须保证只有一个dentry
   - 查找是否存在dentry
   > __d_find_alias(inode, 0)
   - 如果是root,直接代替原来的, 而且需要调整hash表的位置
   > __d_materialise_dentry(dentry, alias)
   - 释放原来的dentry
   - __d_drop(dentry)
   - 如果是正常的dentry, 相当于rename操作?
   > __d_unalias(inode, dentry, alias) 
   - 如果找不到alias,或者是非目录,允许多个dentry?
   > __d_instantiate_unique(dentry, inode)
   - 最后调整hash队列
   > _d_rehash(dentry) 


** 总结
   dcache->flags的DCACHE_DISCONNECTED到底是什么时候使用??

* namei.c
  - dcache中树的查找,kernel提供两种,一种使用rcu/seqcount,另一种是refcount,第二种更安全一些,因为它在查找时增加dentry的计数.
nameidata :
	path 包含vfsmount, dentry
	qstr last
	path root 这个应该是task_struct中的
	inode   path->dentry->d_inode
	flags : 
		LOOKUP_FOLLOW(symlink)
		LOOKUP_DIRECTORY  找一个directory
		LOOKUP_AUTOMOUNT 不错在的目录?
		LOOKUP_PARENT ??
		LOOKUP_REVAL : 需要验证dcache中的目录信息
		LOOKUP_RCU ??
		LOOKUP_ROOT ??
		LOOKUP_OPEN  打开目录?
		LOOKUP_CREATE
		LOOKUP_EXCL
		LOOKUP_RENAME_TARGET ?? 
		LOOKUP_JUMPED 在绝对路径跳转时,设置这个标志
		LOOKUP_EMPTY
	last_type
	seq
	depth, saved_names
	open_intent: 
		- flags
		- create_mode
		- file

** unlazy_walk(nameidata, dentry)
	在rcu-wale中使用, nameidata->flags必须带有LOOKUP_RCU. 这个函数的作用是从lazy(rcu)-walk变为ref-walk. 但dentry和nameidata什么关系.
   - __d_rcu_to_refcount(dentry, seq) 比较seq和dentry->d_seq, 如果一样,增加dentry->d_count，否则返回失败.
	nameidata中的path是父目录,增加path.dentry->d_count,如果dentry不为空，增加它的计数. 
   - mntget(nd->path.mnt) 增加vfsmount的计数

** complete_walk(nameidata) 在rcu模式查找路径完成时的操作, 
   - __d_rcu_to_refcount(dentry, seq) 如果失败,退出
   - mntget(nameidata->path.mnt) 如果获取dentry的计数,也要增加它的计数
   - d_revalidate(dentry, nameidata) 在支持revalidate操作和link搜索时使用

** __vfs_follow_link(nameidata, link_name)
	如果link_name是绝对路径(以"/"开头), 则更换nameidata->path/root为current->fs->root,并设置LOOKUP_JUMPED
   - path_get(nd->path)
   - link_path_walk(link, nd)

	follow_link(path, nameidata, p) 处理符号文件, path应该是只想一个link文件,而nameidata是它的父目录?
   - dentry->d_inode->i_op->follow_link(dentry, nameidata) 获取dentry的链接内容.
   - __vfs_follow_link(nameidata, string) 没人管link

** follow_up_rcu(path) 使用rcu保护的路径向上走,这里要跨越mount,要是不跨越就直接parent
   - 如果path->mnt没有父mount,则返回0
   - 更换path = {path->mnt=>mnt_parent->mnt_mountpoint, path->mnt=>mnt_parent->mnt}

	follow_up(path) 使用refcount方式的向上路径
	和上面一样,但要释放老的paht,增加新path的计数
   - mntget / mntput 
   - dget / dput
** follow_automount(path, flags, need_mntput) 这个还不清除做什么
   - path->dentry->d_op->d_automount(path) 这个返回一个vfsmount
   - finish_automount(mnt, path) 实现挂载功能
   - path_put / dget 切换path

** follow_managed(path, flags) DCACHE_NEED_AUTOMOUNT, DCACHE_MANAGE_TRANSIT这两个标志都是autofs使用
   - d_op->d_manage(path->dentry, false) DCACHE_MANAGE_TRANSIT
   - follow_automount(path, flags, need_mntput) DCACHE_NEED_AUTOMOUNT
   - DCACHE_MOUNTED path是一个mountpoint,切换到mount的根,这里来看应该算是一个向下的搜索

	follow_down_one(path) 和上面DCACHE_MOUNTED一样

	__follow_mount_rcu(nameidata, path, inode) 这里还是和上面一样,但是没有nd的具体操作
		-> d_op->d_manage(path->dentry)
		-> d_mountpoint(path->dentry) 如果不是mountpoint,退出
		-> __lookup_mnt(path->mnt, dentry, 1) 切换path,但没有计数的修改,这是rcu操作

	follow_mount_rcu(nameidata) 切换nameidata->path, 这个只是简单的判断是否是挂载点. rcu操作需要不断的检查seq.

** follow_down(path)  这个函数和follow_managed类似,但这里不会处理DCACHE_NEED_AUTOMOUNT,nfsd使用它.

** d_alloc_and_lookup(dentry parent, qstr name, nameidata)
   - d_alloc(parent, name)
   - i_op->lookup(parent->d_inode, dentry, nd) 这里重新查找，里面有应该d_instantiate之类的复杂操作, 如果返回的有效,就需要释放它. cifs里面使用d_add，而且直接打开路径,但对于localfs,则需要读回目录下的内容.

	d_inode_lookup(dentry parent, dentry, nameidata) 在parent下面为dentry找合适的inode
   - i_op->lookup(inode, dentry, nd)

** do_lookup(nameidata, qstr, path, inode)
	如果nameidata->flags带LOOKU_RCU,使用rcu模式查找
		-> __d_lookup_rcu(parent, name, seq,inode) 这是dcache中的实现,查找parent下面的dentry, 如果找不到,跳到计数模式
		-> d_revalidate
		-> d_nned_lookup(dentry) 跳到计数模式	
		-> __follow_mount_rcu(nd, path, inode) 处理mountpoing或autofs的东西
	找到ref-walk -> unlazy_walk(nd, dentry)
	如果不是rcu模式	-> __d_lookup(parent, name) 这个也是dcache的实现
	如果没找到dentry, 则再找一遍,或分配一个新的
   - d_lookup(parent, name)
   - d_alloc_and_lookup(parent, name, nd)
   - d_inode_lookup(parent, dentry, nd) 找inode
   - follow_managed(path, nd->flags)

	walk_component(nameidata, path, qstr, type, follow)
   - do_lookup(nd, name, path, inode) 如果返回的inode无效,则搜索失败, 把返回的path,inode给nameidata

处理符号链接
	nested_symlink(path, nameidata) 循环使用下面的函数,知道错误退出?
   - follow_link(link, nd, cookie)
   - walk_component(nd, path, last_name, nd->last_type, LOOKUP_FOLLOW)  

	link_path_walk(name, nd)
   - 取出name中的路径片断  walk_component(nd, next, this, type, LOOKUP_FOLLOW)但判断剩下最后一点时,特殊处理
   - nsted_symlink(next, nd)
	把最后的一个片断给nameidata
下面是创建/删除,查找，好复杂...,但上面真是没什么东西,所以还要看下面的实现.
