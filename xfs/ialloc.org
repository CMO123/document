* xfs_ialloc.c

** xfs_alloc_arg
   - 分配xfs_dinode也像分配block一样?? 需要这么多参数??

   #+begin_src 
	struct xfs_trans *tp;		/* transaction pointer */
	struct xfs_mount *mp;		/* file system mount point */
	struct xfs_buf	*agbp;		/* buffer for a.g. freelist header */
	struct xfs_perag *pag;		/* per-ag struct for this agno */
	xfs_fsblock_t	fsbno;		/* file system block number */
	xfs_agnumber_t	agno;		/* allocation group number */
	xfs_agblock_t	agbno;		/* allocation group-relative block # */
	xfs_extlen_t	minlen;		/* minimum size of extent */
	xfs_extlen_t	maxlen;		/* maximum size of extent */
	xfs_extlen_t	mod;		/* mod value for extent size */
	xfs_extlen_t	prod;		/* prod value for extent size */
	xfs_extlen_t	minleft;	/* min blocks must be left after us */
	xfs_extlen_t	total;		/* total blocks needed in xaction */
	xfs_extlen_t	alignment;	/* align answer to multiple of this */
	xfs_extlen_t	minalignslop;	/* slop for minlen+alignment calcs */
	xfs_extlen_t	len;		/* output: actual size of extent */
	xfs_alloctype_t	type;		/* allocation type XFS_ALLOCTYPE_... */
	xfs_alloctype_t	otype;		/* original allocation type */
	char		wasdel;		/* set if allocation was prev delayed */
	char		wasfromfl;	/* set if allocation is from freelist */
	char		isfl;		/* set if is freelist blocks - !acctg */
	char		userdata;	/* set if this is user data */
	xfs_fsblock_t	firstblock;	/* io first block allocated */   
   #+end_src

** xfs_ialloc_cluster_alignment(xfs_alloc_arg)
   - 获取最小分配空间??
   - 如果xfs的版本要求对齐? 
   > xfs_sb_version_hasalign(xfs_alloc_arg->xfs_mount->xfs_sb)
   - 而且xfs_alloc_arg->xfs_mount->xfs_sb->sb_inoalignment > cluster size
   > XFS_INODE_CLUSTER_SIZE(xfs_alloc_arg->xfs_mount)
   - 使用xfs_sb->sb_inoalignment, 他在xfs_dsb中,表示inode chunk的开始地址对齐的标准??
   - 否则返回1

** xfs_lookup
   - 大于小于等于??

   #+begin_src 
	XFS_LOOKUP_EQi, XFS_LOOKUP_LEi, XFS_LOOKUP_GEi   
   #+end_src

** xfs_inobt_lookup(xfs_btree_cur, xfs_agino, xfs_lookup, stat)
   - 使用xfs_btree_cur查找btree, 目标节点指向xfs_agino
   - xfs_agino是inode在ag内部的id
   - 设置xfs_btree_cur->bc_rec->xfs_inobt_rec_incore->ir_startino = xfs_agino
   - 查找btree 
   > xfs_btree_lookup(xfs_btree_cur, xfs_lookup, stat)

** xfs_inobt_rec 
   #+begin_src 
	__be32		ir_startino;	/* starting inode number */
	__be32		ir_freecount;	/* count of free inodes (set bits) */
	__be64		ir_free;	/* free inode mask */   
   #+end_src

** xfs_inobt_rec_incore
   #+begin_src 
	xfs_agino_t	ir_startino;	/* starting inode number */
	__int32_t	ir_freecount;	/* count of free inodes (set bits) */
	xfs_inofree_t	ir_free;	/* free inode mask */   
   #+end_src

   - 这是inode的btree上的叶子节点中的value
   - 上面是磁盘中的格式,使用大端数据类型
   - 下面是内存中的格式

** xfs_btree_rec 
   #+begin_src 
	xfs_bmbt_rec_t		bmbt;
	xfs_bmdr_rec_t		bmbr;	/* bmbt root block */
	xfs_alloc_rec_t		alloc;
	xfs_inobt_rec_t		inobt;   
   #+end_src
   
   - generic btree record, 也就是btree中保存的value, 包括data extent?, free extent, inode cluster..
   - 这里只会使用到xfs_inobt_rec

** xfs_inobt_update(xfs_btree_cur, xfs_inobt_rec_incore)
   - 把xfs_inobt_rec_incore的数据给xfs_btree_cur指向的xfs_btree_rec
   - 构造一个临时的xfs_btree_rec, 使用inobt保存xfs_inobt_rec_incore的数据
   - 经过大小端转化
   - 然后更新到btree中?? btree直接操作block buf?  
   > xfs_btree_update(xfs_btree_cur, xfs_btree_rec

** xfs_inobt_get_rec(xfs_btree_cur, xfs_inobt_rec_incore, stat)
   - 获取xfs_btree_cur指向的xfs_btree_rec 
   > xfs_btree_get_rec(xfs_btree_cur, xfs_btree_rec, stat)
   - 数据转化大小端,给xfs_btree_rec_incore

** xfs_check_agi_freecount(xfs_btree_cur, xfs_agi)
   - xfs_btree_cur->bc_nlevels必须是1??? 必须指向最下层的内部节点?
   - 让xfs_btree_cur指向第一个叶子节点?? 
   > xfs_inobt_lookup(xfs_btree_cur, 0, XFS_LOOKUP_GE, &i)
   - 取出对应的xfs_inobt_rec_incore
   - 然后继续遍历 
   > xfs_btree_increment(xfs_btree_cur, 0, &i)
   - 累加xfs_inobt_rec_incore->ir_freecount, 它必须和xfs_agi->agi_freecount

** xfs_ialloc_inode_init(xfs_mount, xfs_trans, list_head, xfs_agnumber_t agno, xfs_agblock_t agbno, xfs_agblock_t length, gen)
   - 分配xfs_dinode使用的空间,初始化必要的成员变量
   - 空间是(agbno, length), 对于v3的xfs, ino根据agbno而定
   - 遍历时以cluster/fsb为单位
   - 如果xfs_sb->sb_blocksize > cluster size, 遍历次数nbufs是length, 每次遍历的大小是1, 包含的xfs_dinode数量是xfs_sb->sb_inopblock
   - 否则,遍历次数nbufs是length / cluser size, 每次遍历的大小blks_per_cluster是cluster size / xfs_sb->sb_blocksize, 需要转化为fsb, 包含的inode数量是blks_per_cluster * xfs_sb->sb_inopblock
   - log the initialisation?? 
   > xfs_icreate_log(xfs_trans, agno, agbno, XFS_IALLOC_INODES(xfs_mount), xfs_sb->sb_inodesize, length, gen)
   - 遍历所有的cluster
   - 首先获取对应的xfs_buf, 没有根据ino, 而是根据参数agbno 
   > XFS_AGB_TO_DADDR(xfs_mount, agno, agbno + (j * blks_per_cluster))
   - 使用xfs_trans读回数据??
   > xfs_trans_get_buf(xfs_trans, xfs_mount->m_ddev_targp, d, xfs_mount->m_bsize * blks_per_cluster, XBF_UNMAPPED)
   - 设置xfs_buf->b_ops = xfs_inode_buf_ops
   - 清空整个空间? 
   > xfs_buf_zero(xfs_buf, 0, BBTOB(xfs_buf->b_length))
   - 遍历里面的xfs_dinode
   > xfs_make_iptr(xfs_mount, xfs_buf, i)
   - 设置di_magic / di_version / di_gen / di_next_unlinked / uuid / di_ino, 还有crc
   - 根据version, xfs_trans的处理不一样??
   > xfs_trans_inode_alloc_buf(xfs_trans, xfs_buf)
   > xfs_trans_ordered_buf(xfs_trans, xfs_buf)
   > xfs_trans_log_buf(xfs_trans, xfs_buf, 0, BBTOB(xfs_buf->b_length)-1)
   - 如果没有xfs_trans, 就把xfs_buf放到参数的list_head中??

** xfs_ialloc_ag_alloc(xfs_trans, xfs_buf, alloc)
   - 在ag中分配xfs_dinode使用的空间
   - xfs_buf什么作用? 
   - 检查系统inode是否太多?
   > XFS_IALLOC_INODE(xfs_mount)
   - xfs_mount->m_ialloc_inos + xfs_sb->sb_icount > xfs_mount->m_maxicount
   - xfs_alloc_arg->minlen / maxlen 是空间大小?  xfs_mount->m_ialloc_blks
   > XFS_IALLOC_BLOCKS(xfs_mount)
   - 开始准备xfs_alloc_arg, 去申请空间
   - 如果xfs_agi->agi_newino不是NULLAGINO, 使用他作为分配的其实地址?
   - 计算空间位置, 是否超过AG边界 xfs_agi->agi_length
   > XFS_AGINO_TO_AGBNO(xfs_alloc_arg->mount, newino) + XFS_IALLOC_BLOCKS(xfs_mount)
   - 设置xfs_alloc_arg, 表示这个空间, 为何添加偏移??
   - fsbno = XFS_AGB_TO_FSB(xfs_mount, agno, agbno)
   - xfs_alloc_arg->type = XFS_ALLOCTYPE_THIS_BNO
   - 设置xfs_alloc_arg->minalignslop, 什么对齐??
   > xfs_ialloc_cluster_alignment(xfs_alloc_arg)
   > xfs_alloc_vextent(xfs_alloc_arg)
   - xfs_alloc_arg->fsbno表示分配的结果
   - 这里会分配3次,每次对应不同的策略,依次尝试,直到成功分配
   - 然后初始化对应的buf 
   > xfs_ialloc_inode_init(xfs_alloc_arg->xfs_mount, xfs_trans, NULL, agno, xfs_alloc_arg->agbno, xfs_alloc_arg->len, randome())
   - 增加xfs_agi的agi_count, agi_freecount
   - 增加xfs_perag->pagi_freecount
   - 设置xfs_agi->agi_newino, 下次分配使用
   - 把分配的空间插入到ialloc的btree中
   - 初始化xfs_btree_cur
   > xfs_inobt_init_cursor(xfs_alloc_arg->xfs_mount, xfs_trans, xfs_buf, agno)
   - 虽然分配一个cluster, 但还是分成多个chunk
   - 每个对应xfs_inobt_rec, 遍历这些chunk
   - 查找对应的btree, 确认没有重复的 
   > xfs_btree_lookup(xfs_btree_cur, XFS_LOOKUP_EQ, i)
   > xfs_btree_insert(xfs_btree_cur, i)
   - xfs_btree_cur中的数据却使用的xfs_inobt_rec_host
   - 最后释放xfs_btree_cur 
   > xfs_btree_del_cursor(xfs_btree_cur, XFS_BTREE_NOERROR)
   - 最后创建什么log?? 
   > xfs_ialloc_log_agi(xfs_trans, xfs_buf, XFS_AGI_COUNT|XFS_AGI_FREECOUNT|XFS_AGI_NEWINO)
   - 释放xfs_sb的变量,同样需要log记录这些修改.. 
   > xfs_trans_mod_sb(xfs_trans, XFS_TRANS_SB_ICOUNT, newlen)
   > xfs_trans_mod_sb(xfs_trans, XFS_TRANS_SB_IFREE, newlen)

** xfs_ialloc_next_ag(xfs_mount) 
   - 增加xfs_mount->m_agirotor, 如果达到xfs_mount->m_maxagi变为0

** xfs_ialloc_ag_select(xfs_trans, xfs_ino_t parent, mode, okalloc)
   - 找一个xfs_perag分配xfs_dinode使用的block
   - 遍历所有的xfs_perag
   - 如果是dir文件， 使用xfs_mount->m_agirotor 
   > xfs_ialloc_next_ag(xfs_mount)
   - 否则使用parent的xfs_perag 
   > XFS_INO_TO_AGNO(xfs_mount, parent)
   - 检查xfs_perag->pagi_inodeok ==0, 什么意思, 不能给inode使用??
   > xfs_ialloc_next_ag(xfs_mount)
   - 如果xfs_perag->pagei_init ==0, 先初始化什么?? 
   > xfs_ialloc_pagi_init(xfs_mount, xfs_trans, agno)
   - 如果xfs_perag->pagi_freecount > 0, 可以使用这个xfs_perag?
   - 如果okalloc ==0, 不会分配??
   - 下面要检查这个xfs_perag的空间足够,分配block ?
   - 如果xfs_perag->pagf_init ==0, 先去分配什么?
   > xfs_alloc_pagf_init(xfs_mount, xfs_trans, agno, flags)
   - 要分配的空间是cluster大小indeed ?
   > XFS_IALLOC_BLOCKS(xfs_mount)
   - 比较xfs_perag->pagf_freeblks > indeed, xfs_perag->pagf_longest > indeed

** xfs_ialloc_next_rec(xfs_btree_cur, xfs_inobt_rec_incore, done, left)
   - 移动xfs_btree_cur, 如果left>0, 减小,否则增加 
   > xfs_btree_decrement(xfs_btree_cur, 0, i)
   > xfs_btree_increment(xfs_btree_cur, 0, i)
   - 然后把btree中的记录放到参数中 
   > xfs_inobt_get_rec(xfs_btree_cur, xfs_inobt_rec_incore, i)

** xfs_ialloc_get_rec(xfs_btree_cur, xfs_agino_t, xfs_inobt_rec_incore, done)
   - 在btree中查找agino对应的xfs_inobt_rec_incore 
   > xfs_inobt_lookup(xfs_btree_cur, agino, XFS_LOOKUP_EQ, i)
   > xfs_inobt_get_rec(xfs_btree_cur, xfs_inobt_rec_incore, i)

** xfs_dialloc_ag(xfs_trans, xfs_buf, xfs_ino_t parent, xfs_ino_t inop)
   - 分配xfs_dinode??
   - xfs_buf中是agi, 也就是allocate group information
   - 准备xfs_btree_cur, 遍历inode btree
   - 如果parent为0, 使用xfs_agi->agi_newino开始查找
   - 验证btree中的空闲节点的个数??
   - xfs_check_agi_freecount(xfs_btree_cur, agi)
   - 如果parent所在的ag就是xfs_buf指向的ag, 查找一个parent接近的ion
   > xfs_inobt_lookup(xfs_btree_cur, pagino, XFS_LOOKUP_LE, i) 
   - 这样查找的是inode trunk
   > xfs_inobt_get_rec(xfs_btree_cur, xfs_inobt_rec_incore, i)
   - 如果xfs_inobt_rec_incore->ir_freecount > 0, 去分配inode
   - 否则需要查找2边的btree节点
   - 如果parent agino是xfs_perag->pagl_pagino, 而且xfs_perag->pagl_leftrec和xfs_perag->pagl_rightrec不是NULLAGINO
   - 这些是上次分配的记录,这次继续从那些点分配 
   > xfs_ialloc_get_rec(xfs_btree_cur, xfs_perag->pagl_leftrec, xfs_inobt_rec_incore, done)
   > xfs_ialloc_get_rec(xfs_btree_cur, xfs_perag->pagl_rightrec, xfs_inobt_rec_incore, done)
   - 否则遍历2边的xfs_btree_cur 
   > xfs_ialloc_next_rec(xfs_btree_cur, xfs_inobt_rec_incore, done, 1)
   - 在遍历时,选择近的inode trunk
   - 如果没有合适的xfs_inobt_rec_incore, 继续移动xfs_btree_cur, 直到查找10次
   - 如果上面查找结束前没有找到xfs_inobt_rec_incore, 从0开始遍历 
   > xfs_inobt_lookup(xfs_btree_cur, 0, XFS_LOOKUP_GE, i)
   - 遍历到最后,直到碰到一个xfs_inobt_rec_incore 
   > xfs_btree_increment(xfs_btree_cur, 0, i)
   - 如果找到xfs_inobt_rec_incore, 查找ir_free中空闲的一位, 标志表记
   - 写回xfs_inobt_rec_incore 
   > xfs_inobt_update(xfs_btree_cur, xfs_inobt_rec_incore)
   - 减小xfs_agi->agi_freecount, 而且记录这个修改 
   > xfs_ialloc_log_agi(xfs_trans, xfs_buf, XFS_AGI_FREECOUNT)
   - 减小xfs_perag->pagi_freecount
   - 修改xfs_trans中的计数 ?? 
   > xfs_trans_mod_sb(xfs_trans, XFS_TRANS_SB_IFREE, -1)
  
** xfs_dialloc(xfs_trans, xfs_ino_t parent, umode_t, okalloc, xfs_buf, xfs_ino_t)
   - 根据注释，这个函数回调用2次，第一次不会分配block给inode chunk
   - 如果xfs_buf不是空,直接去分配??
   - 否则xfs_buf是空, 只能去查找可用的inode chunk
   - 先查找一个xfs_agi 
   > xfs_ialloc_ag_select(xfs_trans, parent, umode_t, okalloc)
   - 检查inode使用的block达到上限 
   > xfs_mount->xfs_sb + XFS_IALLOC_INODES(xfs_mount) > xfs_mount->m_maxicount
   - 不能再分配block, okalloc = 0, noroom = 1
   - 如果上面没有找到, 为何还要重新查找?? 
   - 下面的处理应该和上面的查找类似
   > xfs_perag_get(xfs_mount, agno)
   - 如果xfs_perag->pagi_init ==0, 跳过处理下一个
   - 如果xfs_perag->pagi_freecount ==0, 而且okalloc ==0, 跳过,不允许分配block
   - 获取agi对应的xfs_buf  
   > xfs_ialloc_read_agi(xfs_mount, xfs_trans, agno, xfs_buf)
   - 如果xfs_perag->pagi_freecount >0, 使用这个agi, 调到最后分配xfs_dinode
   - 否则分配block 
   > xfs_ialloc_ag_alloc(xfs_trans, xfs_buf, ialloced)
   - 如果分配成功返回xfs_buf, 但回返ino为NULLFSINO, 还得调用一次
   - 否则释放xfs_buf, 继续查找 
   > xfs_trans_brelse(xfs_trans, xfs_buf)
   - 如果找到合适的xfs_agi, 分配xfs_dinode
   > xfs_dialloc_ag(xfs_trans, xfs_buf, parent, inop)
   - 如果要分配block, 就要调用2次,为了提交xfs_trans

** xfs_bmap_free_item 
   #+BEGIN_SRC 
	xfs_fsblock_t		xbfi_startblock;/* starting fs block number */
	xfs_extlen_t		xbfi_blockcount;/* number of blocks in extent */
	struct xfs_bmap_free_item *xbfi_next;	/* link to next entry */   
   #+END_SRC

** xfs_bmap_free 
   #+BEGIN_SRC 
	xfs_bmap_free_item_t	*xbf_first;	/* list of to-be-free extents */
	int			xbf_count;	/* count of items on list */
	int			xbf_low;	/* alloc in low mode */   
   #+END_SRC

** xfs_difree(xfs_trans, xfs_ino_t, xfs_bmap_free_t, delete, xfs_ino_t first_in)
   - 释放xfs_ino_t对应的xfs_dinode?
   - 解析agno, agino
   - 找到xfs_dinode所在的xfs_buf 
   > xfs_ialloc_read_agi(xfs_mount, xfs_trans, agno, xfs_buf)
   - 还有找到对应的xfs_inobt_rec 
   - 准备xfs_btree_cur 
   > xfs_inobt_init_cursor(xfs_mount, xfs_trans, xfs_buf, agno)
   - 检查freecount 
   > xfs_check_agi_freecount(xfs_btree_cur, xfs_agi)
   - 根据agino查找xfs_inobt_rec 
   > xfs_inobt_lookup(xfs_btree_cur, agino, XFS_LOOKUP_LE, i)
   - 获取xfs_inobt_rec_incore 
   > xfs_inobt_get_rec(xfs_btree_cur, xfs_inobt_rec_incore, i)
   - 修改ir_free / ir_freecount
   - 如果xfs_mount没有XFS_MOUNT_IKEEP, 而且xfs_inobt_rec_incore->ir_freecount达到最大值XFS_IALLOC_INODES, 可以释放这个xfs_buf?
   - 修改xfs_agi->agi_count / agi_freecount
   > xfs_ialloc_log_agi(xfs_trans, xfs_buf, XFS_AGI_COUNT | XFS_AGI_FREECOUNT)
   - 减小xfs_perag->pagi_freecount 
   > xfs_trans_mod_sb(xfs_trans, XFS_TRANS_SB_ICOUNT, -ilen)
   > xfs_trans_mod_sb(xfs_trans, XFS_TRANS_SB_IFREE, -ilen)
   - 释放xfs_inobt_rec 
   > xfs_btree_delete(xfs_btree_cur)
   - 释放xfs_buf 
   > xfs_bmap_add_free(XFS_AGB_TO_FSB(xfs_mount, agno, XFS_INO_TO_AGBNO(xfs_mount, xfs_inobt_rec->ir_startino)), XFS_IALLOC_BLOCKS(xfs_mount), xfs_bmap_free, xfs_mount)
   - 如果不需要释放,可能因为XFS_MOUNT_IKEEP, 或者xfs_inobt_rec还有使用的位 
   - 更新xfs_inobt_rec 
   > xfs_inobt_update(xfs_btree_cur, xfs_inobt_rec)
   - 更新其他计数
   - xfs_agi->agi_freecount , xfs_perag->pagi_freecount

** xfs_imap_lookup(xfs_mount, xfs_trans, xfs_agnumber_t, xfs_agino_t, xfs_agblock_t agbno, xfs_agblock_t chunk_agbno, xfs_agblock_t offset_agbno)
   - 根据xfs_agnumber_t读回xfs_agi使用的xfs_buf 
   > xfs_ialloc_read_agi(xfs_mount, xfs_trans, agno, xfs_buf)
   - 查找inode btree, 准备xfs_btree_cur 
   > xfs_inobt_init_cursor(xfs_mount, xfs_trans, xfs_buf, xfs_agnumber_t)
   - 根据xfs_agino_t查找xfs_inobt_rec_incore
   > xfs_inobt_lookup(xfs_btree_cur, xfs_agino_t, XFS_LOOKUP_LE, i)
   > xfs_inobt_get_rec(xfs_btree_cur, xfs_inobt_rec_incore, i)
   - 获取agi的xfs_buf是为了查找btree做准备?? 
   - 释放xfs_buf
   > xfs_trans_brelse(xfs_trans, xfs_buf)
   - 根据xfs_inobt_rec_incore, 获取chunk_agbno, 它是inode chunk使用的block的起始地址 
   > XFS_AGINO_TO_AGBNO(xfs_mount, xfs_inobt_rec_incore->ir_stateino)
   - 还有参数agbno对应它的偏移？？

** xfs_imap 
   #+BEGIN_SRC 
	xfs_daddr_t	im_blkno;	/* starting BB of inode chunk */
	ushort		im_len;		/* length in BBs of inode chunk */
	ushort		im_boffset;	/* inode offset in block in bytes */   
   #+END_SRC

** xfs_imap(xfs_mount, xfs_trans, xfs_ino_t, xfs_imap, flags)
   - 查找xfs_ino_t对应的xfs_dinode使用的xfs_imap
   - inode chunk和cluster什么关系??
   - 为什么不可以直接根据inode获取chunk对齐的第一个ino对应的xfs_buf? 然后根据偏移定位xfs_dinode?
   - 首先获取一个cluster包含的block个数  blks_per_cluster
   > XFS_INODE_CLUSTER_SIZE(xfs_mount) >> xfs_sb->sb_blocklog
   - 如果flags有FSX_IGET_UNTRUSTED, 什么意思?? 
   > xfs_imap_lookup(xfs_mount, xfs_trans, agno, agino, agbno, chunk_agbno, offset_agbno, flags)
   - 否则使用其他方法获取imap?
   - 如果cluster < xfs_sb->sb_blocksize
   > XFS_INODE_CLUSTER_SIZE(xfs_mount)
   - 可以直接计算出来, 一个inode cluster就是一个fsb, 即使它有多个inode chunk
   > im_blkno = XFS_AGB_TO_DADDR(xfs_mount, agno, agbno)
   > im_len = XFS_FSB_TO_BB(xfs_mount, 1)
   > im_boffset = XFS_INO_TO_OFFSET(xfs_mount, ino) << xfs_sb->sb_inodelog
   - 否则一个cluster使用多个block? 要尽量精确到某个block?
   - 如果chunk大小是对齐的? 可以定位这个chunk的位置, 它可以使用一个xfs_buf来访问?
   - offset_agbno = agbno & xfs_mount->m_inoalign_mask
   - chunk_agbno = agbno - offset_agbno
   - 否则还得查找btree 
   > xfs_imap_lookup(xfs_mount, xfs_trans, agno, agino, agbno, chunk_agbno, offset_agbno, flags)
   - 然后根据chunk的位置构造cluster地址? 一个chunk包含多个cluster? 
   - cluster_agbno = chunk_agbno + (offset_agbno / blks_per_cluster) * blks_per_cluster
   - offset = (agbno - cluster_agbno) * xfs_sb->sb_inopblock + XFS_INO_TO_OFFSET(xfs_mount, ino)
   - 偏移包括cluster内部偏移和block内部偏移
   - 然后根据cluster构造xfs_imap
   - im_blkno = XFS_AGB_TO_DADDR(xfs_mount, agno, cluster_agbno)
   - im_len = XFS_FSB_TO_BB(xfs_mount, blks_per_cluster)
   - im_boffset = offset << xfs_sb->sb_inodelog

** xfs_ialloc_compute_maxlevels(xfs_mount)
   - 先计算可能最多的xfs_inobt_rec, maxleafents
   - 根据xfs_mount->m_agino_log,m_agino_log应该根据ag的大小计算出来
   > 1<<XFS_INO_AGINO_BITS(xfs_mount) >> XFS_INODES_PER_CHUNK_LOG
   - xfs_mount->m_alloc_mnr[2]表示btree中节点最少的记录数?
   - 逐层计算所需要的最多的节点数 
   > maxblocks = maxleafents / minnoderecs
   > maxblocks = maxblocks / minnoderecs

** xfs_ialloc_log_agi(xfs_trans, xfs_buf, fields)
   - xfs_buf中是xfs_agi, 记录它特殊的成员修改
   - 包括migac,versionnum,agi_setno,agi_length, . 
   - 根据修改的域,计算返回
   > xfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS, first, last)
   > xfs_trans_buf_set_type(xfs_trans, xfs_buf, XFS_BLFL_AGI_BUF)
   > xfs_trans_log_buf(xfs_trans, xfs_buf, first, last)

** xfs_agi 
   #+BEGIN_SRC 
	/*
	 * Common allocation group header information
	 */
	__be32		agi_magicnum;	/* magic number == XFS_AGI_MAGIC */
	__be32		agi_versionnum;	/* header version == XFS_AGI_VERSION */
	__be32		agi_seqno;	/* sequence # starting from 0 */
	__be32		agi_length;	/* size in blocks of a.g. */
	/*
	 * Inode information
	 * Inodes are mapped by interpreting the inode number, so no
	 * mapping data is needed here.
	 */
	__be32		agi_count;	/* count of allocated inodes */
	__be32		agi_root;	/* root of inode btree */
	__be32		agi_level;	/* levels in inode btree */
	__be32		agi_freecount;	/* number of free inodes */

	__be32		agi_newino;	/* new inode just allocated */
	__be32		agi_dirino;	/* last directory inode chunk */
	/*
	 * Hash table of inodes which have been unlinked but are
	 * still being referenced.
	 */
	__be32		agi_unlinked[XFS_AGI_UNLINKED_BUCKETS];

	uuid_t		agi_uuid;	/* uuid of filesystem */
	__be32		agi_crc;	/* crc of agi sector */
	__be32		agi_pad32;
	__be64		agi_lsn;	/* last write sequence */

	/* structure must be padded to 64 bit alignment */   
   #+END_SRC

** xfs_agi_verify(xfs_buf)
   - xfs_buf中是xfs_agi, 验证数据有效性
   - 首先是version/crc/uuid
   > xfs_sb_version_hascrc(xfs_mount->xfs_sb)
   - uuid和xfs_sb->sb_uuid比较
   - 检查magic/version
   - 检查xfs_agi->agi_seqno和xfs_perag->pag_agno
   - 检查unlinked链表, 不能是0??
   > xfs_check_agi_unlinked(xfs_agi)

** xfs_agi_ready_verify(xfs_buf)
   > xfs_agi_verify(xfs_buf)

** xfs_agi_write_verify(xfs_buf)
   - 验证数据有效性
   > xfs_agi_verify(xfs_buf)
   - 如果有错误,返回EFSCORRUPTED? 
   > xfs_buf_ioerror(xfs_buf, EFSCORRUPTED)
   - 设置xfs_agi->agi_lsn = xfs_buf_log_item->xfs_lig_item->li_lsn??
   - 检查checksum 
   > xfs_update_cksum(xfs_buf->b_addr, BBTOB(xfs_buf->b_length), offsetof(xfs_agi, agi_crc)

** xfs_read_agi(xfs_mount, xfs_trans, xfs_agnumber_t, xfs_buf)
   - 读取xfs_agnumber_t对应的ag的xfs_agi 
   > xfs_trans_read_buf(xfs_mount, xfs_trans, xfs_mount->m_ddev_targp, XFS_AG_DADDR(xfs_mount, agno, XFS_AGI_DADDR(xfs_mount)), XFS_FSS_TO_BB(xfs_mount, 1), 0, xfs_buf, xfs_agi_buf_ops)
   - 设置XFS_AGI_REF? 
   > xfs_buf_set_ref(xfs_buf, XFS_AGI_REF)

** xfs_ialloc_read_agi(xfs_mount, xfs_trans, xfs_agnumber_t, xfs_buf)
   - 读取数据
   > xfs_read_agi(xfs_mount, xfs_trans, agno, xfs_buf)
   - 获取xfs_perag? 
   > xfs_perag_get(xfs_mount, agno)
   - 如果xfs_perag->pagi_init ==0, 初始化它?
   - 设置xfs_perag->pagi_freecount = xfs_agi->agi_freecount
   - apgi_count = xfs_agi->agi_count, pagi_init = 1, 算是一段缓存
   
** xfs_ialloc_pagi_init(xfs_mount, xfs_trans, xfs_agnumber_t)
   - 初始化xfs_agnumber_t对应的xfs_perag 
   > xfs_ialloc_read_agi(xfs_mount, xfs_trans, xfs_agnumber_t, xfs_buf)
   > xfs_trans_brelse(xfs_trans, xfs_buf)

* xfs_icache.c 

** xfs_inode_alloc 
   - 分配xfs_inode, 只制定ino 
   - 初始化inode
   > xfs_init_always(xfs_mount->super_block, inode)
   - 清空xfs_ifork, xfs_icdinode

** xfs_inode_free_callback(rcu_head)
   - 释放xfs_inode的内存 

** xfs_inode_free(xfs_inode)
   - 对于普通文件, reg/dir/link, 释放xfs_ifork 
   > xfs_idestroy_fork(xfs_inode, XFS_DATA_FORK)
   - 然后是attribute fork 
   > xfs_idestroy_fork(xfs_inode, XFS_ATTR_FORK)
   - 如果还关联xfs_inode_log_item, 释放它
   > xfs_inode_item_destroy(xfs_inode)
   - 设置xfs_inode->i_flags的XFS_IRECLAIM, 重置ino 
   > call_rcu(xfs_inode->inode->i_rcu, xfs_inode_free_callback)

** xfs_iget_cache_hit(xfs_perag, xfs_inode, xfs_ino, flags, lock_flags)
   - 验证cache的xfs_inode??
   - 放置rcu锁的漏洞??
   - 首先检查xfs_ino和xfs_inode->i_ino
   - 检查xfs_inode->i_flags的XFS_INEW|XFS_IRECLAIM, 这个inode已经释放
   - 如果xfs_inode->xfs_icdinode->di_mode是0, 而且参数flags没有XFS_IGET_CREATE?
   - 说明inode在释放中?? unlink ?
   - 如果xfs_inode->i_flags包含XFS_IRECLAIMABLE, 哪里设置??
   - 这时inode已经销毁, 设置xfs_inode->i_flags的XFS_IRECLAIM ??
   - 重新初始化inode 
   > inode_init_always(xfs_mount->super_block, inode)
   - 去掉xfs_inode->i_flags的XFS_IRECLAIM_RESET_FLAGS, 设置XFS_INEW
   - 从radix上释放关系?? 
   > __xfs_inode_clear_reclaim_tag(xfs_mount, xfs_perag, xfs_inode)
   - 设置xfs_inode->inode->i_state的I_NEW??
   - 如果没有XFS_IRECLAIMABLE标志, 说明什么?
   - 可以直接获取inode ?? 
   > igrab(inode)

** xfs_iget_cache_miss(xfs_mount, xfs_perag, xfs_trans, xfs_ino, xfs_inode, flags, lock_flags)
   - 先分配xfs_inode
   > xfs_inode_alloc(xfs_mount, ino)
   - 读取磁盘的xfs_dinode?
   > xfs_iread(xfs_mount, xfs_trans, xfs_inode, flags)
   - 如果xfs_inode->xfs_icdinode->di_mode是0, 而且flags没有XFS_IGET_CREATE, 返回ENOENT
   - 设置xfs_inode->flags的XFS_INEW 
   > xfs_iflags_set(xfs_inode, iflags)
   - 把它放到xfs_perag的radix中
   > radix_tree_insert(xfs_perag->pag_ici_root, agino, xfs_inode)

** xfs_iget(xfs_mount, xfs_trans, xfs_ino_t, flags, lock_flags, xfs_inode)
   - 根据xfs_ino_t查找xfs_inode
   - 现在cache中查找,它是radix树? 如果找到需要初始化inode
   - 如果cache中没有,去磁盘中查找
   - 先查找radix
   > xfs_perag_get(xfs_mount, XFS_INO_TO_AGNO(xfs_mount, ino))
   > radix_tree_lookup(xfs_perag->pag_ici_root, agino)
   - 如果找到,初始化inode
   > xfs_iget_cache_hit(xfs_perag, xfs_inode, ino, flags, lock_flags)
   - 否则读取磁盘的数据
   > xfs_iget_cache_miss(xfs_mount, xfs_perag, xfs_trans, ino, xfs_inode, flags, lock_flags)
   - 如果文件已经存在,而且inode是刚创建的, 设置inode
   - xfs_iflags_test(xfs_inode, XFS_INEW)
   - 有XFS_INEW标志,而且xfs_inode->xfs_icdinode->di_mode !=0
   > xfs_setup_inode(xfs_inode)
   - 这个文件肯定不是刚创建的!!

** xfs_inode_ag_walk_grab(xfs_inode)
   - inode查找磁盘时是批量处理的,减小radix查找和锁的次数?
   - 首先检查xfs_inode
   - xfs_inode->i_ino不能是0
   - xfs_inode->i_flags不能包含XFS_INEW|XFS_IRECLAIMABLE|XFS_IRECLAIM? 
   > __xfs_iflags_test(xfs_inode, XFS_INEW|XFS_IRECLAIMABLE|XFS_IRECLAIM)
   - 增加inode计数 ?? 
   > igrab(inode)
   
** xfs_inode_ag_walk(xfs_mount, xfs_perag, execute, flags, args, tag)
   - 遍历所有的inode? 执行execute函数
   > execute(xfs_inode, xfs_perag, flag, args)
   - tag用来过滤radix中的xfs_inode 
   - 遍历xsf_perag->pag_ici_root中的xfs_inode 
   > radix_tree_gang_lookup_tag(xfs_perag->pag_ici_root, xfs_inode, first_index, XFS_LOOKUP_BATCH, tag)
   - 每次处理32个, 处理之前增加inode计数
   > xfs_inode_ag_walk_grab(xfs_inode)
   - 然后执行回调函数
   > execute(xfs_inode, xfs_perag, flags, args)

** xfs_queue_eofblocks(xfs_mount)
   - xfs_mount->m_perag_tree是什么?
   - 如果它有标志XFS_ICI_EOFBLOCKS_TAG, 启动xfs_mount->m_eofblocks_work任务 
   > radix_tree_tagged(xfs_mount->m_perag_tree, XFS_ICI_EOFBLOCKS_TAG)
   > queue_delayed_work(xfs_mount->m_eofblocks_workqueue, xfs_mount->m_eofblocks_work, xfs_eofb_secs)
   - xfs_eofb_secs单位是秒
   - sec = 1000 msec = 1000*1000 usec

** xfs_inode_ag_iterator(xfs_mount, execute, args, flags)
   - 遍历xfs_mount的所有xfs_perag
   - 遍历xfs_perag的所有xfs_inode 
   > xfs_perag_get(xfs_mount, ag) 
   - tag是-1, flags是和args一块的
   > xfs_inode_ag_walk(xfs_mount, xfs_perag, execute, flags, args, -1)

** xfs_inode_ag_iterator_tag(xfs_mount, execute, flags, args, tag) 
   - 这里传递了tag
   > xfs_inode_ag_walk(xfs_mount, xfs_perag, execute, flags, args, tag)

** xfs_reclaim_work_queue(xfs_mount)
   - 如果系统中存在xfs_perag, 它需要回收inode?
   - 启动对应的xfs_mount->m_reclaim_work? 
   > radix_tree_tagged(xfs_mount->m_perag_tree, XFS_ICI_RECLAIM_TAG)
   > queue_delayed_work(xfs_mount->m_reclaim_workqueue, xfs_mount->m_reclaim_work, xfs_syncd_centisecs)

** xfs_reclaim_worker(work_struct)
   - 回收xfs_inode cache? 
   - work_struct是xfs_mount->m_reclaim_work
   > xfs_reclaim_inodes(xfs_mount, SYNC_TRYLOCK)
   - 然后检查是否还需要运行work_struct 
   > xfs_reclaim_work_queue(xfs_mount)

** __xfs_inode_set_reclaim_tag(xfs_perag, xfs_inode)
   - 设置xfs_perag->pag_ici_root中xfs_inode对应的标志XFS_ICI_RECLAIM_TAG
   > radix_tree_tag_set(xfs_perag->pag_ici_root, XFS_INO_TO_AGNO(xfs_mount, xfs_inode->i_ino), XFS_ICI_RECLAIM_TAG)
   - 如果xfs_perag->pag_ici_reclaimable ==0? 设置对应的xfs_mount的标志 
   - 使用一样的标志??
   > radix_tree_tag_set(xfs_mount->m_perag_tree, XFS_INO_TO_AGNO(xfs_mount, xfs_inode->i_ino), XFS_ICI_RECLAIM_TAG)
   - 启动work_struct 
   > xfs_reclaim_work_queue(xfs_mount)
   - 最后增加xfs_perag->pag_ici_reclaimable ?? 

** xfs_inode_set_reclaim_tag(xfs_inode)
   - 设置xfs_inode->i_flags的XFS_IRECLAIMABLE
   > __xfs_inode_set_reclaim_tag(xfs_perag, xfs_inode)
   > __xfs_iflags_set(xfs_inode, XFS_IRECLAIMABLE)

** __xfs_inode_clear_reclaim(xfs_perag, xfs_inode)
   - 操作的是xfs_perag
   - 减小xfs_perag->pag_ici_reclaimable
   - 如果减为0, 修改对应radix的标志
   > radix_tree_tag_clear(xfs_inode->xfs_mount->m_perag_tree, XFS_INO_TO_AGNO(xfs_inode->xfs_mount, xfs_inode->i_ino), XFS_ICI_RECLAIM_TAG)
   - 这个和上面是对应的,操作inode时使用 

** __xfs_inode_clear_reclaim_tag(xfs_mount, xfs_perag, xfs_inode)
   - 先修改xfs_perag的radix树 
   > radix_tree_tag_clear(xfs_perag->pag_ici_root, XFS_INO_TO_AGINO(xfs_mount, xfs_inode->i_ino), XFS_ICI_RECLAIM_TAG)
   > __xfs_inode_clear_reclaim(xfs_perag, xfs_inode)

** xfs_reclaim_inode_grab(xfs_inode, flags)
   - 这里应该是回收过程中设置的,而不是标记为可回收的reclaimable
   - 如果flags包含SYNC_TRYLOCK, 而且xfs_inode->i_flags有XFS_IFLOCK|XFS_IRECLAIM
   - 直接返回,因为锁不住??
   - 如果xfs_inode没有XFS_IRECLAIMABLE, 直接返回
   - 如果xfs_inode有XFS_IRECLAIM, 直接返回
   - 设置xfs_inode->flags的XFS_IRECLAIM 
   > __xfs_iflags_set(xfs_inode, XFS_IRECLAIM)
   - 这里没有grab操作??

** xfs_reclaim_inode(xfs_inode, xfs_perag, sync_mode)
   - 回收inode? 但inode的状态不确定? 需要检查xfs_inode的状态
   - 首先锁住inode 
   > xfs_ilock(xfs_inode, XFS_ILOCK_EXCL)
   - 检查flush lock 
   > xfs_iflock_nowait(xfs_inode)
   - 如果需要等待锁,而sync_mode没有SYNC_WAIT, 直接返回
   - 否则等待完成 
   > xfs_iflock(xfs_inode)
   - 如果inode是bad? 回收inode ?
   > is_bad_inode(xfs_inode->inode)
   - 如果inode在ail中? 需要等待log操作?
   > xfs_ipincount(xfs_inode)
   - 如果sync_mode没有SYNC_WAIT，直接返回
   - 否则等待pincount 
   > xfs_iunpin_wait(xfs_inode)
   - 如果inode是无效的? 已经删除? 直接去回收
   > xfs_iflags_test(xfs_inode, XFS_ISTALE)
   - 检查xfs_inode是否是dirty/clean, 表示有metadata需要写回
   > xfs_inode_clean(xfs_inode)
   - 如果是clean, 直接去回收
   - 然后开始flush, 如果sync_mode没有SYNC_WAIT，直接返回 
   > xfs_iflush(xfs_inode, xfs_buf)
   - 写回xfs_buf? 
   > xfs_bwrite(xfs_buf)
   - 通过flush lock等待写完?? 
   > xfs_iflock(xfs_inode)
   - 开始reclaim操作
   - 释放flush lock, XFS_ILOCK_EXCL锁? 是什么保证xfs_inode不会再被使用? XFS_ISTALE?
   - 释放radix索引 
   > radix_tree_delete(xfs_perag->pag_ici_root, XFS_INO_TO_AGINO(xfs_mount, xfs_inode->i_ino))
   - 去掉claim标志? 
   > __xfs_inode_clear_reclaim(xfs_perag, xfs_inode)
   - 再此锁住inode? 操作quota 
   > xfs_ilock(xfs_inode, XFS_ILOCK_EXCL)
   > xfs_qm_dqdetch(xfs_inode)
   - 最后释放xfs_inode 
   > xfs_inode_free(xfs_inode)

** xfs_reclaim_inodes_ag(xfs_mount, flags, nr_to_scan)
   - 遍历xfs_mount的所有xfs_perag, 还有所有的xfs_inode
   - 回收带有XFS_ICI_RECLAIM_TAG标志的inode
   > xfs_perag_get_tag(xfs_mount, ag, XFS_ICI_RECLAIM_TAG)
   > radix_tree_gang_lookup_tag(xfs_perag->pag_ici_root, xfs_inode, first_index, XFS_LOOKUP_BATCH, XFS_ICI_RECLAIM_TAG)
   - 检查xfs_inode的标志
   > xfs_reclaim_inode_grab(xfs_inode, flags)
   - 回收 
   > xfs_reclaim_inode(xfs_inode, xfs_perag, flags)
   - 上面遍历过程中,如果flags包含SYNC_WAIT,而且处理的xfs_inode不满足nr_to_scan,可能回遍历2遍
   - 第一遍如果锁不住xfs_perag不会等待, 第2遍回等待锁

** xfs_reclaim_inodes(xfs_mount, mode)
   > xfs_reclaim_inodes_ag(xfs_mount, mode, INT_MAX)

** xfs_reclaim_inodes_nr(xfs_mount, nr_to_scan)
   - 同步释放? 
   - 为何启动回收工作?
   > xfs_reclaim_work_queue(xfs_mount)
   - 写回log ? 
   > xfs_ail_push_all(xfs_mount->xfs_ail)
   - 回收xfs_inode 
   > xfs_reclaim_inodes_ag(xfs_mount, SYNC_TRYLOCK|SYNC_WAIT, nr_to_scan)

** xfs_reclaim_inodes_count(xfs_mount)
   - 累计可回收的xfs_inode的个数?
   - 遍历XFS_ICI_RECLAIM_TAG的xfs_perag 
   > xfs_perag_get_tag(xfs_mount, xfs_perag, XFS_ICI_RECLAIM_TAG)
   - 累加xfs_perag->pag_ici_reclaimable

** xfs_eofblocks
   - 和pre-allocate有关?

   #+BEGIN_SRC 
	__u32		eof_version;
	__u32		eof_flags;
	uid_t		eof_uid;
	gid_t		eof_gid;
	prid_t		eof_prid;
	__u32		pad32;
	__u64		eof_min_file_size;
	__u64		pad64[12];   
   #+END_SRC

** xfs_inode_match_id(xfs_inode, xfs_eofblocks)
   - 使用xfs_eofblocks过滤xfs_inode
   - 使用uid/gid/eof_prid信息过滤

** xfs_inode_free_eofblocks(xfs_inode, xfs_perag, flags, args)
   - args就是xfs_eofblocks
   - 先检查什么? 
   > xfs_can_free_eofblocks(xfs_inode, false)
   - 如果address_space_mapping中有PAGECACHE_TAG_DIRTY, 写回数据需要等待
   - 如果flags没有SYNC_WAIT, 直接返回
   - 使用args过滤xfs_inode，如果不满足之家返回
   > xfs_inode_match_id(xfs_inode, xfs_eofblocks)
   - 如果xfs_eofblocks->eof_flags包含XFS_EOF_FLAGS_MINFILESIZE, 而且文件大小太小,直接返回 
   > XFS_ISIZE(xfs_inode) < xfs_eofblocks->eof_min_file_size
   - 文件大小是inode->i_size
   - 回收eof blocks 
   > xfs_free_eofblocks(xfs_mount, xfs_inode, true)

** xfs_icache_free_eofblocks(xfs_mount, xfs_eofblocks)
   - 遍历xfs_inode, 回收什么? 
   - 如果xfs_eofblocks->eof_flags包含XFS_EOF_FLAGS_SYNC, 遍历使用SYNC_WAIT方式 
   > xfs_inode_ag_iterator_tag(xfs_mount, xfs_inode_free_eofblocks, flags, xfs_eofblocks, XFS_ICI_EOFBLOCKS_TAG)

** xfs_inode_set_eofblocks_tag(xfs_inode)
   - 设置XFS_ICI_EOFBLOCKS_TAG, 在pre-allocation中设置 
   - 获取xfs_perag 
   > xfs_perag_get(xfs_mount, XFS_INO_TO_AGNO(xfs_mount, xfs_inode->i_ino))
   - 设置xfs_inode对应的标志 
   > radix_tree_tag_set(xfs_perag->pag_ici_root, XFS_INO_TO_AGINO(xfs_mount, xfs_inode->i_ino), XFS_ICI_EOFBLOCKS_TAG)
   - 如果原来xfs_perag在xfs_mount的radix树中没有设置, 这里同样要设置 
   > radix_tree_tag_set(xfs_mount->m_perag_tree, XFS_INO_TO_AGNO(xfs_mount, xfs_inode->i_ino), XFS_ICI_EOFBLOCKS_TAG)
   
** xfs_inode_clear_eofblocks_tag(xfs_inode)
   - 先去掉xfs_inode对应的标志  
   > radix_tree_tag_clear(xfs_perag->pag_ici_root, XFS_INO_TO_AGINO(xfs_mount, xfs_inode->i_ino), XFS_ICI_EOFBLOCKS_TAG)
   - 如果xfs_perag->pag_ici_root中没有xfs_inode使用这个标志, 去掉xfs_perag对应的标志  
   > radix_tree_tag_clear(xfs_mount->m_perag_tree, XFS_INO_TO_AGNO(xfs_mount, xfs_inode->i_ino), XFS_ICI_EOFBLOCKS_TAG)
   - 这里只是修改标志, 不想上面reclaim那么复杂!!


* xfs_icreate_item.c
