* xfs_ialloc.c

** xfs_alloc_arg
   - 分配xfs_dinode也像分配block一样?? 需要这么多参数??

   #+begin_src 
	struct xfs_trans *tp;		/* transaction pointer */
	struct xfs_mount *mp;		/* file system mount point */
	struct xfs_buf	*agbp;		/* buffer for a.g. freelist header */
	struct xfs_perag *pag;		/* per-ag struct for this agno */
	xfs_fsblock_t	fsbno;		/* file system block number */
	xfs_agnumber_t	agno;		/* allocation group number */
	xfs_agblock_t	agbno;		/* allocation group-relative block # */
	xfs_extlen_t	minlen;		/* minimum size of extent */
	xfs_extlen_t	maxlen;		/* maximum size of extent */
	xfs_extlen_t	mod;		/* mod value for extent size */
	xfs_extlen_t	prod;		/* prod value for extent size */
	xfs_extlen_t	minleft;	/* min blocks must be left after us */
	xfs_extlen_t	total;		/* total blocks needed in xaction */
	xfs_extlen_t	alignment;	/* align answer to multiple of this */
	xfs_extlen_t	minalignslop;	/* slop for minlen+alignment calcs */
	xfs_extlen_t	len;		/* output: actual size of extent */
	xfs_alloctype_t	type;		/* allocation type XFS_ALLOCTYPE_... */
	xfs_alloctype_t	otype;		/* original allocation type */
	char		wasdel;		/* set if allocation was prev delayed */
	char		wasfromfl;	/* set if allocation is from freelist */
	char		isfl;		/* set if is freelist blocks - !acctg */
	char		userdata;	/* set if this is user data */
	xfs_fsblock_t	firstblock;	/* io first block allocated */   
   #+end_src

** xfs_ialloc_cluster_alignment(xfs_alloc_arg)
   - 获取最小分配空间??
   - 如果xfs的版本要求对齐? 
   > xfs_sb_version_hasalign(xfs_alloc_arg->xfs_mount->xfs_sb)
   - 而且xfs_alloc_arg->xfs_mount->xfs_sb->sb_inoalignment > cluster size
   > XFS_INODE_CLUSTER_SIZE(xfs_alloc_arg->xfs_mount)
   - 使用xfs_sb->sb_inoalignment, 他在xfs_dsb中,表示inode chunk的开始地址对齐的标准??
   - 否则返回1

** xfs_lookup
   - 大于小于等于??

   #+begin_src 
	XFS_LOOKUP_EQi, XFS_LOOKUP_LEi, XFS_LOOKUP_GEi   
   #+end_src

** xfs_inobt_lookup(xfs_btree_cur, xfs_agino, xfs_lookup, stat)
   - 使用xfs_btree_cur查找btree, 目标节点指向xfs_agino
   - xfs_agino是inode在ag内部的id
   - 设置xfs_btree_cur->bc_rec->xfs_inobt_rec_incore->ir_startino = xfs_agino
   - 查找btree 
   > xfs_btree_lookup(xfs_btree_cur, xfs_lookup, stat)

** xfs_inobt_rec 
   #+begin_src 
	__be32		ir_startino;	/* starting inode number */
	__be32		ir_freecount;	/* count of free inodes (set bits) */
	__be64		ir_free;	/* free inode mask */   
   #+end_src

** xfs_inobt_rec_incore
   #+begin_src 
	xfs_agino_t	ir_startino;	/* starting inode number */
	__int32_t	ir_freecount;	/* count of free inodes (set bits) */
	xfs_inofree_t	ir_free;	/* free inode mask */   
   #+end_src

   - 这是inode的btree上的叶子节点中的value
   - 上面是磁盘中的格式,使用大端数据类型
   - 下面是内存中的格式

** xfs_btree_rec 
   #+begin_src 
	xfs_bmbt_rec_t		bmbt;
	xfs_bmdr_rec_t		bmbr;	/* bmbt root block */
	xfs_alloc_rec_t		alloc;
	xfs_inobt_rec_t		inobt;   
   #+end_src
   
   - generic btree record, 也就是btree中保存的value, 包括data extent?, free extent, inode cluster..
   - 这里只会使用到xfs_inobt_rec

** xfs_inobt_update(xfs_btree_cur, xfs_inobt_rec_incore)
   - 把xfs_inobt_rec_incore的数据给xfs_btree_cur指向的xfs_btree_rec
   - 构造一个临时的xfs_btree_rec, 使用inobt保存xfs_inobt_rec_incore的数据
   - 经过大小端转化
   - 然后更新到btree中?? btree直接操作block buf?  
   > xfs_btree_update(xfs_btree_cur, xfs_btree_rec

** xfs_inobt_get_rec(xfs_btree_cur, xfs_inobt_rec_incore, stat)
   - 获取xfs_btree_cur指向的xfs_btree_rec 
   > xfs_btree_get_rec(xfs_btree_cur, xfs_btree_rec, stat)
   - 数据转化大小端,给xfs_btree_rec_incore

** xfs_check_agi_freecount(xfs_btree_cur, xfs_agi)
   - xfs_btree_cur->bc_nlevels必须是1??? 必须指向最下层的内部节点?
   - 让xfs_btree_cur指向第一个叶子节点?? 
   > xfs_inobt_lookup(xfs_btree_cur, 0, XFS_LOOKUP_GE, &i)
   - 取出对应的xfs_inobt_rec_incore
   - 然后继续遍历 
   > xfs_btree_increment(xfs_btree_cur, 0, &i)
   - 累加xfs_inobt_rec_incore->ir_freecount, 它必须和xfs_agi->agi_freecount

** xfs_ialloc_inode_init(xfs_mount, xfs_trans, list_head, xfs_agnumber_t agno, xfs_agblock_t agbno, xfs_agblock_t length, gen)
   - 分配xfs_dinode使用的空间,初始化必要的成员变量
   - 空间是(agbno, length), 对于v3的xfs, ino根据agbno而定
   - 遍历时以cluster/fsb为单位
   - 如果xfs_sb->sb_blocksize > cluster size, 遍历次数nbufs是length, 每次遍历的大小是1, 包含的xfs_dinode数量是xfs_sb->sb_inopblock
   - 否则,遍历次数nbufs是length / cluser size, 每次遍历的大小blks_per_cluster是cluster size / xfs_sb->sb_blocksize, 需要转化为fsb, 包含的inode数量是blks_per_cluster * xfs_sb->sb_inopblock
   - log the initialisation?? 
   > xfs_icreate_log(xfs_trans, agno, agbno, XFS_IALLOC_INODES(xfs_mount), xfs_sb->sb_inodesize, length, gen)
   - 遍历所有的cluster
   - 首先获取对应的xfs_buf, 没有根据ino, 而是根据参数agbno 
   > XFS_AGB_TO_DADDR(xfs_mount, agno, agbno + (j * blks_per_cluster))
   - 使用xfs_trans读回数据??
   > xfs_trans_get_buf(xfs_trans, xfs_mount->m_ddev_targp, d, xfs_mount->m_bsize * blks_per_cluster, XBF_UNMAPPED)
   - 设置xfs_buf->b_ops = xfs_inode_buf_ops
   - 清空整个空间? 
   > xfs_buf_zero(xfs_buf, 0, BBTOB(xfs_buf->b_length))
   - 遍历里面的xfs_dinode
   > xfs_make_iptr(xfs_mount, xfs_buf, i)
   - 设置di_magic / di_version / di_gen / di_next_unlinked / uuid / di_ino, 还有crc
   - 根据version, xfs_trans的处理不一样??
   > xfs_trans_inode_alloc_buf(xfs_trans, xfs_buf)
   > xfs_trans_ordered_buf(xfs_trans, xfs_buf)
   > xfs_trans_log_buf(xfs_trans, xfs_buf, 0, BBTOB(xfs_buf->b_length)-1)
   - 如果没有xfs_trans, 就把xfs_buf放到参数的list_head中??

** xfs_ialloc_ag_alloc(xfs_trans, xfs_buf, alloc)
   - 在ag中分配xfs_dinode使用的空间
   - xfs_buf什么作用? 
   - 检查系统inode是否太多?
   > XFS_IALLOC_INODE(xfs_mount)
   - xfs_mount->m_ialloc_inos + xfs_sb->sb_icount > xfs_mount->m_maxicount
   - xfs_alloc_arg->minlen / maxlen 是空间大小?  xfs_mount->m_ialloc_blks
   > XFS_IALLOC_BLOCKS(xfs_mount)
   - 开始准备xfs_alloc_arg, 去申请空间
   - 如果xfs_agi->agi_newino不是NULLAGINO, 使用他作为分配的其实地址?
   - 计算空间位置, 是否超过AG边界 xfs_agi->agi_length
   > XFS_AGINO_TO_AGBNO(xfs_alloc_arg->mount, newino) + XFS_IALLOC_BLOCKS(xfs_mount)
   - 设置xfs_alloc_arg, 表示这个空间, 为何添加偏移??
   - fsbno = XFS_AGB_TO_FSB(xfs_mount, agno, agbno)
   - xfs_alloc_arg->type = XFS_ALLOCTYPE_THIS_BNO
   - 设置xfs_alloc_arg->minalignslop, 什么对齐??
   > xfs_ialloc_cluster_alignment(xfs_alloc_arg)
   > xfs_alloc_vextent(xfs_alloc_arg)
   - xfs_alloc_arg->fsbno表示分配的结果
   - 这里会分配3次,每次对应不同的策略,依次尝试,直到成功分配
   - 然后初始化对应的buf 
   > xfs_ialloc_inode_init(xfs_alloc_arg->xfs_mount, xfs_trans, NULL, agno, xfs_alloc_arg->agbno, xfs_alloc_arg->len, randome())
   - 增加xfs_agi的agi_count, agi_freecount
   - 增加xfs_perag->pagi_freecount
   - 设置xfs_agi->agi_newino, 下次分配使用
   - 把分配的空间插入到ialloc的btree中
   - 初始化xfs_btree_cur
   > xfs_inobt_init_cursor(xfs_alloc_arg->xfs_mount, xfs_trans, xfs_buf, agno)
   - 虽然分配一个cluster, 但还是分成多个chunk
   - 每个对应xfs_inobt_rec, 遍历这些chunk
   - 查找对应的btree, 确认没有重复的 
   > xfs_btree_lookup(xfs_btree_cur, XFS_LOOKUP_EQ, i)
   > xfs_btree_insert(xfs_btree_cur, i)
   - xfs_btree_cur中的数据却使用的xfs_inobt_rec_host
   - 最后释放xfs_btree_cur 
   > xfs_btree_del_cursor(xfs_btree_cur, XFS_BTREE_NOERROR)
   - 最后创建什么log?? 
   > xfs_ialloc_log_agi(xfs_trans, xfs_buf, XFS_AGI_COUNT|XFS_AGI_FREECOUNT|XFS_AGI_NEWINO)
   - 释放xfs_sb的变量,同样需要log记录这些修改.. 
   > xfs_trans_mod_sb(xfs_trans, XFS_TRANS_SB_ICOUNT, newlen)
   > xfs_trans_mod_sb(xfs_trans, XFS_TRANS_SB_IFREE, newlen)

** xfs_ialloc_next_ag(xfs_mount) 
   - 增加xfs_mount->m_agirotor, 如果达到xfs_mount->m_maxagi变为0

** xfs_ialloc_ag_select(xfs_trans, xfs_ino_t parent, mode, okalloc)
   - 找一个xfs_perag分配xfs_dinode使用的block
   - 遍历所有的xfs_perag
   - 如果是dir文件， 使用xfs_mount->m_agirotor 
   > xfs_ialloc_next_ag(xfs_mount)
   - 否则使用parent的xfs_perag 
   > XFS_INO_TO_AGNO(xfs_mount, parent)
   - 检查xfs_perag->pagi_inodeok ==0, 什么意思, 不能给inode使用??
   > xfs_ialloc_next_ag(xfs_mount)
   - 如果xfs_perag->pagei_init ==0, 先初始化什么?? 
   > xfs_ialloc_pagi_init(xfs_mount, xfs_trans, agno)
   - 如果xfs_perag->pagi_freecount > 0, 可以使用这个xfs_perag?
   - 如果okalloc ==0, 不会分配??
   - 下面要检查这个xfs_perag的空间足够,分配block ?
   - 如果xfs_perag->pagf_init ==0, 先去分配什么?
   > xfs_alloc_pagf_init(xfs_mount, xfs_trans, agno, flags)
   - 要分配的空间是cluster大小indeed ?
   > XFS_IALLOC_BLOCKS(xfs_mount)
   - 比较xfs_perag->pagf_freeblks > indeed, xfs_perag->pagf_longest > indeed

** xfs_ialloc_next_rec(xfs_btree_cur, xfs_inobt_rec_incore, done, left)
   - 移动xfs_btree_cur, 如果left>0, 减小,否则增加 
   > xfs_btree_decrement(xfs_btree_cur, 0, i)
   > xfs_btree_increment(xfs_btree_cur, 0, i)
   - 然后把btree中的记录放到参数中 
   > xfs_inobt_get_rec(xfs_btree_cur, xfs_inobt_rec_incore, i)

** xfs_ialloc_get_rec(xfs_btree_cur, xfs_agino_t, xfs_inobt_rec_incore, done)
   - 在btree中查找agino对应的xfs_inobt_rec_incore 
   > xfs_inobt_lookup(xfs_btree_cur, agino, XFS_LOOKUP_EQ, i)
   > xfs_inobt_get_rec(xfs_btree_cur, xfs_inobt_rec_incore, i)

** xfs_dialloc_ag(xfs_trans, xfs_buf, xfs_ino_t parent, xfs_ino_t inop)
   - 分配xfs_dinode??
   - xfs_buf中是agi, 也就是allocate group information
   - 准备xfs_btree_cur, 遍历inode btree
   - 如果parent为0, 使用xfs_agi->agi_newino开始查找
   - 验证btree中的空闲节点的个数??
   - xfs_check_agi_freecount(xfs_btree_cur, agi)
   - 如果parent所在的ag就是xfs_buf指向的ag, 查找一个parent接近的ion
   > xfs_inobt_lookup(xfs_btree_cur, pagino, XFS_LOOKUP_LE, i) 
   - 这样查找的是inode trunk
   > xfs_inobt_get_rec(xfs_btree_cur, xfs_inobt_rec_incore, i)
   - 如果xfs_inobt_rec_incore->ir_freecount > 0, 去分配inode
   - 否则需要查找2边的btree节点
   - 如果parent agino是xfs_perag->pagl_pagino, 而且xfs_perag->pagl_leftrec和xfs_perag->pagl_rightrec不是NULLAGINO
   - 这些是上次分配的记录,这次继续从那些点分配 
   > xfs_ialloc_get_rec(xfs_btree_cur, xfs_perag->pagl_leftrec, xfs_inobt_rec_incore, done)
   > xfs_ialloc_get_rec(xfs_btree_cur, xfs_perag->pagl_rightrec, xfs_inobt_rec_incore, done)
   - 否则遍历2边的xfs_btree_cur 
   > xfs_ialloc_next_rec(xfs_btree_cur, xfs_inobt_rec_incore, done, 1)
   - 在遍历时,选择近的inode trunk
   - 如果没有合适的xfs_inobt_rec_incore, 继续移动xfs_btree_cur, 直到查找10次
   - 如果上面查找结束前没有找到xfs_inobt_rec_incore, 从0开始遍历 
   > xfs_inobt_lookup(xfs_btree_cur, 0, XFS_LOOKUP_GE, i)
   - 遍历到最后,直到碰到一个xfs_inobt_rec_incore 
   > xfs_btree_increment(xfs_btree_cur, 0, i)
   - 如果找到xfs_inobt_rec_incore, 查找ir_free中空闲的一位, 标志表记
   - 写回xfs_inobt_rec_incore 
   > xfs_inobt_update(xfs_btree_cur, xfs_inobt_rec_incore)
   - 减小xfs_agi->agi_freecount, 而且记录这个修改 
   > xfs_ialloc_log_agi(xfs_trans, xfs_buf, XFS_AGI_FREECOUNT)
   - 减小xfs_perag->pagi_freecount
   - 修改xfs_trans中的计数 ?? 
   > xfs_trans_mod_sb(xfs_trans, XFS_TRANS_SB_IFREE, -1)
  
** xfs_dialloc(xfs_trans, xfs_ino_t parent, umode_t, okalloc, xfs_buf, xfs_ino_t)
   - 根据注释，这个函数回调用2次，第一次不会分配block给inode chunk
   - 如果xfs_buf不是空,直接去分配??
   - 否则xfs_buf是空, 只能去查找可用的inode chunk
   - 先查找一个xfs_agi 
   > xfs_ialloc_ag_select(xfs_trans, parent, umode_t, okalloc)
   - 检查inode使用的block达到上限 
   > xfs_mount->xfs_sb + XFS_IALLOC_INODES(xfs_mount) > xfs_mount->m_maxicount
   - 不能再分配block, okalloc = 0, noroom = 1
   - 如果上面没有找到, 为何还要重新查找?? 
   - 下面的处理应该和上面的查找类似
   > xfs_perag_get(xfs_mount, agno)
   - 如果xfs_perag->pagi_init ==0, 跳过处理下一个
   - 如果xfs_perag->pagi_freecount ==0, 而且okalloc ==0, 跳过,不允许分配block
   - 获取agi对应的xfs_buf  
   > xfs_ialloc_read_agi(xfs_mount, xfs_trans, agno, xfs_buf)
   - 如果xfs_perag->pagi_freecount >0, 使用这个agi, 调到最后分配xfs_dinode
   - 否则分配block 
   > xfs_ialloc_ag_alloc(xfs_trans, xfs_buf, ialloced)
   - 如果分配成功返回xfs_buf, 但回返ino为NULLFSINO, 还得调用一次
   - 否则释放xfs_buf, 继续查找 
   > xfs_trans_brelse(xfs_trans, xfs_buf)
   - 如果找到合适的xfs_agi, 分配xfs_dinode
   > xfs_dialloc_ag(xfs_trans, xfs_buf, parent, inop)
   - 如果要分配block, 就要调用2次,为了提交xfs_trans

** xfs_bmap_free_item 
   #+BEGIN_SRC 
	xfs_fsblock_t		xbfi_startblock;/* starting fs block number */
	xfs_extlen_t		xbfi_blockcount;/* number of blocks in extent */
	struct xfs_bmap_free_item *xbfi_next;	/* link to next entry */   
   #+END_SRC

** xfs_bmap_free 
   #+BEGIN_SRC 
	xfs_bmap_free_item_t	*xbf_first;	/* list of to-be-free extents */
	int			xbf_count;	/* count of items on list */
	int			xbf_low;	/* alloc in low mode */   
   #+END_SRC

** xfs_difree(xfs_trans, xfs_ino_t, xfs_bmap_free_t, delete, xfs_ino_t first_in)
   - 释放xfs_ino_t对应的xfs_dinode?
   - 解析agno, agino
   - 找到xfs_dinode所在的xfs_buf 
   > xfs_ialloc_read_agi(xfs_mount, xfs_trans, agno, xfs_buf)
   - 还有找到对应的xfs_inobt_rec 
   - 准备xfs_btree_cur 
   > xfs_inobt_init_cursor(xfs_mount, xfs_trans, xfs_buf, agno)
   - 检查freecount 
   > xfs_check_agi_freecount(xfs_btree_cur, xfs_agi)
   - 根据agino查找xfs_inobt_rec 
   > xfs_inobt_lookup(xfs_btree_cur, agino, XFS_LOOKUP_LE, i)
   - 获取xfs_inobt_rec_incore 
   > xfs_inobt_get_rec(xfs_btree_cur, xfs_inobt_rec_incore, i)
   - 修改ir_free / ir_freecount
   - 如果xfs_mount没有XFS_MOUNT_IKEEP, 而且xfs_inobt_rec_incore->ir_freecount达到最大值XFS_IALLOC_INODES, 可以释放这个xfs_buf?
   - 修改xfs_agi->agi_count / agi_freecount
   > xfs_ialloc_log_agi(xfs_trans, xfs_buf, XFS_AGI_COUNT | XFS_AGI_FREECOUNT)
   - 减小xfs_perag->pagi_freecount 
   > xfs_trans_mod_sb(xfs_trans, XFS_TRANS_SB_ICOUNT, -ilen)
   > xfs_trans_mod_sb(xfs_trans, XFS_TRANS_SB_IFREE, -ilen)
   - 释放xfs_inobt_rec 
   > xfs_btree_delete(xfs_btree_cur)
   - 释放xfs_buf 
   > xfs_bmap_add_free(XFS_AGB_TO_FSB(xfs_mount, agno, XFS_INO_TO_AGBNO(xfs_mount, xfs_inobt_rec->ir_startino)), XFS_IALLOC_BLOCKS(xfs_mount), xfs_bmap_free, xfs_mount)
   - 如果不需要释放,可能因为XFS_MOUNT_IKEEP, 或者xfs_inobt_rec还有使用的位 
   - 更新xfs_inobt_rec 
   > xfs_inobt_update(xfs_btree_cur, xfs_inobt_rec)
   - 更新其他计数
   - xfs_agi->agi_freecount , xfs_perag->pagi_freecount

** xfs_imap_lookup(xfs_mount, xfs_trans, xfs_agnumber_t, xfs_agino_t, xfs_agblock_t agbno, xfs_agblock_t chunk_agbno, xfs_agblock_t offset_agbno)
   - 根据xfs_agnumber_t读回xfs_agi使用的xfs_buf 
   > xfs_ialloc_read_agi(xfs_mount, xfs_trans, agno, xfs_buf)
   - 查找inode btree, 准备xfs_btree_cur 
   > xfs_inobt_init_cursor(xfs_mount, xfs_trans, xfs_buf, xfs_agnumber_t)
   - 根据xfs_agino_t查找xfs_inobt_rec_incore
   > xfs_inobt_lookup(xfs_btree_cur, xfs_agino_t, XFS_LOOKUP_LE, i)
   > xfs_inobt_get_rec(xfs_btree_cur, xfs_inobt_rec_incore, i)
   - 获取agi的xfs_buf是为了查找btree做准备?? 
   - 释放xfs_buf
   > xfs_trans_brelse(xfs_trans, xfs_buf)
   - 根据xfs_inobt_rec_incore, 获取chunk_agbno, 它是inode chunk使用的block的起始地址 
   > XFS_AGINO_TO_AGBNO(xfs_mount, xfs_inobt_rec_incore->ir_stateino)
   - 还有参数agbno对应它的偏移？？

** xfs_imap 
   #+BEGIN_SRC 
	xfs_daddr_t	im_blkno;	/* starting BB of inode chunk */
	ushort		im_len;		/* length in BBs of inode chunk */
	ushort		im_boffset;	/* inode offset in block in bytes */   
   #+END_SRC

** xfs_imap(xfs_mount, xfs_trans, xfs_ino_t, xfs_imap, flags)
   - 查找xfs_ino_t对应的xfs_dinode使用的xfs_imap
   - inode chunk和cluster什么关系??
   - 为什么不可以直接根据inode获取chunk对齐的第一个ino对应的xfs_buf? 然后根据偏移定位xfs_dinode?
   - 首先获取一个cluster包含的block个数  blks_per_cluster
   > XFS_INODE_CLUSTER_SIZE(xfs_mount) >> xfs_sb->sb_blocklog
   - 如果flags有FSX_IGET_UNTRUSTED, 什么意思?? 
   > xfs_imap_lookup(xfs_mount, xfs_trans, agno, agino, agbno, chunk_agbno, offset_agbno, flags)
   - 否则使用其他方法获取imap?
   - 如果cluster < xfs_sb->sb_blocksize
   > XFS_INODE_CLUSTER_SIZE(xfs_mount)
   - 可以直接计算出来, 一个inode cluster就是一个fsb, 即使它有多个inode chunk
   > im_blkno = XFS_AGB_TO_DADDR(xfs_mount, agno, agbno)
   > im_len = XFS_FSB_TO_BB(xfs_mount, 1)
   > im_boffset = XFS_INO_TO_OFFSET(xfs_mount, ino) << xfs_sb->sb_inodelog
   - 否则一个cluster使用多个block? 要尽量精确到某个block?
   - 如果chunk大小是对齐的? 可以定位这个chunk的位置, 它可以使用一个xfs_buf来访问?
   - offset_agbno = agbno & xfs_mount->m_inoalign_mask
   - chunk_agbno = agbno - offset_agbno
   - 否则还得查找btree 
   > xfs_imap_lookup(xfs_mount, xfs_trans, agno, agino, agbno, chunk_agbno, offset_agbno, flags)
   - 然后根据chunk的位置构造cluster地址? 一个chunk包含多个cluster? 
   - cluster_agbno = chunk_agbno + (offset_agbno / blks_per_cluster) * blks_per_cluster
   - offset = (agbno - cluster_agbno) * xfs_sb->sb_inopblock + XFS_INO_TO_OFFSET(xfs_mount, ino)
   - 偏移包括cluster内部偏移和block内部偏移
   - 然后根据cluster构造xfs_imap
   - im_blkno = XFS_AGB_TO_DADDR(xfs_mount, agno, cluster_agbno)
   - im_len = XFS_FSB_TO_BB(xfs_mount, blks_per_cluster)
   - im_boffset = offset << xfs_sb->sb_inodelog

** xfs_ialloc_compute_maxlevels(xfs_mount)
   - 先计算可能最多的xfs_inobt_rec, maxleafents
   - 根据xfs_mount->m_agino_log,m_agino_log应该根据ag的大小计算出来
   > 1<<XFS_INO_AGINO_BITS(xfs_mount) >> XFS_INODES_PER_CHUNK_LOG
   - xfs_mount->m_alloc_mnr[2]表示btree中节点最少的记录数?
   - 逐层计算所需要的最多的节点数 
   > maxblocks = maxleafents / minnoderecs
   > maxblocks = maxblocks / minnoderecs

** xfs_ialloc_log_agi(xfs_trans, xfs_buf, fields)
   - xfs_buf中是xfs_agi, 记录它特殊的成员修改
   - 包括migac,versionnum,agi_setno,agi_length, . 
   - 根据修改的域,计算返回
   > xfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS, first, last)
   > xfs_trans_buf_set_type(xfs_trans, xfs_buf, XFS_BLFL_AGI_BUF)
   > xfs_trans_log_buf(xfs_trans, xfs_buf, first, last)

** xfs_agi 
   #+BEGIN_SRC 
	/*
	 * Common allocation group header information
	 */
	__be32		agi_magicnum;	/* magic number == XFS_AGI_MAGIC */
	__be32		agi_versionnum;	/* header version == XFS_AGI_VERSION */
	__be32		agi_seqno;	/* sequence # starting from 0 */
	__be32		agi_length;	/* size in blocks of a.g. */
	/*
	 * Inode information
	 * Inodes are mapped by interpreting the inode number, so no
	 * mapping data is needed here.
	 */
	__be32		agi_count;	/* count of allocated inodes */
	__be32		agi_root;	/* root of inode btree */
	__be32		agi_level;	/* levels in inode btree */
	__be32		agi_freecount;	/* number of free inodes */

	__be32		agi_newino;	/* new inode just allocated */
	__be32		agi_dirino;	/* last directory inode chunk */
	/*
	 * Hash table of inodes which have been unlinked but are
	 * still being referenced.
	 */
	__be32		agi_unlinked[XFS_AGI_UNLINKED_BUCKETS];

	uuid_t		agi_uuid;	/* uuid of filesystem */
	__be32		agi_crc;	/* crc of agi sector */
	__be32		agi_pad32;
	__be64		agi_lsn;	/* last write sequence */

	/* structure must be padded to 64 bit alignment */   
   #+END_SRC

** xfs_agi_verify(xfs_buf)
   - xfs_buf中是xfs_agi, 验证数据有效性
   - 首先是version/crc/uuid
   > xfs_sb_version_hascrc(xfs_mount->xfs_sb)
   - uuid和xfs_sb->sb_uuid比较
   - 检查magic/version
   - 检查xfs_agi->agi_seqno和xfs_perag->pag_agno
   - 检查unlinked链表, 不能是0??
   > xfs_check_agi_unlinked(xfs_agi)

** xfs_agi_ready_verify(xfs_buf)
   > xfs_agi_verify(xfs_buf)

** xfs_agi_write_verify(xfs_buf)
   - 验证数据有效性
   > xfs_agi_verify(xfs_buf)
   - 如果有错误,返回EFSCORRUPTED? 
   > xfs_buf_ioerror(xfs_buf, EFSCORRUPTED)
   - 设置xfs_agi->agi_lsn = xfs_buf_log_item->xfs_lig_item->li_lsn??
   - 检查checksum 
   > xfs_update_cksum(xfs_buf->b_addr, BBTOB(xfs_buf->b_length), offsetof(xfs_agi, agi_crc)

** xfs_read_agi(xfs_mount, xfs_trans, xfs_agnumber_t, xfs_buf)
   - 读取xfs_agnumber_t对应的ag的xfs_agi 
   > xfs_trans_read_buf(xfs_mount, xfs_trans, xfs_mount->m_ddev_targp, XFS_AG_DADDR(xfs_mount, agno, XFS_AGI_DADDR(xfs_mount)), XFS_FSS_TO_BB(xfs_mount, 1), 0, xfs_buf, xfs_agi_buf_ops)
   - 设置XFS_AGI_REF? 
   > xfs_buf_set_ref(xfs_buf, XFS_AGI_REF)

** xfs_ialloc_read_agi(xfs_mount, xfs_trans, xfs_agnumber_t, xfs_buf)
   - 读取数据
   > xfs_read_agi(xfs_mount, xfs_trans, agno, xfs_buf)
   - 获取xfs_perag? 
   > xfs_perag_get(xfs_mount, agno)
   - 如果xfs_perag->pagi_init ==0, 初始化它?
   - 设置xfs_perag->pagi_freecount = xfs_agi->agi_freecount
   - apgi_count = xfs_agi->agi_count, pagi_init = 1, 算是一段缓存
   
** xfs_ialloc_pagi_init(xfs_mount, xfs_trans, xfs_agnumber_t)
   - 初始化xfs_agnumber_t对应的xfs_perag 
   > xfs_ialloc_read_agi(xfs_mount, xfs_trans, xfs_agnumber_t, xfs_buf)
   > xfs_trans_brelse(xfs_trans, xfs_buf)
