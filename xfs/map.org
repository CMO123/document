* xfs_bmap.c

** xfs_ifork
   - 它保存inode的extent,在磁盘中有2中,一种是inline, 一种是btree. 
   - 在内存中有2中情况,如果是inline形式,就把所有数据复制进来,如果是btree,内核中没有btree这个数据结构, 它使用2维数组. 低维是一个page,高维是可扩展的. 希望extent不会太多.

** xfs_bmbt_rec 
   #+begin_src 
	__be64			l0, l1;
	// 这是磁盘中extent的存储. 标志16字节数据. state/start/count放一块.
   #+end_src

** xfs_bmbt_rec_host
   - 和上面一样, __be64变为__uint64_t

** xfs_ext_irec
   #+begin_src 
	xfs_bmbt_rec_host_t *er_extbuf;	/* block of extent records */
	xfs_extnum_t	er_extoff;	/* extent offset in file */
	xfs_extnum_t	er_extcount;	/* number of extents in page/block */
	- 第一个是数组,相当一个btree的节点,它指向一个btree的叶子.
   #+end_src

** xfs_bmap_free_item 
   #+begin_src 
	xfs_fsblock_t		xbfi_startblock;/* starting fs block number */
	xfs_extlen_t		xbfi_blockcount;/* number of blocks in extent */
	struct xfs_bmap_free_item *xbfi_next;	/* link to next entry */
	// 内存中的extent??
   #+end_src

** xfs_bmap_free
   #+begin_src 
	xfs_bmap_free_item_t	*xbf_first;	/* list of to-be-free extents */
	int			xbf_count;	/* count of items on list */
	int			xbf_low;	/* alloc in low mode */
	// xfs_count是xfs_first链表中的数量? 
	// xfs_low是最小的fsb??
	// 它记录一些要释放的extent
   #+end_src

** xfs_bmalloca
   #+begin_src 
	xfs_fsblock_t		*firstblock; /* i/o first block allocated */
	struct xfs_bmap_free	*flist;	/* bmap freelist */
	struct xfs_trans	*tp;	/* transaction pointer */
	struct xfs_inode	*ip;	/* incore inode pointer */
	struct xfs_bmbt_irec	prev;	/* extent before the new one */
	struct xfs_bmbt_irec	got;	/* extent after, or delayed */

	xfs_fileoff_t		offset;	/* offset in file filling in */
	xfs_extlen_t		length;	/* i/o length asked/allocated */
	xfs_fsblock_t		blkno;	/* starting block of new extent */

	struct xfs_btree_cur	*cur;	/* btree cursor */
	xfs_extnum_t		idx;	/* current extent index */
	int			nallocs;/* number of extents alloc'd */
	int			logflags;/* flags for transaction logging */

	xfs_extlen_t		total;	/* total blocks needed for xaction */
	xfs_extlen_t		minlen;	/* minimum allocation size (blocks) */
	xfs_extlen_t		minleft; /* amount must be left after alloc */
	char			eof;	/* set if allocating past last extent */
	char			wasdel;	/* replacing a delayed allocation */
	char			userdata;/* set if is user data */
	char			aeof;	/* allocated space at eof */
	char			conv;	/* overwriting unwritten extents */
	char			stack_switch;
	int			flags;
	struct completion	*done;
	struct work_struct	work;
	int			result;
	//分配一个extent需要这么多参数??
   #+end_src


** 总结
   - 在打开inode时只会读取一部分extent的数据,比如btree root. 这里需要把整个extent的信息放到xfs_ifork, 当然是放到现有的结构中. 从xfs_bmbt_rec -> xfs_bmbt_rec_host (xfs_ext_irec)  -> xfs_bmbt_irec
   - 搜索map使用xfs_ifork,但使用内存的数据结构.
   - 在写完后,修改extent map时,同时修改xfs_ifork和btree,而且可能会有extent在xfs_ifork中存在,但在btree中不存在. 而且会分解或合并.
   - 这里主要实现操作xfs_ifork的extent映射,但attr操作也可使用. attr如何组织数据?
   - 分配操作同时创建xfs_bmbt_irec,还会去操作btree,去分配或释放空间.
   - 实现read/write中设计到map的操作, delayed allocation等.

