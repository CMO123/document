* 数据结构
** xfs_buftarg
  #+begin_src 
  
typedef struct xfs_buftarg {
	dev_t			bt_dev;
	struct block_device	*bt_bdev;
	struct backing_dev_info	*bt_bdi;
	struct xfs_mount	*bt_mount;
	unsigned int		bt_bsize;
	unsigned int		bt_sshift;
	size_t			bt_smask;

	/* LRU control structures */
	struct shrinker		bt_shrinker;
	struct list_head	bt_lru;
	spinlock_t		bt_lru_lock;
	unsigned int		bt_lru_nr;
} xfs_buftarg_t;

  #+end_src
  - 这个数据结构管理磁盘,以及metadata使用的xfs_buf. 这里有shrink, 用来回收不怎么使用的空间.

** xfs_buf_map
  #+begin_src 

struct xfs_buf_map {
	xfs_daddr_t		bm_bn;	/* block number for I/O */
	int			bm_len;	/* size of I/O */
};
  
  #+end_src
  - extent的磁盘地址

** xfs_buf
  #+begin_src 

typedef struct xfs_buf {
	/*
	 * first cacheline holds all the fields needed for an uncontended cache
	 * hit to be fully processed. The semaphore straddles the cacheline
	 * boundary, but the counter and lock sits on the first cacheline,
	 * which is the only bit that is touched if we hit the semaphore
	 * fast-path on locking.
	 */
	struct rb_node		b_rbnode;	/* rbtree node */ //xfs_perag->pag_buf_tree
	xfs_daddr_t		b_bn;		/* block number of buffer */ //第一个xfs_buf_map->bm_bn
	int			b_length;	/* size of buffer in BBs */  //累加的xfs_buf_map->bm_len
	atomic_t		b_hold;		/* reference count */  //使用计数
	atomic_t		b_lru_ref;	/* lru reclaim ref count */
	xfs_buf_flags_t		b_flags;	/* status flags */
	struct semaphore	b_sema;		/* semaphore for lockables */

	/*
	 * concurrent access to b_lru and b_lru_flags are protected by
	 * bt_lru_lock and not by b_sema
	 */
	struct list_head	b_lru;		/* lru list */ //xfs_buftarg->bt_lru
	xfs_buf_flags_t		b_lru_flags;	/* internal lru status flags */
	wait_queue_head_t	b_waiters;	/* unpin waiters */
	struct list_head	b_list;
	struct xfs_perag	*b_pag;		/* contains rbtree root */
	xfs_buftarg_t		*b_target;	/* buffer target (device) */
	void			*b_addr;	/* virtual address of buffer */
	struct work_struct	b_iodone_work;    //在io完成时使用work_queue执行回调函数
	xfs_buf_iodone_t	b_iodone;	/* I/O completion function */
	struct completion	b_iowait;	/* queue for I/O waiters */ //等待bio
	void			*b_fspriv;
	struct xfs_trans	*b_transp;
	struct page		**b_pages;	/* array of page pointers */
	struct page		*b_page_array[XB_PAGES]; /* inline pages */
	struct xfs_buf_map	*b_maps;	/* compound buffer map */ //可能会有多个映射, 可以表示离散的磁盘空间
	struct xfs_buf_map	__b_map;	/* inline compound buffer map */
	int			b_map_count;     //使用的xfs_buf_map的数量
	int			b_io_length;	/* IO size in BBs */  //初始化时是b_length
	atomic_t		b_pin_count;	/* pin count */
	atomic_t		b_io_remaining;	/* #outstanding I/O requests */
	unsigned int		b_page_count;	/* size of page array */
	unsigned int		b_offset;	/* page offset in first page */
	unsigned short		b_error;	/* error code on I/O */
	const struct xfs_buf_ops	*b_ops;

#ifdef XFS_BUF_LOCK_TRACKING
	int			b_last_holder;   //pid,分配的时候设定.
#endif
} xfs_buf_t;

  #+end_src
  - 在内存中表示一个extent, 管理page/io/map
  - 使用xfs_buf->xfs_buf_map数组管理映射
  - xfs_buf->b_pages管理page数组
  - 如果xfs_buf->b_length < PAGE_CACHE_SIZE,给它slob的内存使用. 但它使用的内存不能跨越page边界, 虽然分配了slab内存,但还是把把内存指针转化为page指针和page偏移给xfs_buf->b_offset / b_pages / b_page_count, 这是_XBUF_KMEM
  - 否则分配page. xfs_buf_map->bm_bn是文件偏移,还是磁盘位置?? 应该是文件偏移! page来源于zone,而不是pagecache.
  - xfs_buf的page使用vmalloc的空间访问, xfs_buf->b_addr表示内存指针.
  - xfs_perag->pag_buf_tree使用rb tree管理所有的xfs_buf, 索引使用xfs_buf->b_bn
  - xfs_buf的创建可以使用xfs_buftarg/xfs_buf_map, 先根据xfs_buf_map创建xfs_buf, 然后给它申请内存,读取底层数据.
  - xfs_buf的创建还可以给定(addr,numblks), 应该是磁盘位置? 分配内存,然后设定磁盘位置.
  - xfs_buf还可能会使用分配好的内存,把虚拟地址映射回page,给xfs_buf->b_pages
  - 在xfs_buf.c中还实现了xfs_buf数据的IO,所以它用来操作metadata. 而映射的是磁盘偏移.
  - 它不像btrfs一样,使用文件管理整个磁盘空间,而是使用内存直接和磁盘交换数据.

** xfs_buf的bio回调函数
   - 在xfs_buf_ioapply_map中根据xfs_buf_map提交io请求,构造并发送bio, 设置bio->bi_end_io = xfs_buf_bio_end_io
   > xfs_buf_bio_end_io
   - 一个xfs_buf会提交多个bio, 但不会多个xfs_buf共用bio???
   - 一个xfs_buf_map对应一个bio, 使用xfs_buf->b_io_remaining表示提交个数
     
   > _xfs_buf_ioend
   - xfs_buf->b_io_remaining --, 如果变为0, 调用xfs_buf的回调xfs_buf_ioend
     
   > xfs_buf_ioend(xfs_buf, schedule)
   - schedule是否使用work_queue
   - 如果xfs_buf->b_error = 0, 设置xfs_buf->b_flags的XBF_DONE
   - 如果xfs_buf->b_iodone 或者 读并且xfs_buf->b_ops有效, 或者 xfs_buf->b_flags有XBF_ASYNC标志, 这里要使用xfs_buf_iodone_work, 说明有io完成后的处理.
   - 如果schedule ==1, 使用work_queue, 否则直接调用, 任务都是xfs_buf_iodone_work
   > queue_work(xfslogd_workqueue, xfs_buf->b_iodone_work)
   - 如果上面都无效, 使用简单的同步, 而且b_flags去掉XBF_READ/WRITE/READ_AHEAD??
   > complete(xfs_buf->b_iowait)

   > xfs_buf_iodone_work(work_struct)
   - 去掉b_flags标志XBF_READ/WRITE/READ_HEAD, 为何去掉??
   - 如果是read, 而且xfs_buf->b_ops有效, 而且b_flags有XBF_DONE
   > xfs_buf->b_ops->verify_read(xfs_buf)
   - 最后是同步操作, 这里完全不同
   - 如果b_iodone有效, 同步和释放操作在里面
   > (xfs_buf->b_iodone)(xfs_buf)
   - 如果xfs_buf->b_flags包含XBF_ASYNC, 仅仅释放xfs_buf, 这是异步的,而且没有等待
   > xfs_buf_relse(xfs_buf)
   - 否则唤醒xfs_buf->b_iowait
   > complete(xfs_buf->b_iowait)
** xfs_buf_flags

  #+begin_src 
#define XFS_BUF_FLAGS \
	{ XBF_READ,		"READ" }, \   //buffer用途, read
	{ XBF_WRITE,		"WRITE" }, \  //write
	{ XBF_READ_AHEAD,	"READ_AHEAD" }, \   //异步的readahead
	{ XBF_ASYNC,		"ASYNC" }, \    //异步操作
	{ XBF_DONE,		"DONE" }, \     //所有的page都是uptodate
	{ XBF_STALE,		"STALE" }, \    //buf没有用
	{ XBF_SYNCIO,		"SYNCIO" }, \   //同步IO
	{ XBF_FUA,		"FUA" }, \      //write throught模式? 直接写回去不缓冲?
	{ XBF_FLUSH,		"FLUSH" }, \    //write之前flush操作
	{ XBF_TRYLOCK,		"TRYLOCK" },	/* should never be set */\
	{ XBF_UNMAPPED,		"UNMAPPED" },	/* ditto */\
	{ _XBF_PAGES,		"PAGES" }, \    //使用page存储数据,在IO中使用,使用vmap映射访问
	{ _XBF_KMEM,		"KMEM" }, \     //使用help内存?
	{ _XBF_DELWRI_Q,	"DELWRI_Q" }, \ //延时写?  delay write?
	{ _XBF_COMPOUND,	"COMPOUND" }, \  //compound buffer
	{ _XBF_LRU_DISPOSE,	"LRU_DISPOSE" }  //discard操作
   
  #+end_src
  - xfs_buf->b_flags

* xfs_buf.c

** xfs_buf
   #+BEGIN_SRC 
	/*
	 * first cacheline holds all the fields needed for an uncontended cache
	 * hit to be fully processed. The semaphore straddles the cacheline
	 * boundary, but the counter and lock sits on the first cacheline,
	 * which is the only bit that is touched if we hit the semaphore
	 * fast-path on locking.
	 */
	struct rb_node		b_rbnode;	/* rbtree node */
	xfs_daddr_t		b_bn;		/* block number of buffer */
	int			b_length;	/* size of buffer in BBs */
	atomic_t		b_hold;		/* reference count */
	atomic_t		b_lru_ref;	/* lru reclaim ref count */
	xfs_buf_flags_t		b_flags;	/* status flags */
	struct semaphore	b_sema;		/* semaphore for lockables */

	/*
	 * concurrent access to b_lru and b_lru_flags are protected by
	 * bt_lru_lock and not by b_sema
	 */
	struct list_head	b_lru;		/* lru list */
	spinlock_t		b_lock;		/* internal state lock */
	unsigned int		b_state;	/* internal state flags */
	wait_queue_head_t	b_waiters;	/* unpin waiters */
	struct list_head	b_list;
	struct xfs_perag	*b_pag;		/* contains rbtree root */
	xfs_buftarg_t		*b_target;	/* buffer target (device) */
	void			*b_addr;	/* virtual address of buffer */
	struct work_struct	b_iodone_work;
	xfs_buf_iodone_t	b_iodone;	/* I/O completion function */
	struct completion	b_iowait;	/* queue for I/O waiters */
	void			*b_fspriv;
	struct xfs_trans	*b_transp;
	struct page		**b_pages;	/* array of page pointers */
	struct page		*b_page_array[XB_PAGES]; /* inline pages */
	struct xfs_buf_map	*b_maps;	/* compound buffer map */
	struct xfs_buf_map	__b_map;	/* inline compound buffer map */
	int			b_map_count;
	int			b_io_length;	/* IO size in BBs */
	atomic_t		b_pin_count;	/* pin count */
	atomic_t		b_io_remaining;	/* #outstanding I/O requests */
	unsigned int		b_page_count;	/* size of page array */
	unsigned int		b_offset;	/* page offset in first page */
	unsigned short		b_error;	/* error code on I/O */
	const struct xfs_buf_ops	*b_ops;

#ifdef XFS_BUF_LOCK_TRACKING
	int			b_last_holder;
#endif   
   #+END_SRC

** xf_buf_map 
   - 对应的磁盘映射信息, 下面磁盘位置是绝对地址??
   #+BEGIN_SRC 
	xfs_daddr_t		bm_bn;	/* block number for I/O */
	int			bm_len;	/* size of I/O */
   #+END_SRC

** xfs_buftarg 
   - 管理xfs_buf的磁盘信息, 在IO中使用的信息

   #+BEGIN_SRC 
	dev_t			bt_dev;
	struct block_device	*bt_bdev;
	struct backing_dev_info	*bt_bdi;
	struct xfs_mount	*bt_mount;
	unsigned int		bt_bsize;
	unsigned int		bt_sshift;
	size_t			bt_smask;

	/* LRU control structures */
	struct shrinker		bt_shrinker;
	struct list_lru		bt_lru;   
   #+END_SRC

** xfs_buf_flags_t 
   #+BEGIN_SRC 
	{ XBF_READ,		"READ" },
	{ XBF_WRITE,		"WRITE" }, 
	{ XBF_READ_AHEAD,	"READ_AHEAD" },
	{ XBF_ASYNC,		"ASYNC" },
	{ XBF_DONE,		"DONE" },
	{ XBF_STALE,		"STALE" }, 
	{ XBF_SYNCIO,		"SYNCIO" },
	{ XBF_FUA,		"FUA" },
	{ XBF_FLUSH,		"FLUSH" },
	{ XBF_TRYLOCK,		"TRYLOCK" },
	{ XBF_UNMAPPED,		"UNMAPPED" }, /* 如果使用多个page缓存数据, 不使用vmap建立地址影射*/
	{ _XBF_PAGES,		"PAGES" }, \ /*使用page保存数据, 需要给page建立影射,访问数据. 如果一个page, 可直接使用page的直接影射;如果多个page, 需要vmap影射为多个连续的地址,访问多个page. */
	{ _XBF_KMEM,		"KMEM" }, \  /*使用heap的内存保存数据, 而且使用它的地址访问, 可以反向得到page指针*/
	{ _XBF_DELWRI_Q,	"DELWRI_Q" }, /*在ail的iop_push操作中, 回收的xfs_buf设置这个标志*/
	{ _XBF_COMPOUND,	"COMPOUND" }
   #+END_SRC

** xfs_buf_is_vmapped(xfs_buf)
   - 对于使用多个page的xfs_buf, 空间比较大, 地址影射使用vma
   - 使用连续的地址空间访问全部的page
   - xfs_buf->b_addr !=NULL, 而且xfs_buf->b_page_count > 1

** xf_buf_vmap_len(xfs_buf)
   - 当xfs_buf使用vmap时,计算内存空间长度
   - b_offset应该是第一个page的偏移,开头一部分没有使用
   - xfs_buf->b_page_count * PAGE_SIZE  - xfs_buf->b_offset

** xfs_buf_stale(xfs_buf)
   - 设置xfs_buf->b_flags的XBF_STALE, 去掉_XBF_DELWRI_Q标志??
   - 设置xf_buf->b_lru_ref = 0
   - 如果xfs_buf->b_state没有XFS_BSTATE_DISPOSE, 表示它在lru队列中
   - 释放xfs_buf->b_lru链表, 他在xfs_buf->xfs_buftarg->bt_lru链表中
   - 如果xfs_buf在lru队列中, 减小xfs_buf->b_hold计数

** xfs_buf_get_maps(xfs_buf, map_count)
   - 准备xfs_buf的xfs_buf_map数组使用的内存
   - 设置xfs_buf->b_map_count = map_count
   - 如果是1, 让xfs_buf->b_maps指向xfs_buf->__b_map数组, 使用成员数组
   - 否则分配内存

** xfs_buf_free_maps(xf_buf)
   - 释放xfs_buf->b_maps的内存, xfs_buf_map数组
   - 需要检查它是否指向xfs_buf->__b_map

** _xfs_buf_alloc(xfs_buftarg, xfs_buf_map, nmaps, xfs_buf_flags_t)
   - 构造xfs_buf, 设置b_hold = 1, b_lru_ref = 1
   - 设置xfs_buf->b_last_holder 为当前pid
   - 设置参数xfs_buftarg
   - 设置xfs_buf_flags_t, 初始时需要去掉XBF_UNMAPPED | XBF_TRYLOCK | XBF_ASYNC | XBF_READ_AHEAD
   - 创建xfs_buf_map 
   > xfs_buf_get_maps(xfs_buf, nmaps)
   - 把参数xfs_buf_maps数组给xfs_buf->b_maps
   - 设置xfs_buf->b_length / b_io_length 为累加长度
   - 设置xfs_buf->b_bn 为第一个xfs_buf_map[0]->bm_bn, 第一个xfs_buf_map的位置
   
** _xfs_buf_get_pages(xfs_buf, page_count, xfs_buf_flags_t)
   - 分配xfs_buf->b_pages指针数组使用的内存
   - 设置xfs_buf->b_page_count = page_count
   - 如果page_count < XB_PAGES(2), 使用成员数组  xfs_buf->b_page_array
   - 否则分配内存保存page指针

** _xfs_buf_free_pages(xfs_buf)
   - 释放xfs_buf->b_pages的动态内存 

** xfs_buf_free(xfs_buf)
   - 释放xfs_buf, 以及它的资源, 内存影射,page或内存块, 指针数组

   - xfs_buf->b_lru不能在任何队列上
   - 如果xfs_buf->b_flags有_XBF_PAGES, 说明它使用page保存数据, 需要释放对应的影射和page
   - 如果使用vmap
   > xfs_buf_is_vmapped(xfs_buf)
   - 释放影射使用的资源
   > vm_unmap_ram(xfs_buf->b_addr - xfs_buf->b_offset, xfs_buf->b_page_count)
   - 释放分配的page
   > __free_page(page)
   - 否则如果xfs_buf->b_flags有_XBF_KMEM
   - 使用小的内存块保存数据, 直接释放
   > kmem_free(xfs_buf->b_addr)
   - 最后释放page指针数组和xfs_buf_map指针数组使用的内存
   > _xfs_buf_free_pages(xfs_buf)
   > xfs_buf_free_maps(xfs_buf)
   - 释放xfs_buf自己 

** xfs_buf_allocate_memory(xfs_buf, flags)
   - 为xfs_buf准备内存, 缓存磁盘中的数据

   - 如果length < PAGE_SIZE, 使用heap的内存 
   > kmem_alloc(size, KM_NOFS)
   - 把内存指针给xfs_buf->b_addr
   - 即使使用动态内存, 也还要获取对应的page指针, 还要保证这块内存不能跨page边界
   - 可能在IO底层使用DMA,所以保证物理地址连续
   - 直接比较 (b_addr + size ) & PAGE_MASK 和 b_addr & PAGE_MASK
   - 如果不满足要求,跳到后面,分配整个page
   - 设置b_addr针对page的偏移 
   > offset_in_page(xfs_buf->b_addr)
   - 获取对应的page指针,给xfs_buf->b_pages[0]
   > virt_to_page(xfs_buf->b_addr)
   - 设置xfs_buf->b_flags的XBF_KMEM

   - 如果length >= PAGE_SIZE, 或者上面分配的内存不满足要求, 分配page缓存数据
   - 需要的内存不限于xfs_buf->b_length, 需要对start和end对PAGE_CACHE对齐
   - 多分配了没事,使用xfs_buf->b_offset做偏移 
   - 先分配page指针数组
   > _xfs_buf_get_pages(xfs_buf, page_count, flags)
   - 设置xfs_buf->b_flags的_XBF_PAGES
   - 分配page内存, 但这里没有建立影射
   > alloc_page(gfp_mask)

** _xfs_buf_map_pages(xfs_buf, flags)
   - xfs_buf使用page缓存数据, 建立地址影射,设置xfs_buf->b_addr

   - xfs_buf->b_flags必须有_XBF_PAGES
   - 如果xfs_buf->b_page_count ==1, 直接获取对应的page的地址 
   > page_address(xfs_buf->b_pages[0]) + xfs_buf->b_offset 
   - 如果flags有XBF_UNMAPPED, 不需要建立地址映射
   - 直接设置xfs_buf->b_addr = NULL, 直接返回
   - 否则使用vmap
   > vm_map_ram(xfs_buf->b_pages, xfs_buf->b_page_count, -1, PAGE_KERNEL) 
   - 当然还得做偏移 xfs_buf->b_addr += xfs_buf->b_offset

** _xfs_buf_find(xfs_buftarg, xfs_buf_map, nmaps, xfs_buf_flags, xfs_buf new)
   - 检查xfs_buf_map的参数,磁盘位置blkno和长度len
   - blkno不能超过文件系统的容量xfs_sb->sb_dblocks
   - len必须大于xfs_buftarg->bt_sshift
   - 根据blkno计算agno, 获取对应的xfs_perag
   > xfs_perag_get(xfs_mount, xfs_daddr_to_agno(xfs_mount, blkno))
   - xfs_perag->pag_buf_tree里面管理所有的xfs_buf->b_rbnode, 使用磁盘位置排序xfs_buf->b_bn
   - 使用blkno查找, 如果已经存在一个, xfs_buf->b_length必须相同
   - 如果length不相同,这个xfs_buf必须是无效的, xfs_but->b_flags有XBF_STALE
   - 如果找不到,把新的xfs_buf插入到rbtree中, 如果找到返回它

** xfs_buf_get_map(xfs_buftarg, xfs_buf_map, nmaps, xfs_buf_flags_t)
   - 首先根据xfs_buf_map查找 
   > _xfs_buf_find(xfs_buftarg, xfs_buf_map, nmaps, xfs_buf_flags_t, NULL)
   - 如果找不到, 创建新的
   > _xfs_buf_alloc(xfs_buftarg, xfs_buf_map, nmaps, xfs_buf_flags_t)
   - 分配heap内存或者page 
   > xfs_buf_allocate_memory(xfs_buf, flags)
   - 重新查找或者插入到rbtree 
   > _xfs_buf_find(xfs_buftarg, xfs_buf_map, nmaps, flags, xfs_buf)
   - 如果上面使用page, 可能还没有建立page映射, xfs_buf->b_addr ==NULL
   > _xfs_buf_map_pages(xfs_buf, flags)
   
** _xfs_buf_read(xfs_buf, xfs_buf_flags_t flags)
   - xfs_buf->b_maps[0]->bm_bn必须是有效磁盘位置?? 为何不用xfs_buf->b_bn?  XFS_BUF_DADDR_NULL
   - 去掉xfs_b_flags的xfs_buf->b_flags, 去掉XBF_WRITE | XBF_ASYNC | XBF_READ_AHEAD
   - 添加 flags & (XBF_READ | XBF_ASYNC | XBF_READ_AHEAD ) ??
   - 几乎是重新设置为flags? 
   > xfs_buf_iorequest(xfs_buf)
   - 如果flags有XBF_ASYNC, 直接返回
   - 否则等待io完成 
   > xfs_buf_iowait(xfs_buf)

** xfs_buf_read_map(xfs_buftarg, xfs_buf_map, nmaps, xfs_buf_flags_t, xfs_buf_ops)
   - 根据xfs_buf_map构造xfs_buf 
   > xfs_buf_get_map(xfs_buftarg, xfs_buf_map, nmaps, xfs_buf_flags_t)
   - 检查io是否完成, xfs_buf之前已经存在??
   > XFS_BUF_ISDONE(xfs_buf) 
   - 如果没有完成IO, 设置xfs_buf->xfs_buf_ops, 启动读操作 
   > _xfs_buf_read(xfs_buf, flags)
   - 如果已经完成, 而且flags有XFS_ASYNC, 这是readahead??
   - 释放xfs_buf的锁,和使用计数
   > xfs_buf_relse(xfs_buf)
   - 如果不是异步, 去掉xfs_buf->b_flags的XBF_READ ??

** xfs_buf_readahead_map(xfs_buftarg, xfs_buf_map, nmaps, xfs_buf_ops)
   - 检查bdi的阻塞 
   > bdi_read_congested(xfs_buftarg->backing_dev_info
   - 预读xfs_buf 
   > xfs_buf_read_map(xfs_buftarg, xfs_buf_map, nmaps, XBF_TRYLOCK | XBF_ASYNC |XBF_READ_AHEAD, xfs_btree_ops)

** xfs_buf_read_uncached(xfs_buftarg, xfs_addr_t, numblks, flags, xfs_btree_ops)
   - 根据磁盘位置创建xfs_buf 
   > xfs_buf_get_uncached(xfs_buftarg, numblks, flags)
   - 这种情况只能包含一个xfs_buf_map, xfs_buf->b_map_count =1
   - 设置xfs_buf->b_bn = daddr, 设置xfs_buf->b_maps[0]->bm_bn = daddr
   - 设置xfs_buf->b_flags的XBF_READ, xfs_buf->xfs_buf_ops
   - 读取对应的磁盘数据?? 
   > xfsbdstrat(xfs_mount, xfs_buf)
   - 等待IO完成  
   > xfs_buf_iowait(xfs_buf)

** xfs_buf_set_empty(xfs_buf, numblks)
   - 清空xfs_buf使用的page
   > _xfs_buf_free_pages(xfs_buf)
   - 这里仅仅设置xfs_buf->b_length / b_io_length = numblks
   - 磁盘地址设为 xfs_buf->b_bn, 第一个xfs_bmap_map等都设为XFS_BUF_DADDR_NULL 

** mem_to_page(addr)
   - 检查addr是什么内存?? 获取对应的page指针
   - 如果是vmap映射的 
   > is_vmalloc_addr(addr)
   - vmalloc_to_page(addr)
   - 如果不是vmap, 就是直接映射??
   > virt_to_page(addr)

** xfs_buf_associated_memory(xfs_buf, mem, len)
   - 设置xfs_buf的内存地址, mem是已经分配的,可能包括多个page
   - 设置xfs_buf->b_offset为页内偏移  mem & (PAGE_SIZE - 1)
   - 根据 ( len + offset)计算page个数 
   - 分配page指针数组 
   > _xfs_buf_get_pages(xfs_buf, page_count, 0)
   - 设置mem使用的page指针  
   > mem_to_page(addr)
   - 设置xfs_buf->b_len / b_io_length = len
   - b_len的单位是BB (512)

** xfs_buf_get_uncached(xfs_buftarg, numblks, flags)
   - 构造临时的xfs_buf_map, 来创建xfs_buf
   - _xfs_buf_alloc(xfs_buftarg, xfs_buf_map, 1, 0)
   - 分配page 
   > _xfs_buf_get_pages(xfs_buf, page_count, 0)
   > alloc_page(xb_to_gfp(flags))
   - 设置xfs_buf->b_flags的_XBF_PAGES
   - 建立映射, 
   - 如果是单个page,使用直接映射
   - 如果多个page, 使用vmap, 分配一块连续的虚拟空间
   > _xfs_buf_map_pages(xfs_buf, flags)

** xfs_buf_hold(xfs_buf)
   - 增加xfs_buf->b_hold计数

** xf_buf_rele(xfs_buf)
   - 释放xfs_buf->b_hold计数, 使用xfs_perag->pag_buf_lock锁住 
   - 如果计数不为0, 直接返回
   - 如果为0, 开始释放xfs_buf
   - 如果xfs_buf不是stale, b_flags没有XBF_STALE
   - 而且xfs_buf->b_lru_ref > 0 ???
   - 缓存到lru队列中
   - 把xfs_buf->b_lru放到xfs_buf->xfs_buftarg->bt_lru中
   - 如果原来没有在lru队列中,需要去掉xfs_buf->b_state的XFS_BSTATE_DISPOSE??, 增加xfs_buf->b_hold计数
   - 否则直接释放xfs_buf, 或者他是stale, 或者lru为lru计数为1
   - 如果xfs_buf->b_state有XFS_BSTATE_DISPOSE, 表示它在lru队列中,释放链表
   - 释放rbroot关系  
   > xfs_buf_free(xfs_buf)

** xfs_buf_trylock(xfs_buf)
   - 锁住xfs_buf->b_sema
   - 如果锁住,更新xfs_buf->b_last_holder = current->pid 

** xfs_buf_lock(xfs_buf)
   - 如果xfs_buf->b_pin_count > 0, 而且xfs_buf->b_flags有XBF_STALE, 提交log? 
   > xfs_log_force(xfs_mount, 0)
   - 然后锁住xfs_buf->b_sema

** xfs_buf_unlock(xfs_buf)
   - 解锁xfs_buf->b_sema, 并把xfs_buf->b_last_holder改为-1

** xfs_buf_wait_unpin(xfs_buf)
   - 等待xfs_buf->b_pin_count?
   - 如果b_pin_count ==0, 直接返回
   - 否则在xfs_buf->b_waiters上睡眠

** xfs_buf_iodone_work(work_struct)
   - 使用work_struct同时IO完成??
   - 根据xfs_buf->b_flags计算IO方向, read/write
   - 去掉xfs_buf->b_flags的XBF_READ | XBF_WRITE | XBF_READ_AHEAD ??
   - 如果read, 而且xfs_buf->b_flags有XBF_DONE, 而且没有错误 xfs_buf->b_error ==0 
   > xfs_buf->xfs_buf_ops->verify_read(xfs_buf)
   - 如果xfs_buf->b_iodone !=0, 调用回调函数
   > xfs_buf->b_iodone(xfs_buf)
   - 否则没有设置回调函数, 如果xfs_buf是异步IO, xfs_buf->b_flags有XBF_ASYNC标志
   - 直接解锁并释放这个xfs_buf
   > xfs_buf_relse(xfs_buf)
   - 最后如果是同步IO, 唤醒xfs_buf->b_iowait
   > complete(xfs_buf->b_iowait)

** xfs_buf_ioend(xfs_buf, schedule)
   - 哪里使用的回调函数??
   - 如果xfs_buf->b_error ==0, 设置xfs_buf->b_flags的XBF_DONE
   - 如果xfs_buf->b_iodone有效, 或者read, 或者异步，必须调用IO完成函数
   - 如果schedule ==1, 使用work_queue完成 
   > queue_work(xfslogd_workqueue, xfs_buf->b_iodone_work)
   - 否则直接执行 
   > xfs_buf_iodone_work(xfs_buf->b_iodone_work)
   - 其他情况, IO没有完成,不是需要验证的读操作, 而且是同步的
   - 去掉xfs_buf->b_flags的XBF_READ | XBF_WRITE | XBF_READ_AHEAD
   - 唤醒等待的任务 
   > complete(xfs_buf->b_iowait)

** xfs_buf_ioerror(xfs_buf, error)
   - 设置xfs_buf->b_error = error

** xfs_buf_ioerror_alert(xfs_buf, func)
   - 输出提示信息?? 

** xfs_bioerror(xfs_buf)
   - IO错误处理??
   - 设置错误 
   > xfs_buf_ioerror(xfs_buf, EIO)
   - 去掉xfs_buf->b_flags的XBF_READ, XFS_DONE, 怎么知道这个read操作? 
   > xfs_buf_stale(xfs_buf)
   > xfs_buf_ioend(xfs_buf, 0)

** xfs_bioerror_relse(xfs_buf)
   - IO错误处理函数, 不是使用ioend, 而是直接释放xfs_buf
   - 去掉xfs_buf->b_flags的XBF_READ, 设置XBF_DONE 
   > xfs_buf_stale(xfs_buf)
   - 设置xfs_buf->b_iodone = NULL, 去过是同步的, 唤醒等待的任务
   > xfs_buf_ioerror(xfs_buf, EIO)
   > complete(xfs_buf->b_iowait)
   - 否则直接释放它 
   > xfs_buf_relse(xfs_buf)

** xfs_bdstrat_cb(xfs_buf)
   - 如果文件系统在关闭 
   > XFS_FORCED_SHUTDOWN(xfs_mount)
   - 直接调用错误处理
   - 如果没有回调xfs_buf->b_iodone == NULL, 而且不是同步读
   > xfs_bioerror_relse(xfs_buf)
   - 否则只设置错误?? 使用通用的ioend
   > xfs_bioerror(xfs_buf)
   - 如果没有问题, 提交bio? 
   > xfs_buf_iorequest(xfs_buf)

** xfs_bwrite(xfs_buf)
   - 设置xfs_buf->b_flags的XBF_WRITE, 去掉XBF_ASYNC | XBF_READ | _XBF_DELWRI_Q
   - 写都是异步的?? 
   > xfs_bdstrat_cb(xfs_buf)
   - 等待io 
   > xfs_buf_iowait(xfs_buf)

** xfsbdstrat(xfs_mount, xfs_buf)
   - 先检查xfs_mount 
   > XFS_FORCED_SHUTDOWN(xfs_mount)
   - 使用错误处理
   > xfs_bioerror_relse(xfs_buf)
   - 直接发送IO请求 
   > xfs_buf_iorequest(xfs_buf)
   
** _xfs_buf_ioend(xfs_buf, schedule)
   - 减小xfs_buf->b_io_remaining?  如果减为1, 调用结束函数 
   > xfs_buf_ioend(xfs_buf, schedule)

** xfs_buf_bio_end_io(bio, error)
   - bio的回调函数, bio->bi_private是xfs_buf
   - 如果xfs_buf->b_error ==0, 更新它
   > xfs_buf_ioerror(xfs_buf, -error)
   - 如果xfs_buf->b_error ==0, 而且使用vmap, 而且是read操作, 无效vmap?   
   - 空操作,难道是刷cache?
   > invalidate_kernel_vmap_range(addr, xfs_buf_vmap_len(xfs_buf))
   - 调用通知函数, 这里要求使用work_struct
   > _xfs_buf_ioend(xfs_buf, 1)
   > bio_put(bio)

** xfs_buf_ioapply_map(xfs_buf, map, buf_offset, count, rw)
   - 获取磁盘位置 xfs_buf->b_maps[map]->bm_bn 
   - buf_offset对应的page已经页内偏移
   - IO数据量是min(count, xfs_buf_map[map]->bm_len)
   - 增加xfs_buf->b_io_remaining
   - 构造bio, 这里准备的iovec长度不超过BIO_MAX_SECTORS(256pages)和xfs_buf->b_page_count
   > xfs_alloc(GFP_NOIO, nr_pages)
   - 设置bio的block_device, 磁盘位置bi_sector是上面xfs_buf_map的地址
   - 回调函数是xfs_buf_bio_end_io
   - bio->bi_private是xfs_buf 
   - 遍历xfs_buf里面的page 
   - 这里的offset和page_index根据上面的buf_offset计算
   > bio_add_page(bio, xfs_buf->b_pages[page_index], nbytes, offset)
   - 如果bio无法添加IO,先提交一个,然后创建新的bio
   - 提交bio 
   > submit_bio(rw, bio)

** _xfs_buf_ioapply(xfs_buf)
   - 根据xfs_buf的标志计算IO的方向
   - 如果xfs_buf->b_flags有XBF_WRITE, 写操作
   - 如果xfs_buf->b_flags有XBF_SYNCIO, rw是WRITE_SYNC, 否则是WRITE
   - 如果xfs_buf->b_flags有XBF_FUA, 设置rw的REQ_FUA
   - 如果xfs_buf->b_flags有XBF_FLUSH, 设置rw的REQ_FLUSH
   - 验证xfs_buf的数据  
   > xfs_buf->xfs_buf_ops->verify_write(xfs_buf)
   - 如果xfs_buf->b_flags有XBF_READ_AHEAD, 设置rw = READA 
   - 其他情况设置为rw = READ
   - 最后设置rw的REQ_META, 这里只会读取metadata?? 普通数据的IO??
   - 获取xfs_buf->b_offset / b_io_length, 提交bio 
   - 先停止块设备 
   > xfs_start_plug(plug)
   - 遍历xfs_buf->b_map_count, 每次提交一个xfs_buf_map的IO
   > xfs_buf_ioapply_map(xfs_buf, i, offset, size, rw)
   - xfs_finish_plug(plug)

** xfs_buf_iorequest(xfs_buf)
   - xfs_buf->b_flags不能有_XBF_DELWRI_Q ??
   - 如果xfs_buf->b_flags有XBF_WRITE, 等待pin?? 
   > xfs_buf_wait_unpin(xfs_buf)
   - 增加使用计数 
   > xfs_buf_hold(xfs_buf)
   - 设置xfs_buf->b_io_remaining = 1 
   - 提交bio 
   > _xfs_buf_ioapply(xfs_buf)
   - 为何这里还要释放??
   > _xfs_buf_ioend(xfs_buf, 1)
   - 释放xfs_buf的使用计数
   > xfs_buf_rele(xfs_buf)

** xfs_buf_iowait(xfs_buf)
   - 等待xfs_buf的IO完成  
   > wait_for_completion(xfs_buf->b_iowait)
   - 返回xfs_buf->b_error 

** xfs_buf_offset(xfs_buf, offset)
   - 获取xfs_buf中offset对应的内存地址
   - 如果xfs_buf->b_addr有效,已经建立内存映射, 返回xfs_buf->b_addr + offset
   - 否则返回page的直接映射地址, 首先计算page偏移 
   - ( offset + xfs_buf->b_offset ) / PAGE_SIZE
   - 然后计算page映射地址,做页内偏移

** xfs_buf_iomove(xfs_buf, boff, bsize, data, xfs_buf_rw_t mode)
   - 在参数data和xfs_buf之间移动数据
   - 对于xfs_buf, 完全使用page的直接映射访问
   - 根据boff定位xfs_buf中的内存page
   - 检查mode, 如果是XBRW_ZERO, 设置xfs_buf对应的空间为0
   - 如果是XBRW_READ, 从xfs_buf总复制数据
   - 如果是XBRW_WRITE, 把data写到xfs_buf中

** xfs_buftarg_wait_rele(list_head, lru_lock, arg)
   - 等待释放??
   - 第一个参数list_head是xfs_buf->b_lru, 最后一个参数是链表 list_head
   - 如果xfs_buf->b_hold > 1, 返回LRU_SKIP??
   - 否则释放lru链表关系
   - 设置xfs_buf->b_lru_ref = 0, 添加xfs_buf->b_state的XFS_BSTATE_DISPOSE
   - 把xfs_buf->b_lru放到arg链表中
   - 最后返回LRU_REMOVED

** xfs_wait_buftarg(xfs_buftarg)
   - 循环检查xfs_buftarg->bt_lru链表, 如果还有xfs_buf, 释放它?
   - 这里循环退出条件是这个链表个数? 为何不直接用空判断?
   > list_lru_count(xfs_buftarg->bt_lru)
   - 遍历链表,使用xfs_buftarg_wait_rele处理它 
   > list_lru_walk(xfs_buftarg->bt_lru, xfs_buftarg_wait_rele, list_head, LOGN_MAX)
   - 如果上面list_head中收集了xfs_buf, 释放他们  
   > xfs_buf_rele(xfs_buf)

** xfs_buftarg_isolate(list_head, lru_lock, arg)
   - 也是一个遍历的回调函数, 处理xfs_buf->b_lru_ref计数
   - 锁住xfs_buf, 如果锁不住,返回LRU_SKIP 
   > 减小xfs_buf->b_io_remaining， 如果已经是0,返回LRU_ROTATE?? 
   - 设置xfs_buf->b_state的XFS_BSTATE_DISPOSE, 放到arg链表中  
     
** xfs_buftarg_shrink_scan(shrinker, shrink_control)
   - 在xfs_buftarg->bt_lru上回收可以释放的xfs_buf 
   > list_lru_walk_node(xfs_buftarg->bt_lru, shrinker->nid, xfs_buftarg_isolate, dispose, nr_to_scan)
   - 释放他们
   > xfs_buf_rele(xfs_buf)
   - IO中的xfs_buf应该不会在lru中,应该只会回收内存

** xfs_buftarg_shrink_count(shrinker, shrink_count)
   - 计算可回收的xfs_buf的个数? 
   > list_lru_count_node(xfs_buf->bt_lru, shrink_control->nid)

** xfs_free_buftarg(xfs_mount, xfs_buftarg)
   - 释放xfs_buftarg
   - 注销xfs_buftarg->bt_shrinker
   - 如果xfs_mount->m_flags有XFS_MOUNT_BARRIAR?? 
   - 给磁盘发送flush操作
   > xfs_blkdev_issue_flush(xfs_buftarg)
   - 最后释放xfs_buftarg内存

** xfs_setsize_buftarg_flags(xfs_buftarg, blocksize, sectorsize, verbose)
   - 设置xfs_buftarg->bt_bsize = blocksize
   - bt_sshift = log(sectorsize), bt_smask是sectorsize的位掩码
   - 设置block_device->bd_block_size, 还有对应的blockfs的inode 
   > set_blocksize(xfs_buftarg->block_device, sectorsize)
   - 竟然可以在fs设置blockdevice

** xfs_setsize_buftarg_early(xfs_buftarg, block_device)
   - 在mount之前的操作??
   - 使用PAGE_SIZE作为blocksize, 磁盘默认的sectorsize?
   > xfs_setsize_buftarg_flags(xfs_buftarg, PAGE_SIZE, bdev_logical_block_size(block_device), 0)

** xfs_setsize_buftarg(xfs_buftarg, blocksize, sectorsize)
   > xfs_setsize_buftarg_flags(xfs_buftarg, blocksize, sectorsize, 1)

** xfs_alloc_buftarg(xfs_mount, block_device, external, fsname)
   - 构造xfs_buftarg, 在mount中使用
   - 设置xfs_mount / block_device
   - backing_dev_info使用block_device的 
   > blk_get_backing_dev_info(block_device)
   - 先设置默认的blocksize/sectorsize 
   > xfs_setsize_buftarg_early(xfs_buftarg, block_device)
   - 设置xfs_buftarg->shrink_control
   > register_shrinker(xfs_buftarg->bt_shrinker)

** xfs_buf_delwri_queue(xfs_buf, list_head)
   - 把xfs_buf放到delayed write队列中
   - 如果xfs_buf->b_flags有_XBF_DELWRI_Q, 它已经在队列中,返回false
   - 设置xfs_buf->b_flags的_XBF_DELWRI_Q, 而且把xfs_buf->b_list放到参数list_head中, 增加xfs_buf->b_hold计数

** xfs_buf_cmp(xfs_priv, list_head a, b)
   - list_head是xfs_buf->b_list, 比较2个xfs_buf
   - 根据xfs_buf->xfs_map_buf[0]->bm_bn

** __xfs_buf_delwri_submit(list_head buffer_list, io_list, wait)
   - 提交xfs_buf的写操作?
   - 遍历buffer_list里的xfs_buf->b_list
   - 如果wait ==0, 而且xfs_buf被别人使用? pin ?  跳过这个xfs_buf
   > xfs_buf_ispinned(xfs_buf)
   - 否则尝试锁住, 如果锁不住也跳过
   - 如果wait !=0, 锁住xfs_buf, 而且等待锁操作
   > xfs_buf_lock(xfs_buf)
   - 检查xfs_buf->b_flags的_XBF_DELWRI_Q? 其他人可能写回?? 
   - 释放链表, 释放这个xfs_buf 
   > xfs_buf_relse(xfs_buf)
   - 如果可以释放,把他们集中到io_list链表
   - 根据磁盘位置排序
   > list_sort(NULL, io_list, xfs_buf_map)
   > blk_start_plug(plug)
   - 遍历io_list里的xfs_buf, 去掉_XBF_DELWRI_Q | XBF_ASYNC
   - 设置XBF_WRITE
   - 根据wait设置XBF_ASYNC
   - 如果wait ==0, 还要删除xfs_buf->b_list队列
   - 如果wait !=0, 估计外面回等待这些IO 
   > xfs_bdstrat_cb(xfs_buf)
   > blk_finish_plug(plug)

** xfs_buf_delwri_submit_nowait(list_head)
   - 使用异步方式写回队列中的xfs_buf 
   > __xfs_buf_delwri_submit(buffer_list, io_list, false)
   - 这里的io_list没有用, wait ==0, 所以删除了链表

** xfs_buf_delwri_submit(list_head)
   - 同步写回一串的xfs_buf, 这里回把有IO的xfs_buf放到io_list中
   > __xfs_buf_delwri_submit(buffer_list, io_list, true)
   - 然后等待他们  
   > xfs_buf_iowait(xfs_buf)
   > xfs_buf_relse(xfs_buf)

** xfs_buf_init(void)
   - 构造xfs_buf使用的kmem_zone
   - 构造workqueue, 为异步的IO服务
   - IO回调函数可能在软中断中,不能在里面做验证或回调用户的程序, 所以在workqueue中完成
* xfs_bmap_btree.c
  - 操作文件extent影射 
    
** xfs_bmdr_block
   - bmap结点的头?? 为何不是xfs_btree_block?
   #+BEGIN_SRC 
	__be16		bb_level;	/* 0 is a leaf */
	__be16		bb_numrecs;	/* current # of data records */   
   #+END_SRC

** xfs_extent_state(xfs_filblks_t blks, extent_flag)
   - 如果extent_flag !=0, 返回XFS_EXT_UNWRITTEN
   - 否则返回XFS_EXT_NORM

** xfs_bmdr_to_bmbt(xfs_inode, xfs_bmdr_block, dblocklen, xfs_btree_block, rblocklen)
   - 把xfs_bmdr_block转化为xfs_btree_block 
   - xfs_btree_block的数据不会保存起来??
   - 检查xfs版本,是否支持crc, 设置xfs_btree_block->bc_flags
   > xfs_sb_version_hascrc(xfs_mount->xfs_sb)
   - 这里xfs_btree_block中的指针都是用64位? 
   > xfs_btree_init_block_int(xfs_mount, xfs_btree_block, XFS_BUF_DADDR_NULL, XFS_BMAP_CRC_MAGIC, 0, 0, xfs_inode->i_ino, XFS_BTREE_LONG_PTR|XFS_BTREE_CRC_BLOCKS) 
   - 设置level, numrecs
   - 复制xfs_btree_key数组, xfs_btree_ptr数组
   - 完全不会经过数据类型的大小端变换

** __xfs_bmbt_get_all(l0, l1, xfs_bmbt_irec)
   - (l0,l1)是xfs_bmbt_rec_host格式
   - 转化为xfs_bmbt_irec
   - 对于xfs_bmbt_irec->br_state, 只有2中
   - 如果l0中为0, 使用XFS_EXT_NORM, 否则使用XFS_EXT_UNWRITTEN

** xfs_bmbt_get_all(xfs_bmbt_rec_host r, xfs_bmbmt_irec)
   > __xfs_bmbt_get_all(r->l0, r->l1, xfs_bmbt_irec)

** xfs_bmbt_get_blockcount(xfs_bmbt_rec_host)
   - 获取其中的br_blockcount, 也就是l1的低21位.. 

** xfs_bmbt_get_startblock(xfs_bmbt_rec_host)
   - 获取其中的br_startblock

** xfs_bmbt_get_startoff(xfs_bmbt_rec_host)
   - 获取startoff 

** xfs_bmbt_get_state(xfs_bmbt_rec_host)
   - 获取state 

** xfs_bmbt_disk_get_blockcount(xfs_bmbt_rec) 
   - 处理的是磁盘数据类型,大端的 

** xfs_bmbt_disk_get_startoff(xfs_bmbt_rec)
** xfs_bmbt_set_allf(xfs_bmbt_rec_host, xfs_fileoff_t startoff, xfs_fsblock_t startblock, xfs_filblks_t blockcount, xfs_extst_t state)
   - state只能是XFS_EXT_NORM或XFS_EXT_UNWRITTEN
   - 然后使用位偏移, 计算对应l0, l1

** xfs_bmbt_set_all(xfs_bmbt_rec_host, xfs_bmbt_irec)
   > xfs_bmbt_set_allf(..)

** xfs_bmbt_disk_set_allf(xfs_bmbt_rec, ..)
   - 位操作之后,转化为大端数据类型

** xfs_bmbt_disk_set_all(xfs_bmbt_rec, xfs_bmbt_irec)
   > xfs_bmbt_disk_set_allf(...)

** xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, xfs_filblks_t )
** xfs_bmbt_set_startblock(xfs_bmbt_rec_host, xfs_fsblock_t v)
   - 磁盘位置一直使用xfs_fsblock_t, 应该是包括agno,agbno

** xfs_bmbt_set_startoff(xfs_bmbt_rec_host, xfs_fileoff_t)

** xfs_bmbt_set_state(xfs_bmbt_rec_host, xfs_exntst_t)

** xfs_bmbt_to_bmdr(xfs_mount, xfs_btree_block, rblocklen, xfs_bmdr_block, dblocklen)
   - 把xfs_btree_block的数据填充到xfs_bmdr_block
   - 如果xfs_bmdr_block的信息量比xfs_btree_block少, xfs_btree_block的xfs_buf是怎么来的？它使用的不是磁盘的缓存?? 还是专门的内存??
   - 只会处理level, numrecs
   - 然后把xfs_btree_key/xfs_btree_ptr复制过去

** xfs_check_nostate_extents(xfs_ifork, xfs_extnum_t idx, xfs_extnum_t num)
   - 遍历xfs_ifork的(idx,num)范围内的xfs_bmbt_rec_host
   - 获取对应的xfs_bmbt_rec_host 
   > xfs_iext_get_ext(xfs_ifork, idx)
   - 检查里面的state, 必须全部为0??

** xfs_bmbt_dup_cursor(xfs_btree_cur)
   - 复制一个xfs_btree_cur?
   - 构造一个新的 
   > xfs_bmbt_init_cursor(xfs_mount, xfs_trans, xfs_btree_cur->bc_private->b->xfs_inode, whichfork)
   - 复制xfs_btree_cur->bc_private->b的所有成员

** xfs_bmbt_update_cursor(xfs_btree_cur src, xfs_btree_cur dst)
   - 根据src更新dst
   - dst的firstblock != NULLFSBLOCK?? 而且2个使用的xfs_bmap_free相同??
   - 把src的allocated加到dst中,而且设置src的为0
   - 设置dst的firstblock为src的

** xfs_bmbt_alloc_block(xfs_btree_cur, xfs_btree_ptr start, xfs_btree_ptr new, length, stat)
   - 构造xfs_alloc_arg, 设置xfs_mount /xfs_trans
   - 参数length没有使用
   - 使用xfs_btree_cur->bc_private->b->firstblock作为提示信息,设置xfs_alloc_arg->fsbno
   - 设置xfs_alloc_arg->firstblock = xfs_alloc_arg->fsbno
   - 如果xfs_alloc_arg->fsbno == NULLFSBLOCK,
   - 使用参数start作为提示信息??
   - 分配类新选择XFS_ALLOCTYPE_START_BNO
   - 计算xfs_alloc_arg->minleft? 
   > xfs_trans_et_block_res(xfs_trans)
   - 如果上面不是NULLFSBLOCK,可以使用, 而且xfs_btree_cur的xfs_bmap_free->xbf_low !=0??
   - 使用分配方式为XFS_ALLOCTYPE_START_BNO
   - 其它条件使用XFS_ALLOCTYPE_NEAR_BNO
   - 设置xfs_alloc_arg->minlen / maxlen / prod = 1
   - wasdel根据xfs_btree_cur的bc_flags的XFS_BTCUR_BPRV_WASDEL??
   - 如果wasdel ==0, 而且没有空闲空间?? 返回ENOSPC？？
   > xfs_trans_get_block_res(xfs_trans)
   - 分配空间 
   > xfs_alloc_vextent(xfs_alloc_arg)
   - 如果分配失败,而且设定了xfs_alloc_arg->minleft? 换一种分配方式 
   - 使用XFS_ALLOCTYPE_FIRST_AG
   - 分配成功后更新xfs_btree_cur-bc_private
   - 设置firstblock = xfs_alloc_arg->fsbno, allocated ++
   - 增加xfs_inode->xfs_icdinode->di_nblocks
   - 还要log这个修改!! 
   > xfs_trans_log_inode(xfs_trans, xfs_inode, XFS_ILOG_CORE)
   - 把地址给xfs_btree_ptr, 返回stat =1

** xfs_btree_free_block(xfs_btree_cur, xfs_buf)
   - 把xfs_buf的地址添加到xfs_btree_cur的xfs_bmap_free 
   > xfs_bmap_add_free(xfs_fsblock_t, 1, xfs_btree_cur->bc_private->b->xfs_bmap_free, xfs_mount)
   - 减小xfs_inode->xfs_icdinode->di_nblocks --
   - 记录xfs_inode修改 
   > xfs_trans_log_inode(xfs_trans, xfs_inode, XFS_ILOG_CORE)
   - trans什么操作?? 
   > xfs_trans_binval(xfs_trans, xfs_buf)

** xfs_bmbt_get_minrecs(xfs_btree_cur, level)
   - 获取最小的分支数??
   - 如果是根结点, level == xfs_btree_cur->bc_nlevels -1, 计算xfs_ifork最大的空间, 取其一半
   > xfs_bmbt_maxrecs(xfs_mount, xfs_ifork->if_broot_bytes, level ==0) /2 
   - 否则使用xfs_mount->m_bmap_dmnr[ level !=0 ]

** xfs_bmbt_get_maxrecs(xfs_btree_cur, level)
   - 如果是根结点, 根结点也可以是叶子结点?? 
   > xfs_bmbt_maxrecs(xfs_mount, xfs_ifork->if_broot_bytes, level ==0) 
   > xfs_mount->m_bmap_dmxr[level != 0] 

** xfs_bmbt_get_dmaxrecs(xfs_btree_cur, level)
   - 获取磁盘中一个结点支持的最多记录个数??
   - 如果不是跟结点, 使用xfs_map->m_bmap_dmxr[level !=0], 和上面一样
   - 否则不一样?? 
   > xfs_bmdr_maxrecs(xfs_mount, xfs_bmbt_cur->bc_private->b->forksize, level != 0)
     
** xfs_bmbt_init_key_from_rec(xfs_btree_key, xfs_btree_rec) 
   - xfs_btreekey是xfs_bmbt_key, 使用文件偏移
   - 但这里的数据类型是大端的  __be64
   - 返回xfs_btree_rec的bt_startoff

** xfs_bmbt_inti_rec_from_key(xfs_btree_key, xfs_btree_rec) 
   - 根据xfs_btree_key初始化xfs_btree_rec, 也就是xfs_bmbt_rec
   - 只设置文件偏移 startoff 

** xfs_bmbt_init_rec_from_cur(xfs_btree_cur, xfs_btree_rec)
   - 使用xfs_btree_cur->bc_rec->b, 也就是xfs_bmbt_irec
   > xfs_bmbt_disk_set_all(xfs_bmbt_rec->xfs_bmbt_rec, xfs_btree_cur->bc_rec->xfs_bmbt_irec)

** xfs_bmbt_init_ptr_from_cur(xfs_bmbt_cur, xfs_btree_ptr)
   - 设置为0?? 不是NULL

** xfs_bmbt_key_diff(xfs_btree_cur, xfs_btree_key)
   - 比较xfs_btree_key和要查找的记录的关系
   - xfs_btree_key是文件偏移,而且数据结构是大端的, 先转化为普通的数据类型
   - 然后和xfs_btree_cur->bc_rec->b->br_startoff比较 

** xfs_bmbt_verify(xfs_buf)
   - xfs_buf里面是xfs_btree_block, 检查它的格式??
   - magic, crc, uuid, blkno, owner不能是0
   - level不能超过xfs_mount->m_bm_maxlevels[]
   - numrecs不能超过 xfs_mount->m_bmap_dmxr[]
   - 而且兄弟指针不能为NULLDFSBNO, 或者为0, 或者和当前的结点在一个ag中

** xfs_bmbt_read_verify(xfs_buf)
   - 先计算crc
   > xfs_btree_lblock_verify_crc(xfs_buf)
   - 然后检查xfs_btree_block
   > xfs_bmbt_verify(xfs_buf)

** xfs_bmbt_write_verify(xfs_buf)
   - 写之前的验证
   - 检查xfs_btree_block
   > xfs_bmbt_verify(xfs_buf)
   - 然后计算crc, 谁用呢? 
   > xfs_btree_lblock_calc_crc(xfs_buf)
   
** xfs_buf_ops xfs_bmbt_buf_ops 
   - 包装上面的2个verify函数, 给xfs_btree_ops使用

** xfs_bmbt_keys_inorder(xfs_btree_cur, xfs_btree_key k1, k2)
   - 返回 k1 < k2, 需要先转化为本地的数据类型

** xfs_bmbt_recs_inorder(xfs_bmbt_cur, xfs_btree_rec r1, r2)
   - 比较范围是否有序
   - r1->br_startoff + r1->br_blockcount <= r2->br_startoff

** xfs_btree_ops xfs_bmbt_ops
   - 构造回调函数指针 

** xfs_bmbt_init_cursor(xfs_mount, xfs_trans, xfs_inode, whichfork)
   - 构造新的xfs_btree_cur
   - 设置参数xfs_mount, xfs_trans
   - bc_nlevels需要跟结点,在xfs_ifork中保存 
   > xfs_ifork->if_broot->bb_level + 1
   - bc_blocklog是什么?? xfs_sb->sb_blocklog
   - bc_flags设置为XFS_BTREE_LONG_PTR | XFS_BTREE_ROOT_IN_INODE
   - 然后是xfs_btree_cur->bc_private->b
   - forksize是对应的xfs_ifork在xfs_dinode中的空间大小 
   > XFS_IFORK_SIZE(xfs_inode, whichfork)
   - xfs_inode, whichfork
   - 其他的都设为0, 哪里分配的xfs_bmap_free?? 

** xfs_bmbt_maxrecs(xfs_mount, blocklen, leaf)
   - 对于磁盘中结点长度为blocklen, 计算支持的做多记录数?? 
   - 减去头部XFS_BMBT_BLOCK_LEN(xfs_mount), 磁盘中xfs_bmdr_block不是没有crc等??
   - 对于叶子结点,返回blocklen /= sizeof(xfs_bmbt_rec)
   - 对于内部结点,返回blocklen /= (sizeof(xfs_bmbt_key + xfs_bmbt_ptr))
   - 这里没有使用xfs_btree_key / xfs_btree_ptr, 应该是更精确了.. 

** xfs_bmdr_maxrecs(xfs_mount, blocklen, leaf)
   - 对于普通的非跟结点,还是使用xfs_btree_block
   - 对于在xfs_dinode的跟结点,使用xfs_bmdr_block, 不需要xfs_btree_block重复的成员
   - blocklen -= sizeof(xfs_bmdr_block)
   - 对于叶子结点, blocklen /= sizeof(xfs_bmdr_rec)
   - 对于内部结点, blocklen /= (sizeof(xfs_bmdr_key) + sizeof(xfs_bmdr_ptr))

** xfs_bmdr_change_owner(xfs_trans, xfs_inode, whichfork, xfs_ino_t new_owner, list_head buffer_list)
   - 修改xfs_ifork的xfs_inode?这个可以移动?? 
   - 创建一个xfs_btree_cur 
   > xfs_bmbt_init_cursor(xfs_mount, xfs_trans, xfs_inode, whichfork)
   - 遍历所有的结点, 修改对应的owner成员
   > xfs_btree_change_owner(xfs_btree_cur, new_owner, buffer_list)
   - 删除xfs_btree_cur
* xfs_trans_buf.c

** xfs_buf_log_format 
   #+begin_src 
	unsigned short	blf_type;	/* buf log item type indicator */
	unsigned short	blf_size;	/* size of this item */
	ushort		blf_flags;	/* misc state */
	ushort		blf_len;	/* number of blocks in this buf */
	__int64_t	blf_blkno;	/* starting blkno of this buf */
	unsigned int	blf_map_size;	/* used size of data bitmap in words */
	unsigned int	blf_data_map[XFS_BLF_DATAMAP_SIZE]; /* dirty bitmap */   
   #+end_src

** xfs_buf_log_item
   #+begin_src 
	xfs_log_item_t		bli_item;	/* common item structure */
	struct xfs_buf		*bli_buf;	/* real buffer pointer */
	unsigned int		bli_flags;	/* misc flags */
	unsigned int		bli_recur;	/* lock recursion count */
	atomic_t		bli_refcount;	/* cnt of tp refs */
	int			bli_format_count;	/* count of headers */
	struct xfs_buf_log_format *bli_formats;	/* array of in-log header ptrs */
	struct xfs_buf_log_format __bli_format;	/* embedded in-log header */   
   #+end_src

** xfs_buf_map
   #+begin_src 
	xfs_daddr_t		bm_bn;	/* block number for I/O */
	int			bm_len;	/* size of I/O */   
   #+end_src

** xfs_trans_buf_item_match(xfs_trans, xfs_buftarg, xfs_buf_map, nmaps)
   - 检查xfs_buf_map映射的空间在xfs_trans中??
   - xfs_buf_map数组的空间是连续?? 累加他们的长度
   - 遍历xfs_trans->t_items
   - xfs_log_item->li_type = XFS_LI_BUF xfs_log_item才是xfs_buf_log_item
   - xfs_buf_log_item->bli_buf->b_target = xfs_buftarg, 使用相同的设备
   - xfs_buf_log_item->bli_buf->b_maps[0].bm_bn = map[0].bm_bn
   - xfs_buf_log_item->bli_buf->b_length = len
   - 满足这些条件,返回xfs_buf_log_item->bli_buf. 为何只比较xfs_buf_map[0].bm_bn??

** _xfs_trans_bjoin(xfs_trans, xfs_buf, reset_recur)
   - 把xfs_buf填加到xfs_trans
   - 给xfs_buf创建xfs_buf_log_item, 还有xfs_buf_log_format
   > xfs_buf_item_init(xfs_buf, xfs_trans->xfs_mount)
   - 创建xfs_log_item_desc, 放到xfs_trans->lid_trans队列中.
   > xfs_trans_add_item(xfs_trans, xfs_buf_log_item->xfs_log_item)
   - 设置xfs_buf->b_transp = xfs_trans

** xfs_trans_bjoin(xfs_trans, xfs_buf)
   - 没有reset_cur??
   > _xfs_trans_bjoin(xfs_trans, xfs_buf, 0)

** xfs_trans_get_buf_map(xfs_trans, xfs_buftarg, xfs_buf_map, nmaps, xfs_buf_flags)
   - 如果xfs_trans = NULL, 只是普通的获取block map信息
   > xfs_buf_get_map(xfs_buftarg, xfs_buf_map, nmaps, flags)
   - 先在xfs_trans中找是否有对应的xfs_buf 
   > xfs_trans_buf_item_match(xfs_trans, xfs_buftarg, xfs_buf_map, nmaps)
   - 如果能找到, 获取xfs_buf_log_item, xfs_buf_log_item->bli_recur ++, 返回找到的
   - 如果找不到, 还得去找对应的xfs_buf_map信息
   > xfs_buf_get_map(xfs_buftarg, xfs_buf_map, nmaps, flags)
   - 把它填加到xfs_trans中
   > _xfs_trans_bjoin(xfs_trans, xfs_buf, 1)

** xfs_trans_getsb(xfs_trans, xfs_mount, flags)
   - 如果xfs_trans == NULL, 就是一个普通的操作?
   - 获取xfs_sb->m_sb_bp
   > xfs_getsb(xfs_mount, flags)
   - 如果xfs_trans != NULL, 就是对应的xfs_buf的log操作
   - 如果xfs_buf->b_transp == xfs_trans, 它已经在xfs_trans管理中,上面怎么不用这个判断??
   - xfs_buf->b_fspriv就是xfs_buf_log_item, xfs_buf_log_item->bli_recur ++ 返回
   - 否则,先去找到xfs_buf 
   > xfs_getsb(xfs_mount, flags)
   - 填加到xfs_trans中
   > _xfs_trans_bjoin(xfs_trans, xfs_buf, 1)

** xfs_trans_read_buf_map(xfs_mount, xfs_trans, xfs_buftarg, xfs_buf_map, nmaps, xfs_buf_flags, xfs_buf, xfs_buf_ops)
   - 如果xfs_trans == NULL,根据xfs_buf_map直接去xfs_perag中查找. 即使找不到也会创建一个,以及对应的xfs_buf, 把磁盘数据读出来.
   > xfs_buf_read_map(xfs_buftarg, xfs_buf_map, nmaps, flags, xfs_buf_ops)
   - 如果没找到xfs_buf, 返回EAGAIN
   - 如果没有问题,把它使用倒数第2个参数返回
   - 如果xfs_trans != NULL, 去xfs_trans中查找
   > xfs_trans_buf_item_match(xfs_trans, xfs_buftarg, xfs_buf_map, nmaps)
   - 如果找到xfs_buf, 检查它的状态
   - xfs_buf必须是锁着的
   > xfs_buf_islocked(xfs_buf)
   - xfs_buf->xfs_trans是参数xfs_trans, xfs_buf->b_fspriv是xfs_buf_log_item
   - 检查xfs_buf->b_flags的XBF_DONE, 如果没有,说明数据是无效的??
   - 这里要去发起读操作
   - 设置xfs_buf->b_ops = ops
   - 启动读IO
   > xfsbdstrat(xfs_trans->xfs_mount, xfs_buf)
   - 等待io
   > xfs_buf_iowait(xfs_buf)
   - 既然找到xfs_buf_log_item, xfs_buf_log_item->bli_recur ++, 返回找到的xfs_buf
   - 如果找不到xfs_buf, 就需要去创建,并读取磁盘数据
   > xfs_buf_read_map(xfs_buftarg, xfs_buf_map, nmaps, flags, xfs_buf_ops)
   - 如果返回NULL, 创建失败,返回ENOMEM
   - 把它放到xfs_trans中
   > _xfs_trans_bjoin(xfs_trans, xfs_buf, 1)

** xfs_trans_brelse(xfs_trans, xfs_buf)
   - 如果xfs_trans = NULL, 普通的释放xfs_buf
   > xfs_buf_relse(xfs_buf)
   - 否则从xfs_trans中释放它. 如果它有改动,估计要写到log中
   - 检查xfs_buf / xfs_buf_log_item的状态
   - xfs_buf->b_transp = xfs_trans
   - xfs_buf_log_item->xfs_log_item->li_type = XFS_LI_BUF
   - xfs_buf_log_item->bli_flags 没有 XFS_BLI_STALE??
   - xfs_buf_log_item->xfs_buf_log_format->blf_flags 没有 XFS_BLF_CANCEL
   - 如果xfs_buf_log_item->bli_recur > 0, xfs_buf_log_item->bli_recur --, 直接返回, 这只是一个多重解锁.
   - xfs_buf_log_item->xfs_log_item->xfs_log_item_desc->lid_flags & XFS_LID_DIRTY !=0, 说明它需要保存修改的数据,直接返回
   - 否则这里应该释放xfs_buf
   - 如果xfs_buf->bli_flags & XFS_BLI_STALE !=0, 直接返回. 但上面检查是怎么回事.
   - 删除xfs_log_item_desc, 释放它和xfs_trans的关系
   > xfs_trans_del_item(xfs_buf_log_item->xfs_log_item)
   - xfs_buf_log_item->bli_refcount --
   - 检查xfs_buf_log_item是否有log数据
   > xfs_buf_item_dirty(xfs_buf_log_item)
   - 如果没有,释放xfs_buf_log_item
   > xfs_buf_item_relse(xfs_buf)
   - 最后释放xfs_buf的使用计数
   > xfs_buf_relse(xfs_buf)

** xfs_trans_bhold(xfs_trans, xfs_buf)
   - 设置xfs_buf_log_item->bli_flags |= XFS_BLI_HOLD
   - 这里会检查xfs_buf状态
   - xfs_buf->xfs_trans, xfs_buf->b_fspriv

** xfs_trans_bhold_release(xfs_trans, xfs_buf)
   - 取消hold标志
   - 首先大量的检查, 最后是简单的设置 xfs_buf_log_item->bli_flags &= ~XFS_BLI_HOLD

** xfs_trans_log_buf(xfs_trans, xfs_buf, first, last)
   - 设置(first, last)区间, 在xfs_trans提交时,必须保存到log中
   - 设置xfs_buf的标志  xfs_buf->b_flags & XBF_DONE
   - 设置xfs_buf / xfs_log_item的回调函数
   - 回调函数把xfs_buf从ail中释放,当写回磁盘时把它销毁
   - xfs_buf->b_iodone  = xfs_buf_iodone_callbacks
   - xfs_buf_log_item->xfs_log_item->li_cb = xfs_buf_iodone
   - 检查xfs_buf_log_item->bli_flags & XFS_BLI_STALE, 它表示这个xfs_buf被释放了.这里又重新使它有效, 去掉xfs_buf_log_item->bli_flags的XFS_BLI_STALE, xfs_buf->b_flags的XBF_STALE, 还有xfs_buf_log_format->blf_flags的XFS_BLF_CANCEL
   - 设置xfs_trans->t_flags的XFS_TRANS_DIRTY, xfs_buf_log_item->xfs_log_item->xfs_log_item_desc->lid_flags的XFS_LID_DIRTY, xfs_buf_log_item->bli_flags的XFS_BLI_LOGGED
   - 把xfs_buf放到标记到xfs_buf_log_format中
   > xfs_buf_item_log(xfs_buf_log_item, first, last)

** xfs_trans_binval(xfs_trans, xfs_buf)
   - 无效xfs_trans管理的xfs_buf. 因为要释放它,所以不用把它写回磁盘. 对于xfs_buf_log_item, 使用XFS_BLF_CANCEL
   - 相当于记录xfs_buf的状态
   - 如果xfs_buf->xfs_buf_log_item->bli_flags & XFS_BLI_STALE !=0, 它已经无效, 直接退出. 这里有大量的检查
   - xfs_buf_log_item->bli_flags & (XFS_BLI_LOGGED | XFS_BLI_DIRTY) ==0
   - xfs_buf_log_format->blf_flags的XFS_BLF_MASK表示xfs_buf里面是什么数据
   - xfs_buf_log_item->xfs_buf_log_format->blf_flags & XFS_BLF_INODE_BUF ==0
   - xfs_buf_log_item->xfs_buf_log_format->blf_flags & XFS_BLF_CANCEL !=0
   - xfs_buf_log_item->xfs_log_item->xfs_log_item_desc->lid_flags & XFS_LID_DIRTY !=0
   - xfs_trans->t_flags & XFS_TRANS_DIRTY !=0
   - 如果它还不是无效的,先修改xfs_buf标志
   - xfs_buf->b_flags |= XBF_STALE
   - 还有xfs_buf_log_item / xfs_buf_log_format XFS_BLF_CANCEL
   - 遍历xfs_buf_log_item->bli_formats数组, 把xfs_buf_log_format->blf_data_map中数据清空,那些数据不再使用
   - 设置xfs_log_item_desc->lid_flags的XFS_LID_DIRTY
   - 设置xfs_buf->t_flags 的XFS_TRANS_DIRTY
   
** xfs_trans_inode_buf(xfs_trans, xfs_buf)
   - 设置xfs_buf_log_item->bli_flags的XFS_BLI_INODE_BUF标志
   - 在xfs_buf_log_format中记录类型
   - 用于unlink处理??

** xfs_trans_stale_inode_buf(xfs_trans, xfs_buf)
   - xfs_buf里面是xfs_dinode, 要释放这个xfs_buf
   - 设置xfs_buf_log_item->bli_flags的XFS_BLI_STALE_INODE
   - 设置xfs_log_item的回调函数
   - xfs_buf_log_item->bli_item->li_cb = xfs_buf_iodone

** xfs_trans_inode_alloc_buf(xfs_trans, xfs_buf)
   - 记录这个xfs_buf中有新alloc的inode
   - 添加xfs_buf_log_item->bli_flags的XFS_BLI_INODE_ALLOC_BUF
   - 设置inode标志

** xfs_blft 
   #+begin_src 
	XFS_BLFT_UNKNOWN_BUF = 0,
	XFS_BLFT_UDQUOT_BUF,
	XFS_BLFT_PDQUOT_BUF,
	XFS_BLFT_GDQUOT_BUF,
	XFS_BLFT_BTREE_BUF,
	XFS_BLFT_AGF_BUF,
	XFS_BLFT_AGFL_BUF,
	XFS_BLFT_AGI_BUF,
	XFS_BLFT_DINO_BUF,
	XFS_BLFT_SYMLINK_BUF,
	XFS_BLFT_DIR_BLOCK_BUF,
	XFS_BLFT_DIR_DATA_BUF,
	XFS_BLFT_DIR_FREE_BUF,
	XFS_BLFT_DIR_LEAF1_BUF,
	XFS_BLFT_DIR_LEAFN_BUF,
	XFS_BLFT_DA_NODE_BUF,
	XFS_BLFT_ATTR_LEAF_BUF,
	XFS_BLFT_ATTR_RMT_BUF,
	XFS_BLFT_SB_BUF,
   #+end_src

** xfs_trans_buf_set_type(xfs_trans, xfs_buf, xfs_blft)
   - 设置xfs_buf_log_item->xfs_buf_log_format
   > xfs_blft_to_flags(xfs_buf_log_item->xfs_buf_log_format, type)

** xfs_trans_buf_copy_type(xfs_buf dst, xfs_buf src)
   - 借用dst的xfs_blft  xfs_buf->xfs_buf_log_item->xfs_buf_log_format
   > xfs_blft_from_flags(xfs_buf_log_item->__bli_format)
   > xfs_blft_to_flags(xfs_bu_log_item->xfs_buf_log_format, type)

** 总结
   - 这里还是包装xfs_buf_log_item和xfs_buf的操作. 只要操作xfs_extent/xfs_buf的地方都使用这里的功能. 比较特殊的是inode

* xfs_buf_item.c

** xfs_log_item 
   #+begin_src 
	struct list_head		li_ail;		/* AIL pointers */
	xfs_lsn_t			li_lsn;		/* last on-disk lsn */
	struct xfs_log_item_desc	*li_desc;	/* ptr to current desc*/
	struct xfs_mount		*li_mountp;	/* ptr to fs mount */
	struct xfs_ail			*li_ailp;	/* ptr to AIL */
	uint				li_type;	/* item type */
	uint				li_flags;	/* misc flags */
	struct xfs_log_item		*li_bio_list;	/* buffer item list */
	void				(*li_cb)(struct xfs_buf *,
						 struct xfs_log_item *);
							/* buffer item iodone */
							/* callback func */
	const struct xfs_item_ops	*li_ops;	/* function list */

	/* delayed logging */
	struct list_head		li_cil;		/* CIL pointers */
	struct xfs_log_vec		*li_lv;		/* active log vector */
	xfs_lsn_t			li_seq;		/* CIL commit seq */
   #+end_src

** xfs_buf_log_item
   #+begin_src 
	xfs_log_item_t		bli_item;	/* common item structure */
	struct xfs_buf		*bli_buf;	/* real buffer pointer */
	unsigned int		bli_flags;	/* misc flags */
	unsigned int		bli_recur;	/* lock recursion count */
	atomic_t		bli_refcount;	/* cnt of tp refs */
	int			bli_format_count;	/* count of headers */
	struct xfs_buf_log_format *bli_formats;	/* array of in-log header ptrs */
	struct xfs_buf_log_format __bli_format;	/* embedded in-log header */   
   #+end_src

** xfs_buf_log_format
   #+begin_src 
	unsigned short	blf_type;	/* buf log item type indicator */
	unsigned short	blf_size;	/* size of this item */
	ushort		blf_flags;	/* misc state */
	ushort		blf_len;	/* number of blocks in this buf */
	__int64_t	blf_blkno;	/* starting blkno of this buf */
	unsigned int	blf_map_size;	/* used size of data bitmap in words */
	unsigned int	blf_data_map[XFS_BLF_DATAMAP_SIZE]; /* dirty bitmap */   
   #+end_src

** xfs_blft 
   - 在xfs_buf_log_format->blf_flags里面
   #+begin_src 
	XFS_BLFT_UNKNOWN_BUF = 0,
	XFS_BLFT_UDQUOT_BUF,
	XFS_BLFT_PDQUOT_BUF,
	XFS_BLFT_GDQUOT_BUF,
	XFS_BLFT_BTREE_BUF,
	XFS_BLFT_AGF_BUF,
	XFS_BLFT_AGFL_BUF,
	XFS_BLFT_AGI_BUF,
	XFS_BLFT_DINO_BUF,
	XFS_BLFT_SYMLINK_BUF,
	XFS_BLFT_DIR_BLOCK_BUF,
	XFS_BLFT_DIR_DATA_BUF,
	XFS_BLFT_DIR_FREE_BUF,
	XFS_BLFT_DIR_LEAF1_BUF,
	XFS_BLFT_DIR_LEAFN_BUF,
	XFS_BLFT_DA_NODE_BUF,
	XFS_BLFT_ATTR_LEAF_BUF,
	XFS_BLFT_ATTR_RMT_BUF,
	XFS_BLFT_SB_BUF,
	XFS_BLFT_MAX_BUF = (1 << XFS_BLFT_BITS),   
   #+end_src

** xfs_buf_item_size_segment(xfs_buf_log_item, xfs_buf_log_format)
   - 遍历xfs_buf_log_format->blf_data_map, 里面连续为1的一段使用一个xfs_log_iovec. 查找需要的xfs_log_iovec数量.
   - 对于连续的一段,也是每一位都检查
   > xfs_buf_offset(xfs_buf, next_bit * XFS_BLF_CHUNK) == xfs_buf_offset(xfs_buf, last_bit * XFS_BLF_CHUNK) + XFS_BLF_CHUNK

** xfs_buf_item_size(xfs_log_item)
   - 如果xfs_buf_log_item->bli_flags & XFS_BLI_STALE == 1), 不用再log数据,只要xfs_log_format  xfs_buf_log_item->bli_format_count 表示xfs_buf_log_format的个数
   - 否则遍历每个xfs_buf_log_format, 累加每个需要的xfs_log_iovec个数
   > xfs_buf_item_size_segment(xfs_buf_log_item, xfs_buf_log_format)

** xfs_buf_item_format_segment(xfs_buf_log_item, xfs_log_iovec, offset, xfs_buf_log_format)
   - 把xfs_buf_log_item和xfs_buf_log_format放到xfs_log_iovec中.
   - 第一个xfs_log_iovec指向xfs_buf_log_format, 设置xfs_buf_log_item_format->blf_flags = xfs_buf_log_item->__bli_format->blf_flags. 参数xfs_buf_log_format是xfs_buf_log_item->bli_formats数组里的, xfs_buf_log_item->__bli_format是什么??
   - 第一个xfs_io_iovec->t_type = XLOG_REG_TYPE_BFORMAT. 
   - 如果xfs_buf->bli_flags &XFS_BLI_STALE, xfs_buf_log_format->blf_flags & XFS_BLF_CANCEL ==1, 直接退出
   - 然后遍历xfs_buf_log_format->blf_data_map, 找出设置位的一段范围
   - 根据位的位置计算数据在xfs_buf中的偏移
   - buffer_offset = offset + first_bit * XFS_BLF_CHUNK
   - xfs_log_iovec->i_addr = xfs_buf_offset(xfs_buf, buffer_offset)
   - xfs_log_iovec->i_len = nbits * XFS_BLF_CHUNK
   - xfs_log_iovec->i_type = XLOG_REG_TYPE_BCHUNK
   - 最后设置 xfs_buf_log_format->blf_size = nvecs, xfs_log_iovec的个数.

** xfs_buf_item_format(xfs_log_item, xfs_log_iovec)
   - xfs_log_item属于xfs_buf_log_item, 还不确定xfs_buf里面是什么数据
   - 如果xfs_buf_log_item->bli_flags & XFS_BLI_INODE_BUF ==1, 这里面装xfs_dinode, 设置xfs_buf_log_item->__bli_format->blf_flags的XFS_BLF_INODE_BUF. 它会传递给所有的xfs_buf_log_format
   - 遍历所有的xfs_buf_log_format, 填充相关的xfs_log_iovec
   > xfs_buf_item_format_segment(xfs_buf_log_item, xfs_log_iovec, offset, xfs_buf_log_item->bli_formats[i]
   - 数组中一个xfs_buf_log_format对应一个xfs_buf_map

** xfs_buf_item_pin(xfs_log_item)
   - 增加xfs_buf_log_item->bli_refcount, xfs_buf_log_buf->xfs_buf->b_pin_count

** xfs_buf_item_unpin(xfs_log_item, remove)
   - 首先减小 xfs_buf_log_item->bli_refcount --
   - 然后是  xfs_buf->b_pin_count --  , 如果减为0,唤醒xfs_buf->b_waiters
   > wake_up_all(xfs_buf->b_waiters)
   - 检查xfs_buf_log_item->bli_flags & XFS_BLI_STALE, 如果变为stale, 而且free==1, 删除这个xfs_log_item
   - 如果remove==1, 释放xfs_log_item_desc
   > xfs_trans_del_item(xfs_log_item)
   - 要是放xfs_log_item, 如果是inode   xfs_buf_log_item->bli_flags & XFS_BLI_STALE_INODE ==1
   > xfs_buf_do_callbacks(xfs_buf)
   - 清空xfs_buf->b_fspriv/b_iodone
   - 否则是普通的buf, 释放ail
   > xfs_trans_ail_delete(xfs_ail, xfs_log_item,SHUTDOWN_LOG_IO_ERROR)
   - 释放xfs_log_item
   > xfs_buf_item_relse(xfs_buf)
   - 最后释放xfs_buf
   > xfs_buf_relse(xfs_buf)
   - 如果free==1, 而且remove==1,即使xfs_log_item不是stale的,也要把它删除
   - 因为错误??
   - 设置xfs_buf->b_flags的XBF_ASYNC, 去掉XBF_DONE
   > xfs_buf_ioerror(xfs_buf, EIO)
   - 设置stale, 调用xfs_buf的回调xfs_buf_ioend
   > xfs_buf_stale(xfs_buf)
   > fs_buf_ioend(xfs_buf, 0)

** xfs_buf_item_push(xfs_log_item, list_head)
   - 要把xfs_buf写回磁盘, 检查是否满足要求
   - 首先是pin,  xfs_buf->b_pin_count. 
   - 在IOP_PIN操作中增加, 表示它在xfs_cil中. IOP_UNPIN是
   > xfs_buf_ispinned(xfs_buf)
   - 添加队列要锁住xfs_buf
   > xfs_buf_trylock(xfs_buf)
   - 把它放到list_head队列中, 设置_XBF_DELWRI_Q
   > xfs_buf_delwri_queue(xfs_buf, list_head)

** xfs_buf_item_unlock(xfs_log_item)
   - 释放xfs_log_item关联的xfs_buf?
   - 去掉xfs_buf->bli_flags的XFS_BLI_LOGGED|XFS_BLI_HOLD标志
   - 如果xfs_buf->bli_flags & XFS_BLI_STALE ==1, 这里不处理, 只是减小xfs_buf->bli_refcount
   - 检查xfs_buf_log_item的bitmap中是否还有xlog的数据, 哪里清除这些bitmap
   - 遍历xfs_buf_log_item->bli_formats数组
   > xfs_bitmap_empty(xfs_buf_log_format->blf_data_map, map_size)
   - 如果没有数据, 释放xfs_buf_log_item. 
   - 关联xfs_buf的使用xfs_buf_log_item->li_bio_list组成链表, xfs_buf还会使用下一个
   > xfs_buf_item_relse(xfs_buf)
   - 如果还有,只是减小xfs_buf_log_item->refcount

** xfs_buf_item_committed(xfs_log_item, xfs_lsn_t )
   - 对于普通的xfs_log_item, 返回参数. 
   - 如果xfs_buf_log_item->bli_flags & XFS_BLI_INODE_ALLOC_BUF !=0, 而且xfs_log_item->li_lsn !=0, 返回它,应该比参数xfs_lsn_t早

** xfs_buf_item_committing(xfs_log_item, xfs_lsn_t)
   - 空函数

** xfs_buf_item_get_format(xfs_buf_log_item, count)
   - 准备xfs_buf_log_item->bli_formats. 如果count==1, 使用xfs_buf_log_item->__bli_format, 否则分配一个数组

** xfs_buf_item_free_format(xfs_buf_log_item)
   - 释放xfs_buf_log_format数组

** xfs_buf_item_init(xfs_buf, xfs_mount)
   - 给xfs_buf创建xfs_buf_log_item,准备放到xfs_trans中.
   - 如果xfs_buf->b_fspriv有效, 它已经指向xfs_log_item; 而且xfs_log_item->li_type == XFS_LI_BUF, 直接退出.
   - 对于xfs_buf不可能有多个xfs_buf_log_item. 但可能有其他的xfs_log_item
   - 构造xfs_buf_log_item, 初始化它内嵌的xfs_log_item
   > xfs_log_item_init(xfs_mount, xfs_log_item, XFS_LI_BUF, xfs_buf_item_ops)
   - 设置xfs_buf->b_hold   xfs_buf->b_hold ++,  它会释放xfs_buf或把它放到lru队列
   > xfs_buf_hold(xfs_buf)
   - 初始化xfs_buf_log_format
   > xfs_buf_item_get_format(xfs_buf, xfs_buf->b_map_count)
   - 使用xfs_buf的xfs_buf_map数组,初始化xfs_buf_log_format, 磁盘位置(blkno,len), blf_map_size是把len对齐XFS_BLF_CHUNK之后的值
   - 最后把xfs_buf_log_item放到xfs_buf->b_fspriv链表中

** xfs_buf_item_log_segment(xfs_buf_log_item, first, last, void *map)
   - 把xfs_buf中管理的一块数据在xfs_buf_log_format中标记出来,需要写到xlog磁盘.
   - map是xfs_buf_log_format->blf_data_map
   - first, last是字节单位,需要转化为XFS_BLK_CHUNK

** xfs_buf_item_log(xfs_buf_log_item, first, last)
   - 首先标记xfs_buf_log_item->bli_flags的XFS_BLI_DIRTY
   - 把xfs_buf的改动记录到xfs_buf_log_item中.
   - 遍历xfs_buf_log_format, 操作(first, last)范围内的
   > xfs_buf_item_log_segment(xfs_log_item, first, end, xfs_buf_log_format->blf_data_map)

** xfs_buf_item_dirty
   - 判断xfs_buf_log_item是否需要处理  xfs_buf_log_item->bli_flags & XFS_BLI_DIRTY

** xfs_buf_item_free(xfs_buf_log_item)
   - 释放xfs_buf_log_item, xfs_buf_log_item, 只有内存释放动作

** xfs_buf_item_relse(xfs_buf)
   - 释放xfs_buf关联的xfs_buf_log_item, xfs_buf->b_fspriv链表上的第一个.
   - 释放xfs_buf->b_hold
   > xfs_buf_rele(xfs_buf)
   - 然后是它自己
   > xfs_buf_item_free(xfs_buf_log_item)

** xfs_buf_attach_iodone(xfs_buf, callback, xfs_log_item)
   - 把xfs_log_item给xfs_buf->b_fspriv队列.
   - 而且设置xfs_buf->b_iodone = xfs_buf_iodone_callbacks
   - 而且设置xfs_log_item->li_cb = callback, 在xfs_buf_iodone_callbacks中会调用

** xfs_buf_do_callbacks(xfs_buf)
   - 遍历xfs_buf->b_fspriv链表上所有的xfs_log_item
   - 调用回调函数
   > xfs_log_item->li_cb(xfs_buf, xfs_log_item)

** xfs_buf_iodone_callbacks(xfs_buf)
   - 这个是上面提到在xfs_buf->b_iodone调用的.
   - 首选如果xfs_buf的io没有错误, 处理回调
   > xfs_buf_do_callbacks(xfs_buf)
   - 然后是其他的回调
   > xfs_buf_ioend
   - 如果有错误, 也没有怎么处理!!
   - 如果xfs_buf->b_flags & XBF_ASYNC ==1, 它是异步的,没人关心它的结果?!
   - 如果xfs_buf->b_flags & XBF_STALE ==0, 说明它是可用的, 重新提交一遍
   - 使用XBF_WRITE|XBF_ASYNC|XBF_DONE, 还是异步方式
   > xfs_buf_iorequest(xfs_buf)
   - 否则直接释放它
   > xfs_buf_relse(xfs_buf)

** xfs_buf_iodone(xfs_buf, xfs_log_item)
   - 先释放xfs_buf
   > xfs_buf_rele(xfs_buf)
   - 在xfs_cil中释放xfs_log_item
   > xfs_trans_ail_delete(xfs_ail. xfs_log_item, SHUTDOWN_CORRUPT_INCORE)
   - 释放xfs_buf_log_item 
   > xfs_buf_item_free(xfs_buf_log_item)

** 总结
   - 首先这里实现了一套xfs_item_ops, 对应XFS_LI_BUF. 解释一下xfs_buf_log_item的生命.
   - IOP_SIZE = xfs_buf_item_size 
     - 计算需要的xfs_log_iovec的数量. 首先xfs_buf_log_format使用一个,然后它管理的每个chunk数据块使用一个.
     - 在提交xfs_trans时使用, 它要把数据存到xfs_log_vec中.
   - IOP_FORMAT = xfs_buf_item_format, 填充xfs_buf_log_format的信息, 没有复制数据,只是记录数据的位置等
   - IOP_PIN = xfs_buf_item_pin, 对于xfs_buf_log_item, 增加bli_refcount/xfs_buf->b_pin_count, 方式释放掉. 在把它放到xfs_cil_ctx中时,设置这个标志
   - IOP_UNLOCK = xfs_buf_item_unlock
     - 对于xfs_buf_log_item, 取出XFS_BLI_LOGGED/XFS_BLI_HOLD标志, 设置xfs_buf->b_transp = NULL, 使用xfs_buf/xfs_buf_log_item的使用计数. 
     - 如果xfs_buf_log_item没有改动的数据,可能要释放它自己.
     - 在xfs_trans提交完成后, 需要释放xfs_trans, 同时解锁它的xfs_log_item
   - IOP_COMMITTING = xfs_buf_item_committing, 对于xfs_buf_log_item是空函数. 在xfs_trans释放时调用. 也就是在unlock之前
   - IOP_COMMITTED = xfs_buf_item_committed
     - 在xlog_in_core的回调中,处理xfs_cil_ctx时调用,即将把它放到ail队列中.
     - xfs_log_item->xfs_lsn_t表示它所在的xlog中的位置,xfs_ail根据它更新xlog的磁盘空间信息
     - 大致看只有它加入到xfs_ail中才设置xfs_log_item->xfs_lsn_t.
     - 如果xfs_log_item->xfs_lsn_t == -1, 不再在xlog中管理它, 它对xlog磁盘空间信息没有影响. 谁管他??
     - 如果IOP_COMMITTED返回的xfs_lsn_t和提交它的xfs_lsn_t不一样时, 也不在把它放到ail队列中. 因为它已经在ail中?? 
   - IOP_PUSH = xfs_buf_item_push
     - 要把它关联的xfs_buf数据写回磁盘. 如果没有人使用它, 把它放到一个队列中,一块启动IO. 
     - 在需要释放xfs_ail中xfs_buf_log_item时调用. 来回收xlog空间
   - IOP_UNPIN
     - 对于xfs_buf_log_item, 它只是释放xfs_buf_log_item->bli_refcount, xfs_buf_log_item->b_pin_count
     - 唤醒xfs_buf->b_waiters. 在写xfs_buf时等待这个锁! 这个锁保证xlog数据在原数据之前写进去.
     - 在xfs_buf_log_item填加到xfs_ail队列时使用.或者说是xfs_cil_ctx释放xfs_log_item时使用.
   - 对外部提供的功能为给xfs_buf构造xfs_buf_log_item, 填加到xfs_trans中,而且标记需要log的数据. 都是给xfs_trans_buf.c中使用
   - 在xfs_buf完成后,调用xfs_log_item->li_cb, 好像只有inode使用这个. 提供接口挂钩会回调函数. 在创建xfs_buf_log_item时就设置,没有很大的操作性.

* xfs_extfree_item.c

** xfs_efi_log_format 
   #+begin_src 
	__uint16_t		efi_type;	/* efi log item type */
	__uint16_t		efi_size;	/* size of this item */
	__uint32_t		efi_nextents;	/* # extents to free */
	__uint64_t		efi_id;		/* efi identifier */
	xfs_extent_t		efi_extents[1];	/* array of extents to free */   
   #+end_src

** xfs_extent 
   #+begin_src 
	xfs_dfsbno_t	ext_start;
	xfs_extlen_t	ext_len;   
   #+end_src

** xfs_efi_log_item 
   #+begin_src 
	xfs_log_item_t		efi_item;
	atomic_t		efi_next_extent;
	unsigned long		efi_flags;	/* misc flags */
	xfs_efi_log_format_t	efi_format;   
   #+end_src

** EFI_ITEM(xfs_log_item)
   - 获取xfs_efi_log_item

** xfs_efi_item_free(xfs_efi_log_item)
   - 释放xfs_efi_log_item. xfs_efi_log_format是内嵌的
   - 如果xfs_efi_log_item->xfs_efi_log_format->efi_nextents > XFS_EFI_FAST_EXTENTS, 使用kmalloc分配. 否则是slab分配

** __xfs_efi_release(xfs_efi_log_item)
   - 释放xfs_efi_log_item. 
   - 如果xfs_efi_log_item->efi_flags没有XFS_EFI_COMMITTED, 才释放它. 并且从ail中释放.
   - 否则清除标志,等待下一次释放

** xfs_efi_item_size(xfs_log_item)
   - 只需要一个xfs_log_iovec, 保存xfs_efi_log_format

** xfs_efi_item_format(xfs_log_item, xfs_log_iovec)
   - xfs_log_iovec->i_len是xfs_efi_log_format大小还有xfs_extent数组
   - xfs_efi_log_format->efi_size = 1, 应该是xfs_log_iovec的大小. 在xlog中它对应一个xlog_op_header
   - xfs_log_iovec->i_type = XLOG_REG_TYPE_EFI_FORMAT. 
   - xfs_log_iovec->i_addr指向xfs_efi_log_format

** xfs_efi_item_pin(xfs_log_item)
   - 空函数

** xfs_efi_item_unpin(xfs_log_item)
   - 从xfs_trans中释放xfs_efi_log_item
   > __xfs_efi_releae(xfs_efi_log_item)

** xfs_efi_item_push(xfs_log_item)
   - 返回XFS_ITEM_PINNED??

** xfs_efi_item_unlock(xfs_log_item)
   - 几乎是空函数

** xfs_efi_item_committed(xfs_log_item, xfs_lsn_t)
   - 设置xfs_efi_log_item->efi_flags的XFS_EFI_COMMITTED

** xfs_efi_item_committing(xfs_log_item, xfs_lsn_t)
   - 空函数

** xfs_efi_init(xfs_mount, nextents)
   - 创建xfs_efi_log_item
   - 初始化xfs_log_item
   > xfs_log_item_init(xfs_mount, xfs_log_item, XFS_LI_EFI, xfs_efi_item_ops)
   - 然后是xfs_efi_log_format
   - xfs_efi_item_format->efi_id是xfs_efi_log_item指针. 

** xfs_efi_copy_format(xfs_log_iovec, xfs_efi_log_format)
   - 从xfs_log_iovec中复制到xfs_efi_log_format, 大小段变化

** xfs_efi_release(xfs_efi_log_item, nextents)
   - 使用xfs_efi_log_item->efi_next_extent保护?? 减到0时释放xfs_efi_log_item
   > __xfs_efi_release(xfs_efi_log_item)

** xfs_efd_log_format 
   #+begin_src 
	__uint16_t		efd_type;	/* efd log item type */
	__uint16_t		efd_size;	/* size of this item */
	__uint32_t		efd_nextents;	/* # of extents freed */
	__uint64_t		efd_efi_id;	/* id of corresponding efi */
	xfs_extent_t		efd_extents[1];	/* array of extents freed */  
        //它和xfs_efi_log_item几乎一样
   #+end_src

** xfs_efd_log_item
   #+begin_src 
	xfs_log_item_t		efd_item;
	xfs_efi_log_item_t	*efd_efip;
	uint			efd_next_extent;
	xfs_efd_log_format_t	efd_format;   
   #+end_src

** EFI_ITEM(xfs_log_item)
   - 获取xfs_efd_log_item

** xfs_efd_item_free(xfs_efd_log_item)
   - 和xfs_efi_log_item一样

** xfs_efd_item_size(xfs_log_item)
   - 返回1

** xfs_efd_item_format(xfs_log_item, xfs_log_iovec)
   - 和efi一样

** xfs_efd_item_pin(xfs_log_item)
   - 空函数

** xfs_efd_item_unpin(xfs_log_item, remove)
   - 空

** xfs_efd_item_ush(xfs_log_item)
   - 返回XFS_ITEM_PINNED

** xfs_efd_item_unlock(xfs_log_item)
   - 如果xfs_log_item->li_flags & XFS_LI_ABORTED !=0, 释放xfs_efd_log_item 
   > xfs_efd_item_free(xfs_efd_log_item)

** xfs_efd_item_committed(xfs_log_item, xfs_lsn_t)
   - 如果没有问题XFS_LI_ABORTED, 处理efi
   > xfs_efi_release(xfs_efd_log_item->xfs_efi_log_item, xfs_efd_log_format->efd_nextents)
   - 还是释放xfs_efd_log_item 
   > xfs_efd_item_free(xfs_efd_log_item)
   - 返回-1，所以它不会放到ail中.
   - xfs_efi_log_item回放到ail, 只有对应的efi才会释放它..

** xfs_efd_item_committing(xfs_log_item, xfs_lsn_t)
   - 空函数

** xfs_efd_init(xfs_mount, xfs_efi_log_item, nextents)
   - 构造xfs_efd_log_item

* xfs_trans_extfree.c
   - log extent free intention / extent free done

** xfs_trans_get_efi(xfs_trans, uint nextents)
   - 创建xfs_efi_log_item
   > xfs_efi_init(xfs_mount, nextents)
   - 把它放到xfs_trans中
   > xfs_trans_add_item(xfs_trans, xfs_efi_log_item->xfs_log_item)

** xfs_trans_log_efi_extent(xfs_trans, xfs_efi_log_item, xfs_fsblock_t, xfs_extlen_t)
   - 设置xfs_trans->t_flags的XFS_TRANS_DIRTY
   - xfs_efi_log_item->xfs_log_item->xfs_log_item_desc->lid_flags的XFS_LID_DIRTY
   - 把(xfs_fsblock_t, xfs_extlen_t)保存到xfs_efi_log_format中
   - 使用xfs_efi_log_format->efi_next_extent索引xfs_efi_log_format->efi_extents数组. 原来它才记录xfs_extent的数量

** xfs_trans_get_efd(xfs_trans, xfs_efi_log_item, nextents)
   - xfs_efd_log_item和xfs_efi_log_item很像.
   - 创建xfs_efd_log_item 
   > xfs_efd_init(xfs_trans->xfs_mount, xfs_efi_log_item, nextents)
   - 添加到xfs_trans
   > xfs_trans_add_item(xfs_trans, xfs_efd_log_item->xfs_log_item)

** xfs_trans_log_efd_extents(xfs_trans, xfs_efd_log_item, xfs_fsblock_t, xfs_extlen_t)
   - 把(xfs_fsblock_t, xfs_extlen_t)放到xfs_efd_log_format中. 为何使用xfs_efd_log_format存储数据,而不是xfs_efd_log_item中
   - 设置xfs_trans->t_flags的XFS_TRANS_DIRTY, xfs_efd_log_item->xfs_log_item->xfs_log_item_desc->lid_flags的XFS_LID_DIRTY
   - 使用xfs_efd_log_item->efd_next_extent索引xfs_efd_log_format->efd_nextents数组

** 总结
   - 在bmap操作中使用它, 不仅metadata的extent使用它,file的IO也回使用它.在修改block map时,向写入trans中的efi,最后写入efd  xfs_bmap_finish

