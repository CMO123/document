* xfs_aops.c

** xfs_count_page_state(page, delalloc, unwritten)
   - 检查page的状态
   - 遍历page的buffer_header 
   > page_buffers(page)
   - 检查buffer_head的状态
   - 如果存在BH_Unwritten, unwritten = 1
   > buffer_unwritten(buffer_head)
   - 如果存在BH_Delay, delalloc = 1 
   > buffer_delay(buffer_head)

** xfs_find_bdev_for_inode(inode)
   - 查找inode的数据使用的磁盘
   - 如果是realtime inode，使用xfs_mount->m_rtdev_targp
   - 否则使用xfs_mount->m_ddev_targp->bt_bdev

** xfs_ioend 
   #+BEGIN_SRC 
	struct xfs_ioend	*io_list;	/* next ioend in chain */
	unsigned int		io_type;	/* delalloc / unwritten */
	int			io_error;	/* I/O error code */
	atomic_t		io_remaining;	/* hold count */
	unsigned int		io_isasync : 1;	/* needs aio_complete */
	unsigned int		io_isdirect : 1;/* direct I/O */
	struct inode		*io_inode;	/* file being written to */
	struct buffer_head	*io_buffer_head;/* buffer linked list head */
	struct buffer_head	*io_buffer_tail;/* buffer linked list tail */ //这里使用的buffer_head->b_private链表?
	size_t			io_size;	/* size of the extent */
	xfs_off_t		io_offset;	/* offset in the file */
	struct work_struct	io_work;	/* xfsdatad work queue */
	struct xfs_trans	*io_append_trans;/* xact. for size update */
	struct kiocb		*io_iocb;
	int			io_result;   
   #+END_SRC

** xfs_destroy_ioend(xfs_ioend)
   - IO完成后释放xfs_ioend, 需要释放buffer_head, bio, inode?
   - 遍历io_buffer_head队列的buffer_head 
   > buffer_head->b_end_io(buffer_head, xfs_ioend->io_error)
   - 如果xfs_ioend->io_iocb有效, 才调用回调??
   > inode_dio_done(xfs_ioend->io_inode)
   - 如果是异步, xfs_ioend->io_isasync 
   > aio_complete(xfs_ioend->io_iocb, xfs_ioend->io_result, 0)
   - 这里回唤醒kiocb??
   - 最后释放xfs_ioend 

** xfs_ioend_is_append(xfs_ioend)
   - 检查是否是append io?
   - xfs_ioend->io_offset + io_size > xfs_inode->xfs_icdinode->di_size ?? 

** xfs_setfilesize_trans_alloc(xfs_ioend)
   - 构造xfs_trans 
   > xfs_trans_alloc(xfs_mount, XFS_TRANS_FSYNC_TS)
   - 预留空间, XFS_FSNC_TS_LOG_RES??
   > xfs_trans_reserve(xfs_trans, 0, XFS_FSYNC_TS_LOG_RES(xfs_mount), 0, 0,0)
   - 把上面创建的xfs_trans给xfs_ioend->io_append_trans
   
** xfs_setfilesize(xfs_ioend) 
   - IO完成后释放更新文件大小
   - 锁住inode 
   > xfs_ilock(xfs_inode, XFS_ILOCK_EXCL) 
   - 计算新的文件大小, 它不能超过i_size, 而且必须比di_size大才需要更新??
   - 在a_ops->write中回更新i_size
   > xfs_new_eof(xfs_inode, xfs_ioend->io_offset + io_size)
   - 设置xfs_inode->xfs_icdinode->di_size 
   > xfs_trans_ijoin(xfs_trans, xfs_inode, XFS_ILOCK_EXCL)
   > xfs_trans_log_inode(xfs_trans, xfs_inode, XFS_ILOG_CORE)

** xfs_finish_ioend(xfs_ioend)
   - 释放xfs_ioend的使用计数,如果减为0, 释放资源?
   > atomic_dec_and_test(xfs_ioend->io_remaining) 
   - 如果xfs_ioend->io_type == XFS_IO_UNWRITTEN? 
   > queue_work(xfs_mount->m_unwritten_workqueue, xfs_ioend->io_work)
   - 如果是append IO? 或者directIO 
   > xfs_ioend_is_append(xfs_ioend)
   > queue_work(xfs_mount->m_data_workqueue, xfs_ioend->io_work)
   - 否则直接释放xfs_ioend 
   > xfs_destroy_ioend(xfs_ioend)

** xfs_end_io(work_struct)
   - 参数是xfs_ioend->io_work
   - 什么是XFS_IO_UNWRITTEN, 只分配空间,但没有写数据?
   > xfs_iomap_write_unwritten(xfs_inode, xfs_ioend->io_offset, xfs_ioend->io_size)
   - 如果是direct IO, 修改文件大小? 
   > xfs_setfilesize_trans_alloc(xfs_ioend)
   > xfs_setfilesize(xfs_ioend)
   - 如果只是append? 
   > xfs_setfilesize(xfs_ioend)
   - 最后释放xfs_ioend 
   > xfs_destroy_ioend(xfs_ioend)

** xfs_finish_ioend_sync(xfs_ioend)
   - 释放xfs_ioend->io_remaining计数 
   - 这是同步方式, 直接调用
   > xfs_end_io(xfs_ioend->io_work)

** xfs_alloc_ioend(inode, type)
   - 构造xfs_ioend, 只是设置io_type = type? 

** xfs_bmbt_irec 
   - extent数据, 单位都是  inode->i_blkbits
   #+BEGIN_SRC 
	xfs_fileoff_t	br_startoff;	/* starting file offset */
	xfs_fsblock_t	br_startblock;	/* starting block number */
	xfs_filblks_t	br_blockcount;	/* number of blocks */
	xfs_exntst_t	br_state;	/* extent state */   
   #+END_SRC

** xfs_map_blocks(inode, offset, xfs_bmbt_irec, type, nonblocking)
   - 查找offset对应的extent?
   - 如果type == XFS_IO_UNWRITTEN, 忽略state? XFS_BMAPI_IGSTATE
   - 先锁住inode, 使用XFS_ILOCK_SHARED 
   > xfs_ilock_nowait(xfs_inode, XFS_ILOCK_SHARED)
   - 如果锁不住,而且nonblocking!=0, 返回EAGAIN
   - 否则等待这个锁 
   > xfs_ilock(xfs_inode, XFS_ILOCK_SHARED)
   - 开始查找extent, 范围是(offset, -1)
   - 最大值是super_block->s_maxbytes
   - 转化为FSB 
   > XFS_B_TO_FSB(xfs_mount, offset)
   - 只会返回1个xfs_bmbt_irec
   > xfs_bmapi_read(xfs_inode, offset_fsb, end_fsb-offset_fsb, xfs_bmbt_irec, nimaps, bmapi_flags)
   - 释放xfs_inode的锁 
   > xfs_iunlock(xfs_inode, XFS_ILOCK_SHARED)
   - 如果type是XFS_IO_DELALLOC,而且没有找到xfs_bmbt_irec, 或者找到的是hole 
   > isnullstartblock(xfs_bmbt_irec->br_startblock)
   - 更新btree? 
   > xfs_iomap_write_unwritten(xfs_inode, offset, count, xfs_bmbt_irec)

** xfs_imap_valid(xfs_inode, xfs_bmbt_irec, offset)
   - 验证xfs_bmbt_irec的有效性
   - offset应该在xfs_bmbt_irec->br_startoff和br_blockcount之间
   - 两者单位是什么?  xfs_inode->i_blkbits, 是bb还是fsb?

** xfs_end_bio(bio, error)
   - bio的回调函数
   - 处理bio->bi_private,也就是xfs_ioend
   - 根据bio->bi_flags的BIO_UPTODATE确定io的结果
   - 首先处理bio 
   > bio_put(bio)
   > xfs_finish_ioend(xfs_ioend)

** xfs_submit_ioend_bio(writeback_control, xfs_ioend, bio)
   - 提交bio, 首先配置bio
   - 增加xfs_ioend->io_remaining计数
   - 设置bio->bi_end_io = xfs_end_bio 
   > submit_bio(writeback_control->sync_mode == WB_SYNC_ALL? WRITE_SYNC:WRITE, bio)

** xfs_alloc_ioend_bio(buffer_head)
   - 构造bio, 为何使用多个iovec?
   > bio_get_nr_vecs(buffer_head->b_bdev)
   > bio_alloc(GFP_NOIO, nvecs)
   - 计算bio的起始位置??
   > buffer_head->b_blocknr * buffer_head->b_size >>9

** xfs_start_buffer_writeback(buffer_head)
   - 检查buffer_head的状态，必须是BH_Mapped, BH_Locked 
   - 不能是BH_Delay? BH_Unwritten??
   - 异步写? 通用的函数, 使bio回调通用的函数
   > mark_buffer_async_write(buffer_head)
   - 设置BH_Uptodate, 清除BH_Dirty 
   > set_buffer_uptodate(buffer_head)
   > clear_buffer_dirty(buffer_head)
   - 没有衍生的操作? 比如修改计数?

** xfs_start_page_writeback(page, clear_dirty, buffers)
   - 写回page? 检查page的状态
   - 必须有PG_locked, 而且没有PG_writeback
   - 如果clear_dirty !=0, 修改标志 
   > clear_page_dirty_for_io(page)
   - 准备启动bio 
   > set_page_writeback(page)
   > unlock_page(page)
   - 如果buffers ==0, 没有必要IO? 
   > end_page_writeback(page)

** bio_add_buffer(bio, buffer_head)
   - 向bio中增加iovec
   > bio_add_page(bio, buffer_head->b_page, buffer_head->b_size, bh_offset(buffer_head))

** xfs_submit_ioend(writeback_control, xfs_ioend, fail)
   - xfs_ioend是单链表, 使用xfs_ioend->io_list
   - 遍历每个xfs_ioend中的buffer_head
   - 修改buffer_head的标志
   > xfs_start_buffer_writeback(buffer_head)
   - 再次遍历, 提交bio 
   - 首先分配bio
   > xfs_alloc_ioend_bio(buffer_head)
   - 后续的buffer_head可以合并到这里
   > bio_add_buffer(bio, buffer_head)
   - 如果无法合并,先提交之前的io, 创建新的 
   > xfs_submit_ioend_bio(writeback_control, xfs_ioend, bio)

** xfs_cancel_ioend(xfs_ioend)
   - 释放xfs_ioend中的buffer_head 
   > clear_buffer_async_write(buffer_head)
   > unlock_buffer(buffer_head)
   - 直接释放xfs_ioend

** xfs_add_to_ioend(inode, buffer_head, xfs_off_t, type, xfs_ioend, need_ioend)
   - 把buffer_head添加到xfs_ioend管理中
   - 首先检查buffer_head能否放到参数中
   - need_ioend ==0, 而且type == xfs_ioend->io_type
   - 把buffer_head放到xfs_ioend->io_buffer_tail中, 果然使用buffer_head->b_private
   - 否则创建新的xfs_ioend 
   > xfs_alloc_ioend(inode, type)
   - 设置xfs_ioend->io_offset 为参数offset
   - 并且把xfs_ioend放到参数的xfs_ioend->io_list链表中
   - 还要增加xfs_ioend->io_size += buffer_head->b_size 

** xfs_map_buffer(inode, buffer_head, xfs_bmbt_irec, xfs_off_t)
   - 根据xfs_bmbt_irec计算buffer_head的磁盘位置
   - xfs_off_t是文件偏移,以字节为单位, 同样转换xfs_bmbt_irec->br_startoff 
   > XFS_FSB_TO_B(xfs_mount, xfs_bmbt_irec->br_startoff)
   - 磁盘位置先转化为磁盘绝对位置, 以BB为单位, fsb包含agno,agbno 
   > xfs_fsb_to_db(xfs_inode, xfs_bmbt_irec->br_startblock)
   - 然后根据文件位置做偏移,转化为inode->i_blkbits为单位, 应该是sectorsize?
   - 设置buffer_head->b_blocknr
   - 设置BH_Mapped

** xfs_map_at_offset(inode, buffer_head, xfs_bmbt_irec, xfs_off_t)
   - 影射buffer_head的磁盘位置  
   > xfs_map_buffer(inode, buffer_head, xfs_bmbt_irec, xfs_off_t)
   - 有设置BH_Mapped? 
   - 去掉BH_Delay, BH_Unwritten

** xfs_check_page_type(page, type)
   - 检查page是否和type一致??
   - 如果paeg在写回PG_writeback, 返回0
   - 如果page有buffer_head, 遍历它的buffer_head
   > page_has_buffers(page)
   - XFS_IO_UNWRITTEN要求BH_Unwritten
   - XFS_IO_DELALLOC要求BH_Delay
   - XFS_IO_OVERWRITE要求BH_Mapped
   - 只有存在和type对应的buffer_head时才返回1

** xfs_convert_page(inode, page, loff_t, xfs_bmbt_irec, xfs_ioend, writeback_control)
   - 为page构造buffer_head, 并影射磁盘信息 
   - 只处理delalloc/unwritten的page
   - 先检查page状态
   - page->index == loff_t, 文件偏移
   - 锁住page, PG_lock, 如果有PG_writeback, 返回
   - 检查io类型 
   > xfs_check_page_type(page, xfs_ioend->io_type)
   - 计算需要IO的buffer_head的个数, 每个处理的长度是inode->i_blkbits?
   - 只有文件的最后一个page需要处理 
   - end_offset = min((page->index + 1) <<PAGE_CACHE_SHIFT, i_size_read(inode))
   - 检查extent信息
   > xfs_imap_valid(inode, xfs_bmbt_irec, end_offset)
   - buffer_head的个数是 end_offset & PAGE_CACHE_SHIFT >> inode->i_blkbits
   - 遍历它的buffer_head
   - 如果page/buffer_head都不是有效的,PG_uptodate/BH_Uptodate, 不处理?
   - 只处理3种buffer_head, BH_Unwritten/BH_Delay/BH_Mapped
   > xfs_imap_valid(inode, xfs_bmbt_irec, offset)
   - 对于BH_Unwritten, 使用io_type是XFS_IO_UNWRITTEN
   - 对于BH_Delay, 使用io_type是XFS_IO_DELALLOC
   - 其他使用XFS_IO_OVERWRITE
   - 影射buffer_head的磁盘位置 
   > xfs_map_at_offset(inode, buffer_head, xfs_bmbt_irec, offset)
   - 提交bio
   > xfs_add_to_ioend(inode, buffer_head, offset, type, xfs_ioend, done)
   - 最后可以更新page的PG_uptodate
   - 释放page的锁, 修改状态
   > xfs_start_page_writeback(page, !page_dirty, count)

** xfs_cluster_write(inode, pgoff_t tindex, xfs_bmbt_irec, writeback_control, pgoff_t tlast)
   - 处理(tindex,tlast)之间的page, 属于同一个extent?
   - 循环处理, 先在address_space中查找 
   > pagevec_lookup(page, inode->address_space, tindex, len)
   - 然后提交所有的page 
   > xfs_convert_page(inode, page, tindex, xfs_bmbt_irec, xfs_ioend, writeback_control)
   - 这样也积累了一个队列的xfs_ioend 

** xfs_vm_invalidatepage(page, offset, length)
   - 释放address_space中的page 
   > block_invalidatepage(page, offset, length)

** xfs_aops_discard_page(page)
   - 检查page是否有delalloc的buffer_head
   > xfs_check_page_type(page, XFS_IO_DELALLOC)
   - 遍历page的buffer_header, 只处理BH_Delay的
   - 为何合理处理整个page的偏移??
   > XFS_B_TO_FSB(xfs_mount, offset)
   > xfs_bmap_punch_delalloc_range(xfs_inode, start_fsb, 1)
   - 释放pagecache 
   > xfs_vm_invalidatepage(page, 0, PAGE_CACHE_SIZE)

** xfs_vm_writepage(page, writeback_control)
   - 这是address_space的回调函数, 把page写回磁盘
   - 对于BH_Delay, 需要分配空间, 然后发送bio
   - 对于BH_Unwritten, 需要做什么?? 
   - 其他的只需要发送bio
   - 检查current->flags的PF_FSTRANS, 不能在transaction中操作??
   - 如果处理文件最有一个page,需要清空文件大小之外的数据 i_size
   - 遍历所有的buffer_head
   - 检查BH_Uptodate, 如果所有的buffer_head都有,才设置PG_uptodate
   - 如果没有BH_Mapped,但有BH_Uptodate? 放到后面处理?
   - 检查buffer_head的状态, 确定对应的io_type
   - 如果和前一个io_type一样,不需要重新获取xfs_bmbt_irec, 否则需要 
   > xfs_map_blocks(inode, offset, xfs_bmbt_irec, type, noblocking) 
   - 验证offset是否在xfs_bmbt_irec里面
   > xfs_imap_valid(inode, xfs_bmbt_irec, offset)
   - 如果xfs_bmbt_irec可用, 计算buffer_head的磁盘位置  
   > xfs_map_at_offset(inode, buffer_head, xfs_bmbt_irec, offset)
   - 把它给xfs_ioend 
   > xfs_add_to_ioend(inode, buffer_head, offset, type, xfs_ioend, new_ioend)
   - 设置page状态 
   > xfs_start_page_writeback(page, 1, count)
   - 然后提交page后面的数据??
   > xfs_cluster_write(inode, page->index+1, xfs_bmbt_irec, xfs_ioend, writeback_control, end_index)
   - 构造log, 为修改文件大小准备? 
   - xfs_ioend->io_type != XFS_IO_UNWRITTEN, 而且是append 
   > xfs_ioend_is_append(xfs_ioend)
   > xfs_setfilesize_trans_alloc(xfs_ioend)
   - 提交xfs_ioend 
   > xfs_submit_ioend(writeback_control, xfs_ioend, err)

** xfs_vm_writepages(address_space, writeback_control)
   - 去掉xfs_inode->i_flags的XFS_ITRUNCATED?? 
   > xfs_iflags_clear(xfs_inode, XFS_ITRUNCATED) 
   - 使用vfs接口处理 
   > generic_writepages(address_space, writeback_control)

** xfs_vm_releasepage(page, gfp_t)
   - 检查page是否可以释放? 
   > xfs_count_page_state(page, delalloc, unwritten)
   - 如果是delaye/unwritten, 不可以释放? 
   - 然后检查buffer_head 
   > try_to_free_buffers(page)

** __xfs_get_blocks(inode, sector_t offset, buffer_head, craete, direct)
   - 分配block?
   - 如果create==0, direct==1, 而且offset超过i_size, 返回0??
   - 锁住inode
   - 如果create ==1, 而且direct==0, 这时普通buffered的IO?
   - 使用XFS_ILOCK_EXCL 
   > xfs_ilock(xfs_inode, XFS_ILOCK_EXCL)
   - 否则,根据extent状态而定  
   > xfs_ilock_map_shared(xfs_inode)
   - 把所有的文件位置/大小转化为字节?
   - 参数sector_t 单位是inode->i_blkbits, buffer_head->b_size单位是字节
   - 然后转化为fsb, 单位是xfs_sb->sb_blocklog
   > XFS_B_TO_FSB(xfs_mount, offset)
   - fsb的位置和大小是2回事, 位置包含agno,agbno, 大小直接是以sb_blocklog为单位的数量
   - 获取xfs_bmbt_irec 
   > xfs_bmapi_read(inode, offset_fsb, end_fsb-offset_fsb, xfs_bmbt_irec, nimaps, XFS_BMAPI_ENTIRE)
   - 如果没有找到xfs_bmbt_irec, 而且create==1, 需要创建extent ?
   - xfs_bmbt_irec->br_startblock是HOLESTARTBLOCK|DELAYSTARTBLOCK
   - 如果是direct, 或者hint? 
   > xfs_get_extsz_hint(xfs_inode)
   - 然后iomap怎么了??
   > xfs_iomap_write_direct(xfs_inode, offset, size, xfs_bmbt_irec, nimaps)
   - 否则是delay分配? 
   > xfs_iomap_write_delay(xfs_inode, offset, size, xfs_bmbt_irec)
   - 如果create==0, 而且没有找到xfs_bmbt_irec?? 直接退出??
   - 然后准备新的xfs_bmbt_irec?
   - 如果xfs_bmbt_irec的磁盘位置不是hole/delay, 映射buffer_head? 
   > xfs_map_buffer(inode, buffer_head, xfs_bmbt_irec, offset)
   - 如果xfs_bmbt_irec->br_state是XFS_EXT_UNWRITTEN, 设置buffer_head 
   > set_buffer_unwritten(buffer_head)
   - 查找block_dev 
   > xfs_find_bdev_for_inode(inode)
   - 如果create ==1, 而且block是之前分配的, 设置BH_New
   - 为何没有BH_Mapped, BH_Uptodate就是新的??
   - offset超过文件大小就是新的?
   - xfs_bmbt_irec是hole,或者state==unwritten, 也是新的
   > set_buffer_new(buffer_head)
   - 如果xfs_bmbt_irec是DELAYSTARTBLOCK? 设置buffer_head 
   > set_buffer_uptodate(buffer_head)
   > set_buffer_mapped(buffer_head)
   > set_buffer_delay(buffer_head)
   - 最后要更新buffer_head->b_size ? 不能超过xfs_bmbt_irec

** xfs_get_blocks(inode, sector_t iblock, buffer_head, create)
   - buffered的io 
   > __xfs_get_blocks(inode, iblock, buffer_head, create, 0)

** xfs_get_blocks_direct(inode, sector_t iblock, buffer_head, create)
   > __xfs_get_blocks(inode, iblock, buffer_head, create, 1)

** xfs_end_io_direct_write(kiocb, loff_t offset, size, private)
   - 更新inode->i_size, 怎么在这里更新?
   > i_size_write(xfs_ioend->io_inode, offset + size)
   - 如果private !=0, 而且size>0, 设置xfs_ioend->io_type = XFS_IO_UNWRITTEN
   > xfs_finish_ioend_sync(xfs_ioend)

** xfs_vm_direct_IO(rw, kiocb, iovec, offset, nr_segs)
   - 如果rw是WRITE, 准备xfs_ioend 
   > xfs_alloc_ioend(inode, XFS_IO_DIRECT)
   - 如果写的范围超过文件大小, 设置xfs_ioend->io_isdirect =1 
   > __blockdev_direct_IO(rw, kiocb, inode, block_device, iovec, offset, nr_segs, xfs_get_blocks_direct, xfs_end_io_direct_write, NULL, 0)
   - 对于READ? 
   > __block_direct_IO(rw, kiocb, inode, block_device, iovec, offset, nr_segs, xfs_get_blocks_direct, NULL, NULL, 0)

** xfs_vm_kill_delalloc_range(inode, start, end)
   - 释放delalloc的磁盘空间?
   - 锁住inode 
   > xfs_ilock(xfs_inode, XFS_ILOCK_EXCL)
   > xfs_bmap_punch_delalloc_range(xfs_inode, start_fsb, end_fsb-offset_fsb)

** xfs_vm_write_failed(inode, page, pos, len)
   - write的错误处理函数?
   - 遍历page的buffer_header
   > xfs_vm_kill_delalloc_range(inode, block_offset, block_offset + buffer_head->b_size)

** xfs_vm_write_begin(file, address_space, pos, len, flags, page, fsdata)
   - 获取page  
   > grab_cache_page_write_begin(address_space, index, flags)
   - 准备block? 
   > __block_write_begin(page, pos, len, xfs_get_blocks)

** xfs_vm_write_end(file, address_space, loff_t pos, len, copied, page, fsdata)
   - 还是使用vfs的接口函数 
   > generic_write_end(file, address_space， pos, len, copied, page, fsdata)

** xfs_vm_bmap(address_space, sector_t block)
   - 锁住xfs_inode, XFS_IOLOCK_SHARED
   > xfs_ilock(xfs_inode, XFS_IOLOCK_SHARED)
   - flush pagecache? 
   > filemap_write_and_wait(address_space)
   - 然后映射?? 
   > generic_block_bmap(address_space, block, xfs_get_blocks)

** xfs_vm_readpage(file, page)
   > mpage_readpage(page, xfs_get_blocks)

** xfs_vm_readpages(file, address_space, list_head, nr_pages)
   - 都使用vfs接口
   > mpage_readpages(address_space, list_head, nr_pages, xfs_get_blocks)

* xfs_iomap.c

** xfs_iomap_eof_align_last_fsb(xfs_mount, xfs_inode, xfs_extlen_t extsize, xfs_fileoff_t last_fsb)
   - 处理文件的eof? last_fsb
   - 首先使用xfs_mount->swidth或xfs_mount->d_dalign对齐
   - 如果eof超过align 
   > XFS_ISIZE(xfs_inode)
   - 然后对齐extsize?? 
   - 修改什么? 
   > xfs_bmap_eof(xfs_inode, new_last_fsb, XFS_DATA_FORK, eof)
  
** xfs_alert_fsblock_zero(xfs_inode, xfs_bmbmt_irec)
   - 调式信息, 输出xfs_bmbt_irec的信息  

** xfs_bmap_free_item 
   #+BEGIN_SRC 
	xfs_fsblock_t		xbfi_startblock;/* starting fs block number */
	xfs_extlen_t		xbfi_blockcount;/* number of blocks in extent */
	struct xfs_bmap_free_item *xbfi_next;	/* link to next entry */   
   #+END_SRC

** xfs_bmap_free
   #+BEGIN_SRC 
	xfs_bmap_free_item_t	*xbf_first;	/* list of to-be-free extents */
	int			xbf_count;	/* count of items on list */
	int			xbf_low;	/* alloc in low mode */   
   #+END_SRC

** xfs_iomap_write_direct(xfs_inode, xfs_off_t offset, size_t count, xfs_bmbt_irec, nmaps)
   - 要写的数据是(offset, count), 如果超过eof, 校正eof? 
   - 获取hint extent size 
   > xfs_get_extsz_hint(xfs_inode)
   - offset + count > XFS_ISIZE(xfs_inode)
   > xfs_iomap_eof_align_last_fsb(xfs_mount, xfs_inode, extsz, last_fsb)
   - 如果对应的xfs_bmbt_irec表示范围是hole, 限制操作范围
   - 校正文件范围,起始位置和长度都要对extsz对齐
   - 创建xfs_trans 
   > xfs_trans_alloc(xfs_mount, XFS_TRANS_DIOSTRAT)
   - 预留空间 
   > xfs_trans_reserve(xfs_trans, resblks, XFS_WRITE_LOG_RES(xfs_mount), resrtextents, XFS_TRANS_PERM_LOG_RES, XFS_WRITE_LOG_COUNT)
   - 锁住inode ? 
   > xfs_ilock(xfs_inode, XFS_ILOCK_EXCL)
   > xfs_trans_ijoin(xfs_trans, xfs_inode, 0)
   - 初始化xfs_bmap_free? 
   > xfs_bmap_init(xfs_bmap_free, firstfsb)
   - 获取xfs_bmbt_irec?? 
   > xfs_bmapi_write(xfs_trans, xfs_inode, offset_fsb, count_fsb, bmapi_flags, firstfsb, 0, xfs_bmbt_irec, nimaps, free_list)
   - 结束transaction 
   > xfs_trans_commit(xfs_trans, XFS_TRANS_RELEASE_LOG_RES)

** xfs_iomap_eof_want_preallocate(xfs_mount, xfs_inode, xfs_off_t offset, size_t count, xfs_bmbt_irec, nimaps, prealloc)
   - 在写操作增加eof时,检查是否能预分配空间? 设置结果给prealloc?
   - 如果写的范围没有超过eof, 直接返回
   - 如果offset + count <= XFS_ISIZE(xfs_inode)
   - 如果prealloc有限制, xfs_mount使用XFS_MOUNT_DFLT_IOSIZE
   - 如果文件太小, 小于xfs_mount->m_writeio_blocks, 直接返回0
   - 读取文件的extent, 检查是否已经有空间? 
   - 在offset+count之后的
   > xfs_bmapi_read(xfs_inode, start_fsb, count_fsb, xfs_bmbt_irec, imaps, 0)
   - 遍历读取的xfs_bmbt_irec, 如果xfs_bmbt_irec->br_startblock不是HOLDSTARTBLOCK/DELAYSTARTBLOCK,直接返回
   - 如果xfs_bmbt_irec->br_startblock是DELAYSTARTBLOCK, 找到delalloc?
   - 只有找不到xfs_bmbt_irec, 或者找到的都是HOLDSTARTBLOCK, 才能设置prealloc=1

** xfs_iomap_eof_prealloc_initial_size(xfs_mount, xfs_inode, xfs_off_t offset, xfs_bmbt_irec, nimaps)
   - 计算与分配的空间?
   - 如果xfs_mount->m_flags有XFS_MOUNT_DFLT_IOSIZE, 使用特定的大小
   - 如果文件太小, 不超过xfs_mount->m_dalign, 使用默认的
   - 查找xfs_bmbt_irec 
   > xfs_bmapi_read(xfs_inode, start_fsb, 1, xfs_bmbt_irec, imaps, XFS_BMAPI_ENTIRE)
   - 如果xfs_bmbt_irec->br_startblock是HOLDSTARTBLOCK, 返回0? 使用默认的?
   - 如果xfs_bmbt_irec->br_blockcount <= MAXEXTLEN/2, 返回xfs_bmbt_irec->br_blockcount * 2 ??
   - 否则返回offset???

** xfs_quota_calc_throttle(xfs_inode, type, xfs_fsblock_t, qshift)

** xfs_iomap_prealloc_size(xfs_mount, xfs_inode, xfs_off_t, xfs_bmbt_irec, nimaps)
   - 首先检查是否使用变化的prealloc size 
   > xfs_iomap_eof_prealloc_initial_size(xfs_mount, xfs_inode, offset, xfs_bmbt_irec, nimaps)
   - 如果返回0, 使用固定的大小
   - 否则使用上面返回的alloc_blocks,计算适当的值
   - 检查文件系统的剩余空间, 如果越少,越少分配 
   - xfs_sb->sb_fdblocks, 标准是xfs_mount->m_low_space[5]
   - 根据上面的条件,缩小alloc_blocks
   - 同时它还不能超过文件系统剩余空间, 否则需要缩小4倍,16倍..
   - 最后默认的,也是最小的是xfs_mount->m_writeio_blocks

** xfs_iomap_write_delay(xfs_inode, xfs_off_t, size_t, xfs_bmbt_irec)
   - 首先获取extent hint? 
   > xfs_get_extsz_hint(xfs_inode)
   - 校正eof ? 
   > xfs_iomap_eof_want_preallocate(xfs_mount, xfs_inode, offset, count, xfs_bmbt_irec, XFS_WRITE_IMAPS, prealloc)
   - 如果需要预分配? 检查与分配的空间?? 
   > xfs_iomap_prealloc_size(xfs_mount, xfs_inode, offset, xfs_bmbt_irec, XFS_WRITE_IMAPS)
   - 然后构造extent? 
   > xfs_bmapi_delay(xfs_inode, offset_fsb, last_fsb-offset_fsb, xfs_bmbt_irec, nimaps, XFS_BMAPI_ENTIRE)
   - 最后设置xfs_inode标志? 
   > xfs_inode_set_eofblocks_tag(xfs_inode)

** xfs_iomap_write_allocate(xfs_inode, xfs_off_t, size_t, xfs_bmbt_irec)
   - 把delayed的extent,转化为已经使用的extent?
   - 首先准备xfs_trans 
   > xfs_trans_alloc(xfs_mount, XFS_TRNS_STRAT_WRITE)
   - 预留空间?? 
   > xfs_trans_reserve(xfs_trans, nres, XFS_WRITE_LOG_RES(xfs_mount), 0, XFS_TRANS_PERM_LOG_RES, XFS_WRITE_LOG_COUNT)
   - 为何要锁住xfs_inode, 才能设置trans? 
   > xfs_trans_ijoin(xfs_trans, xfs_inode, 0)
   - 初始化xfs_bmap_free? 
   > xfs_bmap_init(xfs_bmap_free, first_block)
   - 计算last_block?? 
   > xfs_bmap_last_offset(NULL, xfs_inode, last_block, XFS_DATA_FORK)
   - 修改extent数据?
   > xfs_bmapi_write(xfs_trans, xfs_inode, map_start_fsb, count_fsb, XFS_BMAPI_STACK_SWITCH, first_block, 1, xfs_bmbt_irec, nimaps, xfs_bmap_free)
   - 结束transaction
   > xfs_bmap_finish(xfs_trans, xfs_bmap_free, committed)
   - 提交transaction 
   > xfs_trans_commit(xfs_trans, XFS_TRANS_RELEASE_LOG_RES)
   - 需要循环处理, 直到(offset, count)范围内的extent都处理掉

** xfs_iomap_write_unwritten(xfs_inode, xfs_off_t offset, size_t count)
   - 和上面很想,循环处理(offset, count)内的xfs_bmbt_irec
   > _xfs_trans_alloc(xfs_mount, XFS_TRANS_STRAT_WRITE, KM_NOFS)
   > xfs_trans_reserve(xfs_trans, resblks, XFS_WRITE_LOG_RES(xfs_mount), 0, XFS_TRANS_PERM_LOG_RES, XFS_WRITE_LOG_COUNT)
   > xfs_bmapi_init(xfs_bmap_free, firstfsb)
   > xfs_bmapi_write(xfs_trans, xfs_inode, offset_fsb, count_fsb, XFS_BMAPI_CONVERT, firstfsb, ..)
   - 如果改变文件大小 
   > xfs_new_eof(xfs_inode, i_size)
   - 需要使用trans改变xfs_dinode 
   > xfs_trans_log_inode(xfs_trans, xfs_inode, XFS_ILOG_CORE)

* xfs_bmap.c 
  - bmap tree

** xfs_bmdr_block 
   - 这是数据节点使用的,后面是(key,value)点对
   - 这个在xfs_dinode的fork中
   #+BEGIN_SRC 
	__be16		bb_level;	/* 0 is a leaf */
	__be16		bb_numrecs;	/* current # of data records */   
   #+END_SRC

** xfs_btree_block 
   - 每个btree节点使用的block使用的数据结构
   #+BEGIN_SRC 
	__be32		bb_magic;	/* magic number for block type */
	__be16		bb_level;	/* 0 is a leaf */
	__be16		bb_numrecs;	/* current # of data records */

	__be64		bb_leftsib;
	__be64		bb_rightsib;

	__be64		bb_blkno;
	__be64		bb_lsn;
	uuid_t		bb_uuid;
	__be64		bb_owner;
	__le32		bb_crc;
	__be32		bb_pad; /* padding for alignment */
   
   #+END_SRC

** xfs_bmbt_key 
   - btree中节点使用的key, 分支指针使用磁盘块指针 
   - xfs_bmbt_ptr_t, xfs_bmdr_ptr_t

   #+BEGIN_SRC 
	__be64		br_startoff;	/* starting file offset */   
   #+END_SRC


** xfs_bmap_compute_maxlevels(xfs_mount, whichfork)
   - 计算btree高度的最大值, 首先计算可能的叶子节点的最大值
   - 对于data fork, 记录项最多是MAXEXTNUM, signed int
   - 对于attr fork, 记录项最多MAXAEXTNUM, signed short
   - 叶子节点或内部节点的最小分支是xfs_mount->m_bmap_dmnr[2]
   - 然后计算btree是最小分支时的高度
   - 最后一个节点必须比跟节点小
   - maxrootrecs = xfs_bmdr_maxrecs(xfs_mount, sz, 0)
   - (sz-sizeof(xfs_bmdr_block_t) / (sizeof(xfs_bmdr_key_t) + sizeof(xfs_bmdr_ptr_t))
   - sz表示data fork或attr fork的最小空间
   > XFS_BMDR_SPACE_CALC(MINDBPTRS) / MINADBPTRS
   - 为何不直接使用这2个宏??

** xfs_fsb_to_db(xfs_inode, xfs_fsblock_t)
   - 把fsb指针转化为磁盘绝对地址
   > XFS_FSB_TO_DADDR(xfs_mount, fsb)
   - 它先分解成agno, agbno, 然后对ag的起始地址做偏移
   > XFS_AGB_TO_ADDR(XFS_FSB_TO_AGNO(xfs_mount, fsbno), XFS_FSB_TO_AGBNO(xfs_mount, fsbno)
   - fsb指针单位是fsb, xfs_mount->m_blkbb_log

** xfs_bmbt_lookup_eq(xfs_btree_cur, xfs_fileoff_t off, xfs_fsblock_t bno, xfs_filblks_t len, stat)
   - btree查找可以精确到记录? 还是到叶子节点?
   - 设置xfs_btree_cur->xfs_bmbt_irec的startoff/startblock/blockcount
   - 为何要都设置? 查找是否存在对应的xfs_bmbt_irec? 
   > xfs_btree_lookup(xfs_btree_cur, XFS_LOOKUP_EQ, stat)
  
** xfs_bmbmt_lookup_ge(xfs_btree_cur, xfs_fileoff_t, xfs_fsblock_t, xfs_filblks_t, stat)
   - 设置xfs_btree_cur, 查找btree 
   > xfs_btree_lookup(xfs_btree_cur, XFS_LOOKUP_GE, stat)

** xfs_bmap_needs_btree(xfs_inode, whichfork)
   - 当前是extent数组,才能转化成btree
   - 检查xfs_icdinode->di_format/di_aformat, XFS_IFORK_FORMAT(xfs_inode, whichfork) == XFS_DINODE_FMT_EXTENTS
   - 而且extent数量超过限制 
   > XFS_IFORK_NEXTENTS(xfs_inode, whichfork)
   > XFS_IFORK_MAXEXT(xfs_inode, whichfork)

** xfs_bmap_wants_extents(xfs_inode, whichfork)
   - 当前使用btree存储数据,转为extent
   - 当前xfs_icdinode->di_format/di_aformat使用XFS_DINODE_FMT_BTREE
   > XFS_IFORK_FORMAT(xfs_inode, whichfork)
   - 而且extent低于限制 
   > XFS_IFORK_MAXEXT(xfs_inode, whichfork)

** xfs_bmbt_update(xfs_btree_cur, xfs_fileoff_t, xfs_fsblock_t, xfs_filblks_t, xfs_exntst_t)
   - 使用xfs_btree_cur转移数据
   > xfs_bmbt_disk_set_allf(xfs_bmbt_cur->xfs_bmbt_irec, off, bno, len, state)
   - 写给btree 
   > xfs_btree_update(xfs_btree_cur, xfs_btree_rec)
   - xfs_bmbt_irec中数据单位应该都是fsb

** xfs_bmap_worst_indlen(xfs_inode, xfs_filblks_t len)
   - len是什么长度?
   - 计算最坏情况下btree节点使用的block的个数?
   - len / xfs_mount->m_bmap_dmxr[0] ?? 

** xfs_default_attroffset(xfs_inode)
   - 计算xfs_dinode中attr fock的默认开始位置
   - 如果xfs_sb->sb_inodesize == 256, 只会留下2个节点的btree根结点使用的空间
   > XFS_LITINO(xfs_mount, xfs_icdinode->di_version) - XFS_BMDR_SPACE_CALC(MINABTPTRS)
   - 否则偏移为包含MINABTPTRS*6个记录的根结点的空间,给data fork使用
   > XFS_BMDR_SPACE_CALC( 6 * MINABTPTRS)

** xfs_bmap_forkoff_reset(xfs_mount, xfs_inode, whichfork)
   - 如果参数whichfork是XFS_ATTR_FORK
   - 而且data fork使用XFS_DINODE_FMT_EXTENTS/XFS_DINODE_FMT_LOCAL
   - 重新计算attr fork的空间 dfl_forkoff
   > xfs_default_attroffset(xfs_inode) 
   - 只有偏移扩大时才设置
   - xfs_inode->icdinode->di_forkoff = dfl_forkoff / 8 

** xfs_bmap_count_leaves(xfs_ifork, xfs_extnum_t idx, numrecs, count)
   - 统计xfs_ifork中(idx, numrecs)范围内的xfs_bmbt_rec_host, 影射的磁盘总量
   - 获取这些xfs_bmbt_rec_host 
   > xfs_iext_get_ext(xfs_ifork, idx)
   - 只抽取blockcount
   > xfs_bmbt_get_blockcount(xfs_bmbt_rec_host)
   - 这些xfs_bmbt_rec_host管理分配的磁盘空间??

** xfs_bmap_disk_count_leaves(xfs_mount, xfs_btree_block, numrecs, count)
   - xfs_btree_block指向一个叶子节点
   - 取出这个叶子节点的(numrecs, count)范围内的xfs_bmbt_rec
   > XFS_BMBT_REC_ADDR(xfs_mount, xfs_btree_block, idx)
   - 叶子节点xfs_btree_block后面就是xfs_btree_block数组
   - 累加blockcount 
   > xfs_bmbt_disk_get_blockcount(xfs_btree_block)

** xfs_bmap_count_tree(xfs_mount, xfs_trans, xfs_ifork, xfs_fsblock_t blockno, levelin, count)
   - 这个函数用来统计xfs_ifork占用的磁盘空间,不仅包括btree
   - 还有数据叶子节点影射的空间
   - bno指向的block是btree的节点
   > xfs_btree_read_bufl(xfs_mount, xfs_trans, bno, 0, xfs_buf, XFS_BMAP_BTREE_REF, xfs_bmbt_buf_ops)
   - 从xfs_buf中获取xfs_btree_block 
   > XFS_BUF_TO_BLOCK(xfs_trans)
   - level表示父节点的高度
   - 如果level >1, 这是内部节点
   - 使用xfs_btree_block->bb_u->l->bb_rightsib遍历这一层的所有节点
   > xfs_btree_read_bufl(xfs_mount, xfs_trans, nextbno, 0, xfs_buf, XFS_BMAP_BTREE_REF, xfs_bmbt_buf_ops)
   - 这里不会使用xfs_buf, 立刻释放
   > xfs_trans_brelse(xfs_trans, xfs_buf)
   - 这种遍历只是统计内部节点的个数
   - 然后处理下一层,获得第一个ptr的值, bno
   > XFS_BMBT_PTR_ADDR(xfs_mount, block, 1, xfs_mount->m_bmap_dmxr[1])
   - key和ptr是严格分开的,最大的分支数已经确定
   - 统计下一层节点个数和叶子节点影射的磁盘数量
   - xfs_bmap_count_tree(xfs_mount, xfs_trans, xfs_ifork, bno, level, count)
   - 如果level ==1, 当前节点是叶子节点
   - 还是根据xfs_btree_block->bb_u->l->bb_rightsib遍历最下层的节点
   - 针对每个节点分支, 统计影射的磁盘的总量 
   > xfs_bmap_disk_count_leaves(xfs_mount, xfs_btree_block, numrecs, count)
   - 使用count传递总数,这里还得添加叶子节点的1
   - 然后读取下一个兄弟节点 
   > xfs_btree_read_bufl(xfs_mount, xfs_trans, bno, 0, xfs_buf, XFS_BMAP_BTREE_REF, xfs_bmbt_buf_ops)
   > XFS_BUF_TO_BLOCK(xfs_buf)

** xfs_bmap_sanity_check(xfs_mount, xfs_buf)
   - xfs_buf里面是xfs_btree_block
   - 检查magic, level
   - numrecs !=0, 也不超过最大分支xfs_mount->m_bmap_dmxr[level!=0]

** xfs_bmap_get_bp(xfs_btree_cur, xfs_fsblock_t bno)
   - 查找xfs_btree_cur中和bno对应的xfs_buf?
   - 首先查找xfs_btree_cur->bc_bufs, 它应该是是从跟到叶子节点的路径
   - 然后遍历xfs_btree_cur->bc_tmp->t_items
   - 查找里面的xsf_buf_log_item 
   > XFS_BUF_ADDR(xfs_buf)

** xfs_check_block(xfs_btree_block, xfs_mount, root, sz)
   - xfs_btree_block是btree的内部节点
   - 检查key是否是有序的
   - 检查ptr是否有重复的
   - 如果不满足,说明文件系统崩溃.. 
   - xfs_btree_block可能是根节点,在fork数据中
   > XFS_BMBT_KEY_ADDR(xfs_mount, xfs_btree_block, i)
   > XFS_BMAP_BROOT_PTR_ADDR(xfs_mount, xfs_btree_block, i, sz)
   > XFS_BMAP_PTR_ADDR(xfs_mount, xfs_btree_block, i, dmxr)
   - (key,value)的点对数 
   > xfs_btree_get_numrecs(xfs_btree_block)

** xfs_bmap_check_leaf_extents(xfs_btree_cur, xfs_inode, whichfork)
   - 检查xfs_btree_cur中btree节点的数据有效性
   - xfs_ifork使用XFS_DINODE_FMT_BTREE, attr fork操作都是用这些?
   - 获取xfs_ifork中的跟节点xfs_btree_block, xfs_ifork->if_broot
   - 这里xfs_btree_block的数据结构是带大端的
   - 检查根结点的成员, level,key,value
   > xfs_check_block(xfs_btree_block, xfs_mount, 1, xfs_ifork->if_broot_bytes)xo
   - 然后检查btree的叶子节点的数据有效性
   -这里没有全部遍历内部节点
   - 首先找到第一个叶子节点,使用内部节点的第一个分支
   - 先取出xfs_buf
   > xfs_bmap_get_bp(xfs_btree_cur, XFS_FSB_TO_DADDR(xfs_mount, bno))
   > xfs_btree_read_bufl(xfs_mount, NULL, bno, 0, xfs_buf, XFS_BMAP_BTREE_REF, xfs_bmbt_buf_ops)
   - 获取xfs_btree_block 
   > XFS_BUF_TO_BLOCK(xfs_buf)
   - 检查成员的有效性 
   > xfs_check_block(xfs_btree_block, xfs_mount, 0, 0)
   - 获取第一个分支的value 
   > XFS_BMBT_PTR_ADDR（xfs_mount, xfs_btree_block, 1, xfs_mount->m_bmap_dmxr[1])
   - 如果level不是0, 需要继续查找
   - 找到第一个叶子节点,使用xfs_btree_block->bb_u->l->bb_rightsib遍历所有的叶子节点
   - 对于每个叶子节点,检查它成员的有效性
   > XFS_BMBT_REC_ADDR(xfs_mount, xfs_btree_block, j)
   - 检查xfs_bmbt_rec, 他也是大端定义的
   - 他们指向的文件范围不能交叉
   > xfs_bmbt_disk_get_startoff(xfs_bmbt_rec)
   > xfs_bmbt_disk_get_blockcount(xfs_bmbt_rec)
   - 相邻2个叶子节点也必须比较

** xfs_bmap_trace_extlist(xfs_inode, xfs_extnum_t, whichfork, caller_ip)
   - bmap trace insert entry??

** xfs_bmap_validate_ret(xfs_fileoff_t bno, xfs_filblks_t len, flags, xfs_bmbt_irec, nmap, ret_nmap)
   - 检查xfs_bmbt_irec数组, 哪里获取的?
   - xfs_bmbt_irec->br_blockcount >0, 它表示范围
   - 如果flags有XFS_BMAPI_ENTIRE,(br_startoff,br_blockcount)必须在(bno,len)范围内
   - 否则两个范围必须交叉
   - 而且相邻2个xfs_bmbt_irec不能交叉
   - br_startblock不能是DELAYSTARTBLOCK和HOLESTARTBLOCK

** xfs_bmap_add_free(xfs_fsblock_t bno, xfs_filblks_t len, xfs_bmap_free_t flist, xfs_mount)
   - 构造xfs_bmap_free_item, 记录(bno, len)
   - 把它放到参数xfs_bmap_free->xbf_first的链表中
   - 里面节点按照xfs_bmap_free_item->xbfi_startblock排序

** xfs_bmap_del_free(xfs_bmap_free, xfs_bmap_free_item prev, xfs_bmap_free_item)
   - free是xfs_bmap_free->xbf_first链表上的节点, 删除free
   - 减小xfs_bmap_free->xbf_count 

** xfs_bmap_finish(xfs_trans, xfs_bmap_free, committed)
   - 释放xfs_bmap_free中的所有extent?
   - xfs_trans->t_flags必须有XFS_TRANS_PERM_LOG_RES
   - 构造xfs_efi_log_item, 用来free extent
   > xfs_trans_get_efi(xfs_trans, nextents)
   - 遍历xfs_bmap_free的xfs_bmap_free_list, 填充到xfs_extent
   > xfs_trans_log_efi_extent(xfs_trans, xfs_efi_log_item, xfs_fsblock_t, xfs_extlen_t)
   - 设置xfs_trans->t_flags的XFS_TRANS_DIRTY
   - xfs_log_item->xfs_log_item_desc->lid_flags的XFS_LID_DIRTY
   - 为何要复制xfs_trans 
   > xfs_trans_dup(xfs_trans)
   - 又在提交? 
   > xfs_trans_commit(xfs_trans, 0)
   - 什么是xlog_ticket ?? 
   > xfs_log_ticket_put(xfs_trans->t_ticket)
   - 预留空间
   > xfs_trans_reserve(xfs_trans, 0, logres, 0, XFS_TRANS_PERM_LOG_RES, logcount)
   - 为xfs_trans创建xfs_efd_log_item, extent free done
   > xfs_trans_get_efd(xfs_trans, xfs_efi_log_item, xfs_bmap_free->xbf_count)
   - 然后遍历xfs_bmap_free->xbf_first的xfs_bmap_free_item, 释放空间
   > xfs_free_extent(xfs_trans, xfs_bmap_free_item->xbfi_startblock, xbfi_blockcount)
   - 记录xfs_efd_log_item
   > xfs_trans_log_efd_extent(xfs_trans, xfs_efd_log_item, xbfi_startblock, xbfi_blockcount)
   - 释放xfs_bmap_free_item 
   > xfs_bmap_del_free(xfs_bmap_free, NULL, xfs_bmap_free_item)
   - 在xfs_bmap_free_item/xfs_extent里面都是磁盘位置

** xfs_bmap_cancel(xfs_bmap_free)
   - 直接释放xfs_bmap_free的xfs_bmap_free_item节点

** xfs_bmap_btree_to_extents(xfs_trans, xfs_inode, xfs_btree_cur, logflags, whichfork)
   - 文件的extent数据从btree改为extents, 把extents队列放到xfs_dinode中
   - 在xfs_icdinode中,extents本来就是数组格式?
   - 
