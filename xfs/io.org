* bmap
  - 术语
    - xfs_bmbt_rec:表示磁盘中保存的regular文件的extent信息, 它是这里最重要的, 表示数据的位置信息，包括磁盘位置和文件偏移. xfs_bmbt_rec_host表示xfs_ifork中对应的信息, 使用的数据类型是本地CPU的. xfs_bmbt_irec表示解析的extent信息. 所以xfs_bmbt_rec表示一个extent的数据, 文件的一块数据.

    - 结点: 表示btree的结点，可能包括3中,根结点,内部结点，叶子节点.根结点可能和叶子结点一样，可能和根结点一样. 每个结点使用一个fsb磁盘块. 对于非根结点，磁盘块开头使用相同的数据结构, xfs_btree_block
      
** xfs_bmbt_rec
   - 磁盘中的bmap btree使用的数据类型, 使用大端格式
   - 对于于di_format有2种, XFS_DINODE_FMT_BTREE和XFS_DINODE_FMT_EXTENTS
   - 对于XFS_DINODE_FMT_EXTENTS,就是在xfs_dinode里面保存xfs_bmbt_rec数组
   - 对于XFS_DINODE_FMT_BTREE, 使用xfs_dinode保存树根, xfs_bmdr_block
   - 根节点的key/value使用xfs_bmdr_key_t/fs_bmdr_ptr_t
   - 内部节点头是xfs_btree_block, key/value使用xfs_bmbt_key / xfs_bmbt_ptr_t,和上面一样
   - 叶子节点使用xfs_btree_block, value是xfs_bmbt_rec数组

** xfs_bmbt_rec_host
   - 数据结构和xfs_bmbt_rec一样,不会使用本地数据类型
   - 保存在xfs_ifork中, data fork, xfs_inode->i_df
   - 文件操作map之前,需要先把xfs_bmbt_rec从磁盘中读到xfs_ifork中, 一次性全读出来. xfs_ifork->if_flags的XFS_IFEXTENTS表示是否缓存xfs_bmbt_rec
   - 对于XFS_DINODE_FMT_EXTENTS,读取xfs_dinode时把xfs_bmbt_rec读取出来, 直接设置XFS_IFEXTENTS标志
   - 对于XFS_DINODE_FMT_BTREE,需要去btree中读取xfs_bmbt_rec_host(xfs_iread_extents),读取只会才设置XFS_IFEXTENTS. 初始化时设置xfs_ifork->fi_flags的XFS_IFBROOT, 表示文件使用XFS_DINODE_FMT_BTREE
   - xfs_ifork存储xfs_bmbt_rec_host使用2种方法
   - 一种是一维数组, 所有的xfs_bmbt_rec_host在xfs_ifork内部的静态数组,或者动态分配一个数组
   - xfs_bmbt_rec在xfs_dinode的data fork, 使用XFS_DFORK_PTR直接访问
   - 另一种是2维数组,使用xfs_ifork->fi_flags的XFS_IFEXTIREC区别
   - 当xfs_bmbt_rec个数,也就是xfs_dinode->di_nextents < 4096/sizeof(xfs_bmbt_rec), 使用1维数组,否则扩展为2维数组
   - 2维数组使用xfs_ext_irec管理xfs_bmbt_rec_host, 里面可能不是满的,使用中需要压缩整理

   - xfs_ifork->if_flags还有XFS_IFINLINE, xfs_bmbt_rec不使用它. 它用于dir/attr/symlink的数组.

** xfs_bmbt_irec
   - 解析的xfs_bmbt_rec, 在操作btree中使用, 做数据转化使用
   - 对于br_state来说有4种? 
     - XFS_EXT_NORM 
     - XFS_EXT_UNWRITTEN
       - 有磁盘空间,但没有数据,也没有pagecache数据,刚为hole分配的磁盘
     - XFS_EXT_DMAPI_OFFLINE
     - XFS_EXT_INVALID
       
   - 对于br_startblock来说有2中,一种是有效的磁盘地址
   - 另一种是无效的磁盘地址,表示delay allocation
   - isnullstartblock(startblock)
   - 2个特殊的无效地址? DELAYSTARTBLOCK / HOLESTARTBLOCK

   - 修改btree之前,必须先修改xfs_ifork中缓存的

   - 删除xfs_bmbt_rec_host操作
   > xfs_bunmapi(xfs_trans, xfs_inode, xfs_fileoff_t bno, xfs_filblks_t len, flags, xfs_extnum_t nexts, xfs_fsblock_t firstblock, xfs_bmap_free_t, done)
     - 查找(bno,len)交叉的xfs_bmbt_rec_host, 删除它覆盖的部分
     - 对于delay allocation, 没有磁盘空间,只需释放预留的空间XFS_SBS_FDBLOCKS, 以及xfs_inode->i_delayed_blks计数
     - 否则需要修改btree中对应的xfs_bmbt_rec, 而且通过xfs_bmap_free释放磁盘空间
     > xfs_bmap_del_extent(xfs_inode, xfs_trans, idx, xfs_bmap_free, xfs_btree_cur, xfs_bmbt_irec)

* xfs_aops.c

** xfs_count_page_state(page, delalloc, unwritten)
   - 检查page的状态
   - 遍历page的buffer_header 
   > page_buffers(page)
   - 检查buffer_head的状态
   - 如果存在BH_Unwritten, unwritten = 1
   > buffer_unwritten(buffer_head)
   - 如果存在BH_Delay, delalloc = 1 
   > buffer_delay(buffer_head)

** xfs_find_bdev_for_inode(inode)
   - 查找inode的数据使用的磁盘
   - 如果是realtime inode，使用xfs_mount->m_rtdev_targp
   - 否则使用xfs_mount->m_ddev_targp->bt_bdev

** xfs_ioend 
   #+BEGIN_SRC 
	struct xfs_ioend	*io_list;	/* next ioend in chain */
	unsigned int		io_type;	/* delalloc / unwritten */
	int			io_error;	/* I/O error code */
	atomic_t		io_remaining;	/* hold count */
	unsigned int		io_isasync : 1;	/* needs aio_complete */
	unsigned int		io_isdirect : 1;/* direct I/O */
	struct inode		*io_inode;	/* file being written to */
	struct buffer_head	*io_buffer_head;/* buffer linked list head */
	struct buffer_head	*io_buffer_tail;/* buffer linked list tail */ //这里使用的buffer_head->b_private链表?
	size_t			io_size;	/* size of the extent */
	xfs_off_t		io_offset;	/* offset in the file */
	struct work_struct	io_work;	/* xfsdatad work queue */
	struct xfs_trans	*io_append_trans;/* xact. for size update */
	struct kiocb		*io_iocb;
	int			io_result;   
   #+END_SRC

** xfs_destroy_ioend(xfs_ioend)
   - IO完成后释放xfs_ioend, 需要释放buffer_head, bio, inode?
   - 遍历io_buffer_head队列的buffer_head 
   > buffer_head->b_end_io(buffer_head, xfs_ioend->io_error)
   - 如果xfs_ioend->io_iocb有效, 才调用回调??
   > inode_dio_done(xfs_ioend->io_inode)
   - 如果是异步, xfs_ioend->io_isasync 
   > aio_complete(xfs_ioend->io_iocb, xfs_ioend->io_result, 0)
   - 这里回唤醒kiocb??
   - 最后释放xfs_ioend 

** xfs_ioend_is_append(xfs_ioend)
   - 检查是否是append io?
   - xfs_ioend->io_offset + io_size > xfs_inode->xfs_icdinode->di_size ?? 

** xfs_setfilesize_trans_alloc(xfs_ioend)
   - 构造xfs_trans 
   > xfs_trans_alloc(xfs_mount, XFS_TRANS_FSYNC_TS)
   - 预留空间, XFS_FSNC_TS_LOG_RES??
   > xfs_trans_reserve(xfs_trans, 0, XFS_FSYNC_TS_LOG_RES(xfs_mount), 0, 0,0)
   - 把上面创建的xfs_trans给xfs_ioend->io_append_trans
   
** xfs_setfilesize(xfs_ioend) 
   - IO完成后释放更新文件大小
   - 锁住inode 
   > xfs_ilock(xfs_inode, XFS_ILOCK_EXCL) 
   - 计算新的文件大小, 它不能超过i_size, 而且必须比di_size大才需要更新??
   - 在a_ops->write中回更新i_size
   > xfs_new_eof(xfs_inode, xfs_ioend->io_offset + io_size)
   - 设置xfs_inode->xfs_icdinode->di_size 
   > xfs_trans_ijoin(xfs_trans, xfs_inode, XFS_ILOCK_EXCL)
   > xfs_trans_log_inode(xfs_trans, xfs_inode, XFS_ILOG_CORE)

** xfs_finish_ioend(xfs_ioend)
   - 释放xfs_ioend的使用计数,如果减为0, 释放资源?
   > atomic_dec_and_test(xfs_ioend->io_remaining) 
   - 如果xfs_ioend->io_type == XFS_IO_UNWRITTEN? 
   > queue_work(xfs_mount->m_unwritten_workqueue, xfs_ioend->io_work)
   - 如果是append IO? 或者directIO 
   > xfs_ioend_is_append(xfs_ioend)
   > queue_work(xfs_mount->m_data_workqueue, xfs_ioend->io_work)
   - 否则直接释放xfs_ioend 
   > xfs_destroy_ioend(xfs_ioend)

** xfs_end_io(work_struct)
   - 参数是xfs_ioend->io_work
   - 什么是XFS_IO_UNWRITTEN, 只分配空间,但没有写数据?
   > xfs_iomap_write_unwritten(xfs_inode, xfs_ioend->io_offset, xfs_ioend->io_size)
   - 如果是direct IO, 修改文件大小? 
   > xfs_setfilesize_trans_alloc(xfs_ioend)
   > xfs_setfilesize(xfs_ioend)
   - 如果只是append? 
   > xfs_setfilesize(xfs_ioend)
   - 最后释放xfs_ioend 
   > xfs_destroy_ioend(xfs_ioend)

** xfs_finish_ioend_sync(xfs_ioend)
   - 释放xfs_ioend->io_remaining计数 
   - 这是同步方式, 直接调用
   > xfs_end_io(xfs_ioend->io_work)

** xfs_alloc_ioend(inode, type)
   - 构造xfs_ioend, 只是设置io_type = type? 

** xfs_bmbt_irec 
   - extent数据, 单位都是  inode->i_blkbits
   #+BEGIN_SRC 
	xfs_fileoff_t	br_startoff;	/* starting file offset */
	xfs_fsblock_t	br_startblock;	/* starting block number */
	xfs_filblks_t	br_blockcount;	/* number of blocks */
	xfs_exntst_t	br_state;	/* extent state */   
   #+END_SRC

** xfs_map_blocks(inode, offset, xfs_bmbt_irec, type, nonblocking)
   - 查找offset对应的extent?
   - 如果type == XFS_IO_UNWRITTEN, 忽略state? XFS_BMAPI_IGSTATE
   - 先锁住inode, 使用XFS_ILOCK_SHARED 
   > xfs_ilock_nowait(xfs_inode, XFS_ILOCK_SHARED)
   - 如果锁不住,而且nonblocking!=0, 返回EAGAIN
   - 否则等待这个锁 
   > xfs_ilock(xfs_inode, XFS_ILOCK_SHARED)
   - 开始查找extent, 范围是(offset, -1)
   - 最大值是super_block->s_maxbytes
   - 转化为FSB 
   > XFS_B_TO_FSB(xfs_mount, offset)
   - 只会返回1个xfs_bmbt_irec
   > xfs_bmapi_read(xfs_inode, offset_fsb, end_fsb-offset_fsb, xfs_bmbt_irec, nimaps, bmapi_flags)
   - 释放xfs_inode的锁 
   > xfs_iunlock(xfs_inode, XFS_ILOCK_SHARED)
   - 如果type是XFS_IO_DELALLOC,而且没有找到xfs_bmbt_irec, 或者找到的是hole 
   > isnullstartblock(xfs_bmbt_irec->br_startblock)
   - 更新btree? 
   > xfs_iomap_write_unwritten(xfs_inode, offset, count, xfs_bmbt_irec)

** xfs_imap_valid(xfs_inode, xfs_bmbt_irec, offset)
   - 验证xfs_bmbt_irec的有效性
   - offset应该在xfs_bmbt_irec->br_startoff和br_blockcount之间
   - 两者单位是什么?  xfs_inode->i_blkbits, 是bb还是fsb?

** xfs_end_bio(bio, error)
   - bio的回调函数
   - 处理bio->bi_private,也就是xfs_ioend
   - 根据bio->bi_flags的BIO_UPTODATE确定io的结果
   - 首先处理bio 
   > bio_put(bio)
   > xfs_finish_ioend(xfs_ioend)

** xfs_submit_ioend_bio(writeback_control, xfs_ioend, bio)
   - 提交bio, 首先配置bio
   - 增加xfs_ioend->io_remaining计数
   - 设置bio->bi_end_io = xfs_end_bio 
   > submit_bio(writeback_control->sync_mode == WB_SYNC_ALL? WRITE_SYNC:WRITE, bio)

** xfs_alloc_ioend_bio(buffer_head)
   - 构造bio, 为何使用多个iovec?
   > bio_get_nr_vecs(buffer_head->b_bdev)
   > bio_alloc(GFP_NOIO, nvecs)
   - 计算bio的起始位置??
   > buffer_head->b_blocknr * buffer_head->b_size >>9

** xfs_start_buffer_writeback(buffer_head)
   - 检查buffer_head的状态，必须是BH_Mapped, BH_Locked 
   - 不能是BH_Delay? BH_Unwritten??
   - 异步写? 通用的函数, 使bio回调通用的函数
   > mark_buffer_async_write(buffer_head)
   - 设置BH_Uptodate, 清除BH_Dirty 
   > set_buffer_uptodate(buffer_head)
   > clear_buffer_dirty(buffer_head)
   - 没有衍生的操作? 比如修改计数?

** xfs_start_page_writeback(page, clear_dirty, buffers)
   - 写回page? 检查page的状态
   - 必须有PG_locked, 而且没有PG_writeback
   - 如果clear_dirty !=0, 修改标志 
   > clear_page_dirty_for_io(page)
   - 准备启动bio 
   > set_page_writeback(page)
   > unlock_page(page)
   - 如果buffers ==0, 没有必要IO? 
   > end_page_writeback(page)

** bio_add_buffer(bio, buffer_head)
   - 向bio中增加iovec
   > bio_add_page(bio, buffer_head->b_page, buffer_head->b_size, bh_offset(buffer_head))

** xfs_submit_ioend(writeback_control, xfs_ioend, fail)
   - xfs_ioend是单链表, 使用xfs_ioend->io_list
   - 遍历每个xfs_ioend中的buffer_head
   - 修改buffer_head的标志
   > xfs_start_buffer_writeback(buffer_head)
   - 再次遍历, 提交bio 
   - 首先分配bio
   > xfs_alloc_ioend_bio(buffer_head)
   - 后续的buffer_head可以合并到这里
   > bio_add_buffer(bio, buffer_head)
   - 如果无法合并,先提交之前的io, 创建新的 
   > xfs_submit_ioend_bio(writeback_control, xfs_ioend, bio)

** xfs_cancel_ioend(xfs_ioend)
   - 释放xfs_ioend中的buffer_head 
   > clear_buffer_async_write(buffer_head)
   > unlock_buffer(buffer_head)
   - 直接释放xfs_ioend

** xfs_add_to_ioend(inode, buffer_head, xfs_off_t, type, xfs_ioend, need_ioend)
   - 把buffer_head添加到xfs_ioend管理中
   - 首先检查buffer_head能否放到参数中
   - need_ioend ==0, 而且type == xfs_ioend->io_type
   - 把buffer_head放到xfs_ioend->io_buffer_tail中, 果然使用buffer_head->b_private
   - 否则创建新的xfs_ioend 
   > xfs_alloc_ioend(inode, type)
   - 设置xfs_ioend->io_offset 为参数offset
   - 并且把xfs_ioend放到参数的xfs_ioend->io_list链表中
   - 还要增加xfs_ioend->io_size += buffer_head->b_size 

** xfs_map_buffer(inode, buffer_head, xfs_bmbt_irec, xfs_off_t)
   - 根据xfs_bmbt_irec计算buffer_head的磁盘位置
   - xfs_off_t是文件偏移,以字节为单位, 同样转换xfs_bmbt_irec->br_startoff 
   > XFS_FSB_TO_B(xfs_mount, xfs_bmbt_irec->br_startoff)
   - 磁盘位置先转化为磁盘绝对位置, 以BB为单位, fsb包含agno,agbno 
   > xfs_fsb_to_db(xfs_inode, xfs_bmbt_irec->br_startblock)
   - 然后根据文件位置做偏移,转化为inode->i_blkbits为单位, 应该是sectorsize?
   - 设置buffer_head->b_blocknr
   - 设置BH_Mapped

** xfs_map_at_offset(inode, buffer_head, xfs_bmbt_irec, xfs_off_t)
   - 影射buffer_head的磁盘位置  
   > xfs_map_buffer(inode, buffer_head, xfs_bmbt_irec, xfs_off_t)
   - 有设置BH_Mapped? 
   - 去掉BH_Delay, BH_Unwritten

** xfs_check_page_type(page, type)
   - 检查page是否和type一致??
   - 如果paeg在写回PG_writeback, 返回0
   - 如果page有buffer_head, 遍历它的buffer_head
   > page_has_buffers(page)
   - XFS_IO_UNWRITTEN要求BH_Unwritten
   - XFS_IO_DELALLOC要求BH_Delay
   - XFS_IO_OVERWRITE要求BH_Mapped
   - 只有存在和type对应的buffer_head时才返回1

** xfs_convert_page(inode, page, loff_t, xfs_bmbt_irec, xfs_ioend, writeback_control)
   - 为page构造buffer_head, 并影射磁盘信息 
   - 只处理delalloc/unwritten的page
   - 先检查page状态
   - page->index == loff_t, 文件偏移
   - 锁住page, PG_lock, 如果有PG_writeback, 返回
   - 检查io类型 
   > xfs_check_page_type(page, xfs_ioend->io_type)
   - 计算需要IO的buffer_head的个数, 每个处理的长度是inode->i_blkbits?
   - 只有文件的最后一个page需要处理 
   - end_offset = min((page->index + 1) <<PAGE_CACHE_SHIFT, i_size_read(inode))
   - 检查extent信息
   > xfs_imap_valid(inode, xfs_bmbt_irec, end_offset)
   - buffer_head的个数是 end_offset & PAGE_CACHE_SHIFT >> inode->i_blkbits
   - 遍历它的buffer_head
   - 如果page/buffer_head都不是有效的,PG_uptodate/BH_Uptodate, 不处理?
   - 只处理3种buffer_head, BH_Unwritten/BH_Delay/BH_Mapped
   > xfs_imap_valid(inode, xfs_bmbt_irec, offset)
   - 对于BH_Unwritten, 使用io_type是XFS_IO_UNWRITTEN
   - 对于BH_Delay, 使用io_type是XFS_IO_DELALLOC
   - 其他使用XFS_IO_OVERWRITE
   - 影射buffer_head的磁盘位置 
   > xfs_map_at_offset(inode, buffer_head, xfs_bmbt_irec, offset)
   - 提交bio
   > xfs_add_to_ioend(inode, buffer_head, offset, type, xfs_ioend, done)
   - 最后可以更新page的PG_uptodate
   - 释放page的锁, 修改状态
   > xfs_start_page_writeback(page, !page_dirty, count)

** xfs_cluster_write(inode, pgoff_t tindex, xfs_bmbt_irec, writeback_control, pgoff_t tlast)
   - 处理(tindex,tlast)之间的page, 属于同一个extent?
   - 循环处理, 先在address_space中查找 
   > pagevec_lookup(page, inode->address_space, tindex, len)
   - 然后提交所有的page 
   > xfs_convert_page(inode, page, tindex, xfs_bmbt_irec, xfs_ioend, writeback_control)
   - 这样也积累了一个队列的xfs_ioend 

** xfs_vm_invalidatepage(page, offset, length)
   - 释放address_space中的page 
   > block_invalidatepage(page, offset, length)

** xfs_aops_discard_page(page)
   - 检查page是否有delalloc的buffer_head
   > xfs_check_page_type(page, XFS_IO_DELALLOC)
   - 遍历page的buffer_header, 只处理BH_Delay的
   - 为何合理处理整个page的偏移??
   > XFS_B_TO_FSB(xfs_mount, offset)
   > xfs_bmap_punch_delalloc_range(xfs_inode, start_fsb, 1)
   - 释放pagecache 
   > xfs_vm_invalidatepage(page, 0, PAGE_CACHE_SIZE)

** xfs_vm_writepage(page, writeback_control)
   - 这是address_space的回调函数, 把page写回磁盘
   - 对于BH_Delay, 需要分配空间, 然后发送bio
   - 对于BH_Unwritten, 需要做什么?? 
   - 其他的只需要发送bio
   - 检查current->flags的PF_FSTRANS, 不能在transaction中操作??
   - 如果处理文件最有一个page,需要清空文件大小之外的数据 i_size
   - 遍历所有的buffer_head
   - 检查BH_Uptodate, 如果所有的buffer_head都有,才设置PG_uptodate
   - 如果没有BH_Mapped,但有BH_Uptodate? 放到后面处理?
   - 检查buffer_head的状态, 确定对应的io_type
   - 如果和前一个io_type一样,不需要重新获取xfs_bmbt_irec, 否则需要 
   > xfs_map_blocks(inode, offset, xfs_bmbt_irec, type, noblocking) 
   - 验证offset是否在xfs_bmbt_irec里面
   > xfs_imap_valid(inode, xfs_bmbt_irec, offset)
   - 如果xfs_bmbt_irec可用, 计算buffer_head的磁盘位置  
   > xfs_map_at_offset(inode, buffer_head, xfs_bmbt_irec, offset)
   - 把它给xfs_ioend 
   > xfs_add_to_ioend(inode, buffer_head, offset, type, xfs_ioend, new_ioend)
   - 设置page状态 
   > xfs_start_page_writeback(page, 1, count)
   - 然后提交page后面的数据??
   > xfs_cluster_write(inode, page->index+1, xfs_bmbt_irec, xfs_ioend, writeback_control, end_index)
   - 构造log, 为修改文件大小准备? 
   - xfs_ioend->io_type != XFS_IO_UNWRITTEN, 而且是append 
   > xfs_ioend_is_append(xfs_ioend)
   > xfs_setfilesize_trans_alloc(xfs_ioend)
   - 提交xfs_ioend 
   > xfs_submit_ioend(writeback_control, xfs_ioend, err)

** xfs_vm_writepages(address_space, writeback_control)
   - 去掉xfs_inode->i_flags的XFS_ITRUNCATED?? 
   > xfs_iflags_clear(xfs_inode, XFS_ITRUNCATED) 
   - 使用vfs接口处理 
   > generic_writepages(address_space, writeback_control)

** xfs_vm_releasepage(page, gfp_t)
   - 检查page是否可以释放? 
   > xfs_count_page_state(page, delalloc, unwritten)
   - 如果是delaye/unwritten, 不可以释放? 
   - 然后检查buffer_head 
   > try_to_free_buffers(page)

** __xfs_get_blocks(inode, sector_t offset, buffer_head, craete, direct)
   - 获取buffer_head的磁盘位置信息, offset表示文件偏移
   - 首先处理参数, offset从blocksize单位变为字节  inode->i_blkbits
   - 如果create==0, direct==1, 而且offset超过i_size, 不处理?
   - 锁住inode
   - 如果create ==1, 而且direct==0, 这时普通buffered的IO,使用XFS_ILOCK_EXCL 
   > xfs_ilock(xfs_inode, XFS_ILOCK_EXCL)
   - 否则,根据extent状态而定 
   > xfs_ilock_map_shared(xfs_inode)
   - 把所有的文件位置/大小转化为fsb, 单位是xfs_sb->sb_blocklog
   > XFS_B_TO_FSB(xfs_mount, offset)
   - 获取offset_fsb所在的xfs_bmbt_irec 
   > xfs_bmapi_read(inode, offset_fsb, end_fsb-offset_fsb, xfs_bmbt_irec, nimaps, XFS_BMAPI_ENTIRE)
   - 上面无论如何都会找到一个xfs_bmbt_rec_irec.
   - 如果create==1,而且没有找到xfs_bmbt_irec,或者找到的没有磁盘空间, 开始delalloc?
   - xfs_bmbt_irec->br_startblock是HOLESTRATBLOCK|DELAYSTRATBLOCK
   - 如果是direct, 或者有extent大小?
   > xfs_get_extsz_hint(xfs_inode)
   - 分配磁盘, 如果需要增加eof, 使用XFS_MAPI_PREALLOCATION??
   > xfs_iomap_write_direct(xfs_inode, offset, size, xfs_bmbt_irec, nimaps)
   - 否则启动delalloc, 预留磁盘空间,创建xfs_bmbt_rec_host, 并不会修改btree
   > xfs_iomap_write_delay(xfs_inode, offset, size, xfs_bmbt_irec)
   - 如果create==0, 而且没有找到xfs_bmbt_irec, 直接退出
   - 如果xfs_bmbt_irec的磁盘位置不是hole/delay 
   - 而且create ==1或者xfs_bmbt_irec不是XFS_EXT_UNWRITTEN, 建立buffer_head的映射信息
   > xfs_map_buffer(inode, buffer_head, xfs_bmbt_irec, offset)
   - 如果xfs_bmbt_irec->br_state是XFS_EXT_UNWRITTEN, 设置BH_Unwritten
   > set_buffer_unwritten(buffer_head)
   - 查找block_dev 
   > xfs_find_bdev_for_inode(inode)
   - 如果create ==1, 而且没有BH_Mapped|BH_Uptodate, 或者在eof之后,或者上面刚创建xfs_bmbt_irec,而且是XFS_EXT_UNWRITTEN, 设置BH_New
   - 如果xfs_bmbt_irec是delalloc, DELAYSTRATBLOCK, 而且create ==1
   - 设置BH_Uptodate, BH_Mapped, BH_Delay, 怎么能有BH_Mapped?
   > set_buffer_uptodate(buffer_head)
   > set_buffer_mapped(buffer_head)
   > set_buffer_delay(buffer_head)
   - 如果是directIO,可能修改buffer_head的大小??

** xfs_get_blocks(inode, sector_t iblock, buffer_head, create)
   - buffered的io 
   > __xfs_get_blocks(inode, iblock, buffer_head, create, 0)

** xfs_get_blocks_direct(inode, sector_t iblock, buffer_head, create)
   > __xfs_get_blocks(inode, iblock, buffer_head, create, 1)

** xfs_end_io_direct_write(kiocb, loff_t offset, size, private)
   - 更新inode->i_size, 怎么在这里更新?
   > i_size_write(xfs_ioend->io_inode, offset + size)
   - 如果private !=0, 而且size>0, 设置xfs_ioend->io_type = XFS_IO_UNWRITTEN
   > xfs_finish_ioend_sync(xfs_ioend)

** xfs_vm_direct_IO(rw, kiocb, iovec, offset, nr_segs)
   - 如果rw是WRITE, 准备xfs_ioend 
   > xfs_alloc_ioend(inode, XFS_IO_DIRECT)
   - 如果写的范围超过文件大小, 设置xfs_ioend->io_isdirect =1 
   > __blockdev_direct_IO(rw, kiocb, inode, block_device, iovec, offset, nr_segs, xfs_get_blocks_direct, xfs_end_io_direct_write, NULL, 0)
   - 对于READ? 
   > __block_direct_IO(rw, kiocb, inode, block_device, iovec, offset, nr_segs, xfs_get_blocks_direct, NULL, NULL, 0)

** xfs_vm_kill_delalloc_range(inode, start, end)
   - 释放delalloc的磁盘空间?
   - 锁住inode 
   > xfs_ilock(xfs_inode, XFS_ILOCK_EXCL)
   > xfs_bmap_punch_delalloc_range(xfs_inode, start_fsb, end_fsb-offset_fsb)

** xfs_vm_write_failed(inode, page, pos, len)
   - write的错误处理函数?
   - 遍历page的buffer_header
   > xfs_vm_kill_delalloc_range(inode, block_offset, block_offset + buffer_head->b_size)

** xfs_vm_write_begin(file, address_space, pos, len, flags, page, fsdata)
   - 获取或创建page  
   > grab_cache_page_write_begin(address_space, index, flags)
   - 准备buffer_head,以及磁盘映射信息
   > __block_write_begin(page, pos, len, xfs_get_blocks)

** xfs_vm_write_end(file, address_space, loff_t pos, len, copied, page, fsdata)
   - 还是使用vfs的接口函数,修改buffer_head/page的标志,还有inode的大小
   > generic_write_end(file, address_space， pos, len, copied, page, fsdata)

** xfs_vm_bmap(address_space, sector_t block)
   - 锁住xfs_inode, XFS_IOLOCK_SHARED
   > xfs_ilock(xfs_inode, XFS_IOLOCK_SHARED)
   - flush pagecache? 
   > filemap_write_and_wait(address_space)
   - 然后映射?? 
   > generic_block_bmap(address_space, block, xfs_get_blocks)

** xfs_vm_readpage(file, page)
   > mpage_readpage(page, xfs_get_blocks)

** xfs_vm_readpages(file, address_space, list_head, nr_pages)
   - 都使用vfs接口
   > mpage_readpages(address_space, list_head, nr_pages, xfs_get_blocks)

* xfs_iomap.c

** xfs_iomap_eof_align_last_fsb(xfs_mount, xfs_inode, xfs_extlen_t extsize, xfs_fileoff_t last_fsb)
   - 处理文件的eof? last_fsb
   - 首先使用xfs_mount->swidth或xfs_mount->d_dalign对齐
   - 如果eof超过align 
   > XFS_ISIZE(xfs_inode)
   - 然后对齐extsize?? 
   - 修改什么? 
   > xfs_bmap_eof(xfs_inode, new_last_fsb, XFS_DATA_FORK, eof)
  
** xfs_alert_fsblock_zero(xfs_inode, xfs_bmbmt_irec)
   - 调式信息, 输出xfs_bmbt_irec的信息  

** xfs_bmap_free_item 
   #+BEGIN_SRC 
	xfs_fsblock_t		xbfi_startblock;/* starting fs block number */
	xfs_extlen_t		xbfi_blockcount;/* number of blocks in extent */
	struct xfs_bmap_free_item *xbfi_next;	/* link to next entry */   
   #+END_SRC

** xfs_bmap_free
   #+BEGIN_SRC 
	xfs_bmap_free_item_t	*xbf_first;	/* list of to-be-free extents */
	int			xbf_count;	/* count of items on list */
	int			xbf_low;	/* alloc in low mode */   
   #+END_SRC

** xfs_iomap_write_direct(xfs_inode, xfs_off_t offset, size_t count, xfs_bmbt_irec, nmaps)
   - 要写的数据是(offset, count), 如果超过eof, 校正eof? 
   - 获取hint extent size 
   > xfs_get_extsz_hint(xfs_inode)
   - offset + count > XFS_ISIZE(xfs_inode)
   > xfs_iomap_eof_align_last_fsb(xfs_mount, xfs_inode, extsz, last_fsb)
   - 如果对应的xfs_bmbt_irec表示范围是hole, 限制操作范围
   - 校正文件范围,起始位置和长度都要对extsz对齐
   - 创建xfs_trans 
   > xfs_trans_alloc(xfs_mount, XFS_TRANS_DIOSTRAT)
   - 预留空间 
   > xfs_trans_reserve(xfs_trans, resblks, XFS_WRITE_LOG_RES(xfs_mount), resrtextents, XFS_TRANS_PERM_LOG_RES, XFS_WRITE_LOG_COUNT)
   - 锁住inode ? 
   > xfs_ilock(xfs_inode, XFS_ILOCK_EXCL)
   > xfs_trans_ijoin(xfs_trans, xfs_inode, 0)
   - 初始化xfs_bmap_free? 
   > xfs_bmap_init(xfs_bmap_free, firstfsb)
   - 获取xfs_bmbt_irec?? 
   > xfs_bmapi_write(xfs_trans, xfs_inode, offset_fsb, count_fsb, bmapi_flags, firstfsb, 0, xfs_bmbt_irec, nimaps, free_list)
   - 结束transaction 
   > xfs_trans_commit(xfs_trans, XFS_TRANS_RELEASE_LOG_RES)

** xfs_iomap_eof_want_preallocate(xfs_mount, xfs_inode, xfs_off_t offset, size_t count, xfs_bmbt_irec, nimaps, prealloc)
   - 在写操作增加eof时,检查是否能预分配空间? 设置结果给prealloc?
   - 如果写的范围没有超过eof, 直接返回
   - 如果offset + count <= XFS_ISIZE(xfs_inode)
   - 如果prealloc有限制, xfs_mount使用XFS_MOUNT_DFLT_IOSIZE
   - 如果文件太小, 小于xfs_mount->m_writeio_blocks, 直接返回0
   - 读取文件的extent, 检查是否已经有空间? 
   - 在offset+count之后的
   > xfs_bmapi_read(xfs_inode, start_fsb, count_fsb, xfs_bmbt_irec, imaps, 0)
   - 遍历读取的xfs_bmbt_irec, 如果xfs_bmbt_irec->br_startblock不是HOLDSTARTBLOCK/DELAYSTARTBLOCK,直接返回
   - 如果xfs_bmbt_irec->br_startblock是DELAYSTARTBLOCK, 找到delalloc?
   - 只有找不到xfs_bmbt_irec, 或者找到的都是HOLDSTARTBLOCK, 才能设置prealloc=1

** xfs_iomap_eof_prealloc_initial_size(xfs_mount, xfs_inode, xfs_off_t offset, xfs_bmbt_irec, nimaps)
   - 计算与分配的空间?
   - 如果xfs_mount->m_flags有XFS_MOUNT_DFLT_IOSIZE, 使用特定的大小
   - 如果文件太小, 不超过xfs_mount->m_dalign, 使用默认的
   - 查找xfs_bmbt_irec 
   > xfs_bmapi_read(xfs_inode, start_fsb, 1, xfs_bmbt_irec, imaps, XFS_BMAPI_ENTIRE)
   - 如果xfs_bmbt_irec->br_startblock是HOLDSTARTBLOCK, 返回0? 使用默认的?
   - 如果xfs_bmbt_irec->br_blockcount <= MAXEXTLEN/2, 返回xfs_bmbt_irec->br_blockcount * 2 ??
   - 否则返回offset???

** xfs_quota_calc_throttle(xfs_inode, type, xfs_fsblock_t, qshift)

** xfs_iomap_prealloc_size(xfs_mount, xfs_inode, xfs_off_t, xfs_bmbt_irec, nimaps)
   - 首先检查是否使用变化的prealloc size 
   > xfs_iomap_eof_prealloc_initial_size(xfs_mount, xfs_inode, offset, xfs_bmbt_irec, nimaps)
   - 如果返回0, 使用固定的大小
   - 否则使用上面返回的alloc_blocks,计算适当的值
   - 检查文件系统的剩余空间, 如果越少,越少分配 
   - xfs_sb->sb_fdblocks, 标准是xfs_mount->m_low_space[5]
   - 根据上面的条件,缩小alloc_blocks
   - 同时它还不能超过文件系统剩余空间, 否则需要缩小4倍,16倍..
   - 最后默认的,也是最小的是xfs_mount->m_writeio_blocks

** xfs_iomap_write_delay(xfs_inode, xfs_off_t, size_t, xfs_bmbt_irec)
   - 首先获取extent hint? 
   > xfs_get_extsz_hint(xfs_inode)
   - 校正eof ? 
   > xfs_iomap_eof_want_preallocate(xfs_mount, xfs_inode, offset, count, xfs_bmbt_irec, XFS_WRITE_IMAPS, prealloc)
   - 如果需要预分配? 检查与分配的空间?? 
   > xfs_iomap_prealloc_size(xfs_mount, xfs_inode, offset, xfs_bmbt_irec, XFS_WRITE_IMAPS)
   - 然后构造extent? 
   > xfs_bmapi_delay(xfs_inode, offset_fsb, last_fsb-offset_fsb, xfs_bmbt_irec, nimaps, XFS_BMAPI_ENTIRE)
   - 最后设置xfs_inode标志? 
   > xfs_inode_set_eofblocks_tag(xfs_inode)

** xfs_iomap_write_allocate(xfs_inode, xfs_off_t, size_t, xfs_bmbt_irec)
   - 把delayed的extent,转化为已经使用的extent?
   - 首先准备xfs_trans 
   > xfs_trans_alloc(xfs_mount, XFS_TRNS_STRAT_WRITE)
   - 预留空间?? 
   > xfs_trans_reserve(xfs_trans, nres, XFS_WRITE_LOG_RES(xfs_mount), 0, XFS_TRANS_PERM_LOG_RES, XFS_WRITE_LOG_COUNT)
   - 为何要锁住xfs_inode, 才能设置trans? 
   > xfs_trans_ijoin(xfs_trans, xfs_inode, 0)
   - 初始化xfs_bmap_free? 
   > xfs_bmap_init(xfs_bmap_free, first_block)
   - 计算last_block?? 
   > xfs_bmap_last_offset(NULL, xfs_inode, last_block, XFS_DATA_FORK)
   - 修改extent数据?
   > xfs_bmapi_write(xfs_trans, xfs_inode, map_start_fsb, count_fsb, XFS_BMAPI_STACK_SWITCH, first_block, 1, xfs_bmbt_irec, nimaps, xfs_bmap_free)
   - 结束transaction
   > xfs_bmap_finish(xfs_trans, xfs_bmap_free, committed)
   - 提交transaction 
   > xfs_trans_commit(xfs_trans, XFS_TRANS_RELEASE_LOG_RES)
   - 需要循环处理, 直到(offset, count)范围内的extent都处理掉

** xfs_iomap_write_unwritten(xfs_inode, xfs_off_t offset, size_t count)
   - 和上面很想,循环处理(offset, count)内的xfs_bmbt_irec
   > _xfs_trans_alloc(xfs_mount, XFS_TRANS_STRAT_WRITE, KM_NOFS)
   > xfs_trans_reserve(xfs_trans, resblks, XFS_WRITE_LOG_RES(xfs_mount), 0, XFS_TRANS_PERM_LOG_RES, XFS_WRITE_LOG_COUNT)
   > xfs_bmapi_init(xfs_bmap_free, firstfsb)
   > xfs_bmapi_write(xfs_trans, xfs_inode, offset_fsb, count_fsb, XFS_BMAPI_CONVERT, firstfsb, ..)
   - 如果改变文件大小 
   > xfs_new_eof(xfs_inode, i_size)
   - 需要使用trans改变xfs_dinode 
   > xfs_trans_log_inode(xfs_trans, xfs_inode, XFS_ILOG_CORE)

* xfs_bmap.c 
  - 操作磁盘的bmap tree的函数

** xfs_bmdr_block 
   - 这是btree根节点的头,后面是(key,value)对值
   - 在xfs_dinode的data fork中保存
   - 但在内存xfs_ifork中还是转化为xfs_btree_block
   #+BEGIN_SRC 
	__be16		bb_level;	/* 0 is a leaf */
	__be16		bb_numrecs;	/* current # of data records */   
   #+END_SRC

** xfs_btree_block 
   - 每个btree节点在磁盘中保存时开头的数据结构
   - 在这里, btree是bmbt, 保存文件的extent信息, 它在内存中放在xfs_ifork->if_broot中
   - 根结点在磁盘中不使用这个数据结构

   #+BEGIN_SRC 
	__be32		bb_magic;	/* magic number for block type */
	__be16		bb_level;	/* 0 is a leaf */
	__be16		bb_numrecs;	/* current # of data records */

	__be64		bb_leftsib;
	__be64		bb_rightsib;

	__be64		bb_blkno;
	__be64		bb_lsn;
	uuid_t		bb_uuid;
	__be64		bb_owner;
	__le32		bb_crc;
	__be32		bb_pad; /* padding for alignment */
   
   #+END_SRC

** xfs_bmbt_key 
   - btree中非叶子节点使用的key, value是分支指针,使用子节点的磁盘位置
   - xfs_bmbt_ptr_t, xfs_bmdr_ptr_t分配用于根结点和内部结点
   - 这里磁盘位置是64位，一个文件的bmbt btree的结点可以不限于一个AG

   #+BEGIN_SRC 
	__be64		br_startoff;	/* starting file offset */   
   #+END_SRC

** xfs_bmap_compute_maxlevels(xfs_mount, whichfork)
   - 计算bmbt btree高度的最大值, 在mount操作时调用, 用来设置xfs_mount->m_bm_maxlevels[fork]
   - 当叶子节点最多时,而且内部节点分支最少时,btree的高度最大
   - 当叶子结点中xfs_bmbt_rec最少时, 叶子结点最多
   - 先计算最多的xfs_bmbt_rec的数量 maxleafents
   - 对于data fork, 叶子结点最多是xfs_dinode->di_nextents的数据类型决定, MAXEXTLEN, signed int32
   - 对于attr fork, 叶子结点最多是xfs_dinode->di_anextents的数据类型决定, MAXAEXTNUM, signed int16
   - 叶子节点或内部节点的最小分支是xfs_mount->m_bmap_dmnr[2]
   - 最多的叶子结点时  maxblocks = maxleafents / xfs_mount->m_bmap_dmnr[0]
   - 遍历计算每一层内部结点的最大值, 直到分支数小于根结点分支数
   - maxrootrecs = xfs_bmdr_maxrecs(xfs_mount, sz, 0)
   - maxblocks = maxblocks / xfs_mount->m_bmap_dmnr[1]

** xfs_bmbt_lookup_eq(xfs_btree_cur, xfs_fileoff_t off, xfs_fsblock_t bno, xfs_filblks_t len, stat)
   - 让xfs_bmbt_cur指向对应的xfs_bmbt_rec
   - 设置xfs_btree_cur->xfs_bmbt_irec的startoff/startblock/blockcount
   > xfs_btree_lookup(xfs_btree_cur, XFS_LOOKUP_EQ, stat)
  
** xfs_bmbmt_lookup_ge(xfs_btree_cur, xfs_fileoff_t, xfs_fsblock_t, xfs_filblks_t, stat)
   - 设置xfs_btree_cur, 查找btree 
   > xfs_btree_lookup(xfs_btree_cur, XFS_LOOKUP_GE, stat)

** xfs_bmap_needs_btree(xfs_inode, whichfork)
   - 检查xfs_inode是否需要转化为使用btree存储xfs_bmbt_rec
   - 如果xfs_ifork的磁盘格式使用XFS_DINODE_FMT_EXTENTS, 没有使用btree, xfs_icdinode->di_format/di_aformat
   - XFS_IFORK_FORMAT(xfs_inode, whichfork)
   - 而且xfs_bmbt_rec数量超过限制 xfs_dinode->di_nextents/di_anextents
   > XFS_IFORK_NEXTENTS(xfs_inode, whichfork)
   - 最大值表示xfs_dinode可容纳的最多的xfs_bmbt_rec的数量
   - 也就是data fork/attr fork的大小决定
   > XFS_IFORK_MAXEXT(xfs_inode, whichfork)

** xfs_bmap_wants_extents(xfs_inode, whichfork)
   - 检查xfs_inode是否需要使用数组方式存储xfs_bmbt_rec
   - 如果xfs_ifork现在使用XFS_DINODE_FMT_BTREE
   > XFS_IFORK_FORMAT(xfs_inode, whichfork)
   - 而且xfs_bmbt_rec数量低于上面的限制
   > XFS_IFORK_MAXEXT(xfs_inode, whichfork)

** xfs_bmbt_update(xfs_btree_cur, xfs_fileoff_t, xfs_fsblock_t, xfs_filblks_t, xfs_exntst_t)
   - 更新xfs_btree_cur当前指向的xfs_bmbt_rec
   - 根据参数构造xfs_bmbt_rec, 它使用磁盘数据类型
   > xfs_bmbt_disk_set_allf(xfs_bmbt_cur->xfs_bmbt_irec, off, bno, len, state)
   - 复制到xfs_buf的对应的位置
   > xfs_btree_update(xfs_btree_cur, xfs_btree_rec)
   - xfs_bmbt_irec中数据单位应该都是fsb

** xfs_bmap_worst_indlen(xfs_inode, xfs_filblks_t len)
   - len表示文件数据块的长度,也可以算xfs_bmbt_irec的长度
   - xfs_bmbt_irec的长度有时是无效的,可能用于delay allocation??
   - 最坏情况下,可能需要len个xfs_bmbt_irec,计算需要的btree结点的个数
   - 这里计算使用分支最大的情况, 使用level从0到最大高度遍历
   - 计算每一层使用的分支节点数
   > XFS_BM_MAXLEVELS(xfs_mount, XFS_DATA_FORK)
   - 使用xfs_mount->m_bmap_dmxr[2]表示分支

** xfs_default_attroffset(xfs_inode)
   - 计算xfs_dinode中attr fock的默认开始位置
   - 如果xfs_sb->sb_inodesize == 256, 只会留下空间保存一个根结点，根结点有2个分支
   > XFS_LITINO(xfs_mount, xfs_icdinode->di_version) - XFS_BMDR_SPACE_CALC(MINABTPTRS)
   - 否则预留空间保存一个根结点，结点包含MINABTPTRS*6/12个分支
   > XFS_BMDR_SPACE_CALC( 6 * MINABTPTRS)

** xfs_bmap_forkoff_reset(xfs_mount, xfs_inode, whichfork)
   - 重新设置xfs_icdinode->di_forkoff, attr fork数据改为使用XFS_DINODE_FMT_EXTENTS, 预留空间给data fork
   - 操作attr fork, whichfork是XFS_ATTR_FORK, 文件是regular
   - 重新计算dfl_forkoff
   > xfs_default_attroffset(xfs_inode) 
   - 当dlf_forkoff > xfs_icdinode->di_forkoff时才设置，用来增加data fork的空间
   - xfs_inode->icdinode->di_forkoff = dfl_forkoff / 8 

** xfs_bmap_sanity_check(xfs_mount, xfs_buf)
   - xfs_buf里面是xfs_btree_block,验证它的有效性
   - 检查magic, level
   - numrecs !=0, 也不超过最大分支xfs_mount->m_bmap_dmxr[level!=0]

** xfs_bmap_get_bp(xfs_btree_cur, xfs_fsblock_t bno)
   - 查找xfs_btree_cur路径中使用bno的xfs_buf
   - 查找xfs_btree_cur->bc_bufs中的xfs_buf, 它应该是是从跟到叶子节点的路径
   - XFS_BUF_ADDR(xfs_btree_cur->bc_bufs[i])
   - 然后遍历xfs_btree_cur->bc_tp->t_items
   - 查找里面的xsf_buf_log_item, 使用xfs_log_item->li_type == XFS_LI_BUF过滤
   > XFS_BUF_ADDR(xfs_buf_log_item->xfs_buf)

** xfs_check_block(xfs_btree_block, xfs_mount, root, sz)
   - xfs_btree_block是btree的内部节点, sz是结点大小
   - 检查key是否是有序的, 检查ptr是否有重复的
   - 如果不满足,说明文件系统崩溃.. 
   - xfs_btree_block可能是根节点,在fork数据中
   > XFS_BMBT_KEY_ADDR(xfs_mount, xfs_btree_block, i)
   > XFS_BMAP_BROOT_PTR_ADDR(xfs_mount, xfs_btree_block, i, sz)
   > XFS_BMAP_PTR_ADDR(xfs_mount, xfs_btree_block, i, dmxr)
   - (key,value)的点对数 
   > xfs_btree_get_numrecs(xfs_btree_block)

** xfs_bmap_check_leaf_extents(xfs_btree_cur, xfs_inode, whichfork)
   - 检查btree中所有xfs_bmbt_rec数据的有效性
   - 只检查叶子结点和到第一个叶子的路径上的内部结点
   - 如果xfs_inode->xfs_icdinode->di_format不是XFS_DINODE_FMT_BTREE, 直接退出
   - 获取xfs_ifork中的跟节点xfs_btree_block, xfs_ifork->if_broot
   - 这里xfs_btree_block的数据结构是大端数据类型的
   - 检查根结点的成员, level,key,value
   > xfs_check_block(xfs_btree_block, xfs_mount, 1, xfs_ifork->if_broot_bytes)xo
   - 然后检查btree的叶子节点的数据有效性
   - 这里没有全部遍历内部节点
   - 首先找到第一个叶子节点,使用内部节点的第一个分支
   - 先取出xfs_buf
   > xfs_bmap_get_bp(xfs_btree_cur, XFS_FSB_TO_DADDR(xfs_mount, bno))
   > xfs_btree_read_bufl(xfs_mount, NULL, bno, 0, xfs_buf, XFS_BMAP_BTREE_REF, xfs_bmbt_buf_ops)
   - 获取xfs_btree_block 
   > XFS_BUF_TO_BLOCK(xfs_buf)
   - 检查成员的有效性 
   > xfs_check_block(xfs_btree_block, xfs_mount, 0, 0)
   - 获取第一个分支的value 
   > XFS_BMBT_PTR_ADDR（xfs_mount, xfs_btree_block, 1, xfs_mount->m_bmap_dmxr[1])
   - 如果level不是0, 需要继续查找
   - 找到第一个叶子节点,使用xfs_btree_block->bb_u->l->bb_rightsib遍历所有的叶子节点
   - 对于每个叶子节点,检查它成员的有效性
   > XFS_BMBT_REC_ADDR(xfs_mount, xfs_btree_block, j)
   - 检查xfs_bmbt_rec, 他也是大端定义的
   - 他们指向的文件范围不能交叉
   > xfs_bmbt_disk_get_startoff(xfs_bmbt_rec)
   > xfs_bmbt_disk_get_blockcount(xfs_bmbt_rec)
   - 相邻2个叶子节点也必须比较

** xfs_bmap_trace_extlist(xfs_inode, xfs_extnum_t, whichfork, caller_ip)
   - bmap trace insert entry??

** xfs_bmap_validate_ret(xfs_fileoff_t bno, xfs_filblks_t len, flags, xfs_bmbt_irec, nmap, ret_nmap)
   - 检查xfs_bmbt_irec数组, 里面时文件数据的磁盘位置信息, 在写操作中使用
   - 遍历每个xfs_bmbt_irec
   - xfs_bmbt_irec->br_blockcount >0, 它表示范围
   - 如果flags没有XFS_BMAPI_ENTIRE,(br_startoff,br_blockcount)必须在(bno,len)范围内
   - XFS_BMAPI_ENTIRE表示返回整个xfs_bmbt_rec? 没有经过裁剪! 没有裁剪返回必须是覆盖???
   - 否则两个范围必须交叉
   - 而且相邻2个xfs_bmbt_irec不能交叉
   - br_startblock不能是DELAYSTARTBLOCK和HOLESTARTBLOCK
   - br_state必须是XFS_EXT_NORM, XFS_EXT_UNWRITTEN

** xfs_bmap_add_free(xfs_fsblock_t bno, xfs_filblks_t len, xfs_bmap_free_t flist, xfs_mount)
   - 构造xfs_bmap_free_item, 记录(bno, len)
   - 把它放到参数xfs_bmap_free->xbf_first的链表中
   - 里面节点按照xfs_bmap_free_item->xbfi_startblock排序
   - 这里有大量的检查
   - bno不能是NULLFSBLOCK(-1),或其他无效地址, 必须是有效的磁盘地址, len>0
   - isnullstartblock(bno)

   - 这里bno分成2部分,一部分是STARTBLOCKVALBITS(17), 另一部分是STARTBLOCKMASKBITS(35), 也就是做为无效地址时,仅仅使用低17位??

   - 对于xfs_fsblock_t的磁盘地址,分成AGNO和AGB, 前面是AG序号,后面是AG内部偏移
   - AGB的位数根据AG大小而定, xfs_sb->sb_agblklog, 单位是FSB, xfs_mount->m_blkbb_log, xfs_sb->sb_blocksize


** xfs_bmap_del_free(xfs_bmap_free, xfs_bmap_free_item prev, xfs_bmap_free_item)
   - free是xfs_bmap_free->xbf_first链表上的节点, 删除free
   - 减小xfs_bmap_free->xbf_count --

** xfs_bmap_cancel(xfs_bmap_free)
   - 直接释放xfs_bmap_free的xfs_bmap_free_item节点

** xfs_bmap_btree_to_extents(xfs_trans, xfs_inode, xfs_btree_cur, logflags, whichfork)
   - xfs_ifork中xfs_bmbt_rec_host的管理和磁盘的xfs_bmbt_rec是分开的
   - 现在xfs_bmbt_rec还是使用XFS_DINODE_FMT_BTREE, 要改为使用XFS_DINODE_FMT_EXTENTS格式
   - 现在xfs_ifork还管理着xfs_btree_block, 需要释放它

   - 检查参数现在的状态, 获取xfs_ifork
   > XFS_IFORK(xfs_inode, whichfork)
   - xfs_ifork->if_flags有XFS_IFEXTENTS, xfs_bmbt_rec都缓存到内存中
   - xfs_icdinode->di_format是XFS_DINODE_FMT_BTREE
   > XFS_IFORK_FORMAT(xfs_inode, whichfork)
   - 获取xfs_ifork中的根结点xfs_btree_block, xfs_ifork->if_broot, 只有一个分支，而且高度是1
   - xfs_btree_block->bb_level ==1
   - xfs_btree_block->bb_numrecs ==1
   - xfs_bmbt_maxrecs(xfs_mount, xfs_ifork->if_broot_bytes, 0) ==1
   - xfs_ifork使用xfs_btree_block和磁盘中xfs_bmdr_block不完全一样, 仅仅缓冲它数据
   - xfs_btree_block的头包含比xfs_bmdr_block更多的数据
   - 而且根结点中的分支信息xfs_bmdr_key/xfs_bmdr_ptr使用的内存和xfs_btree_block一块, 整个内存大小是if_btree_bytes
   - 如果根结点中分支数量变化,需要重新分配内存块,修改数据
   - 它不是xfs_bmdr_block的大小, 不是磁盘中结点的大小, 它表示内存中结点的大小

   - 读出叶子节点, 也就是分支的指针
   - xfs_btree_ptr指向的就是叶子结点磁盘位置
   - 为何不直接使用xfs_btree_cur中的结点信息???
   > XFS_BMAP_BROOT_PTR_ADDR(xfs_mount, xfs_broot_block, 1, xfs_ifork->if_broot_bytes)
   > xfs_btree_read_bufl(xfs_mount, xfs_trans, cbno, XFS_BMAP_BTREE_REF, xfs_bmbt_buf_ops)

   - 检查获取的xfs_bmbt_block 
   > XFS_BUF_TO_BLOCK(xfs_buf)
   > xfs_btree_check_block(xfs_btree_cur, xfs_btree_block, 0, xfs_buf)

   - 释放叶子节点使用的block
   > xfs_bmap_add_free(cbno, 1, xfs_btree_cur->bc_private->xfs_bmap_free, xfs_mount)
   - 减小xfs_inode->xfs_icdinode->di_nblocks --

   - 为何无效transaction? log xfs_buf? 这里释放xfs_buf?
   > xfs_trans_binval(xfs_trans, xfs_buf)

   - 完全释放xfs_ifork使用的xfs_btree_block
   > xfs_iroot_realloc(xfs_inode, -1, whichfork)
   - 检查xfs_ifork->if_broot == NULL, if_flags没有XFS_IFBROOT

   - 设置xfs_inode->xfs_icdinode->di_format
   > XFS_IFORK_FMT_SET(xfs_inode, whichfork, XFS_DINODE_FMT_EXTENTS)
   - 最后设置返回参数logflags = XFS_ILOG_CORE|xfs_ilog_fext(whichfork)

   - 这里对于xfs_icdinode的修改只有di_format,整个data fork的修改在哪里??

** xfs_bmap_extents_to_btree(xfs_trans, xfs_inode, xfs_fsblock_t firstblock, xfs_bmap_free, xfs_btree_cur, wasdel, logflags, whichfork)
   - 把xfs_bmbt_rec的存储从XFS_DINODE_FMT_EXTENTS,变为XFS_DINODE_FMT_BTREE
   - 需要在xfs_ifork中创建xfs_btree_block, 以及对应的节点,应该只需要一个

   - 获取当前xfs_ifork 
   > XFS_IFORK_PTR(xfs_inode, whichfork)
   - 现在xfs_icdinode->di_format是XFS_DINODE_FMT_EXTENTS
   > XFS_IFORK_FORMAT(xfs_inode, whichfork) == XFS_DINODE_FMT_EXTENTS

   - 创建xfs_ifork使用的xfs_btree_block
   > xfs_iroot_realloc(xfs_inode, 1, whichfork)
   - 设置xfs_ifork->if_flags的XFS_IFBROOT

   - 初始化xfs_ifork->xfs_btree_block 
   > xfs_btree_init_block_int(xfs_mount, xfs_btree_block, XFS_BUF_DADDR_NULL, XFS_BMAP_CRC_MAGIC, 1,1, xfs_inode->i_ino, XFS_BTREE_LONG_PTR|XFS_BTREE_CRC_BLOCKS)
   - 只有一个分支, 设置owner为ino, 磁盘位置为XFS_BUF_DADDR_NULL

   - 准备xfs_btree_cur 
   > xfs_bmbt_init_cursor(xfs_mount, xfs_trans, xfs_inode, whichfork)
   - 初始化xfs_btree_cur->pc_private->b,应该用于磁盘为配

   - 修改xfs_icdinode->di_format
   > XFS_IFORK_FMT_SET(xfs_inode, whichfork, XFS_DINODE_FMT_BTREE)

   - 准备xfs_alloc_arg, 准备分配block
   - 设置xfs_alloc_arg->fsbno = firstblock
   - 如果firstblock == NULLFSBLOCK, 使用inode的位置
   - 设置xfs_alloc_arg->type = XFS_ALLOCTYPE_START_BNO
   - 设置xfs_alloc_arg->fsbno = XFS_INO_TO_FSB(xfs_mount, xfs_inode->i_ino)
   - 如果不是NULLFSBLOCK, 而且xfs_bmap_free->xbf_low !=0, 分配连续的空间? 
   - 设置xfs_alloc_arg->type = XFS_ALLOCTYPE_START_BNO
   - 设置xfs_alloc_arg->fsbno = firstblock
   - 否则就近分配?
   - 设置xfs_alloc_arg->type = XFS_ALLOCTYPE_NEAR_BNO
   - 设置xfs_alloc_arg->fsbno = firstblock
   - 设置xfs_alloc_arg->minlen = maxlen = prod = 1
   > xfs_alloc_vextent(xfs_alloc_arg)
   - 分配不能失败? 因为已经reserve空间
   - 把xfs_alloc_arg->fsbno给xfs_btree_cur->bc_private->b_firstblock?
   - 增加xfs_btree_cur->bc_private->b_allocated ++

   - 增加xfs_icdinode->di_nblocks++
   - 准备一个xfs_buf, 操作这个block, 只是分配内存建立影射
   - 可能这个block对应的xfs_buf已经存在,可以直接使用
   > xfs_btree_get_bufl(xfs_mount, xfs_trans, xfs_alloc_arg->fsbno, 0)

   - xfs_buf作为叶子节点, 设置xfs_buf->b_ops = xfs_bmbt_buf_ops
   - 首先初始化xfs_btree_block, 没有xfs_bmbt_rec
   > xfs_btree_init_block_int(xfs_mount, xfs_btree_block, xfs_buf->b_bn, XFS_BMAP_CRC_MAGIC, 0, 0, xfs_inode->i_ino, XFS_BTREE_LONG_PTR|XFS_BTREE_CRC_BLOCKS)

   - 然后把xfs_ifork中的xfs_bmbt_rec_host写到xfs_btree_block中
   > xfs_iext_get_ext(xfs_ifork, i)
   - 过滤掉没有有效磁盘空间的, 有没有0的??
   > isnullstartblock(xfs_bmbt_get_startblock(xfs_bmbt_rec_host))
   - 这里需要把xfs_bmbt_rec_host转化为xfs_bmbt_rec,做数据类型转化

   - xfs_bmbt_rec的数量必须和xfs_icdinode->di_nextents相同?? 如何保证上面过滤掉的?? 
   - 指向无效磁盘空间的xfs_bmbt_rec_host不会写到磁盘中??
   > XFS_IFORK_NEXTENTS(xfs_inode, whichfork)

   - 设置xfs_btree_block->bb_numrecs
   > xfs_btree_set_numrecs(xfs_btree_block, cnt)
   - 初始化xfs_ifork->xfs_btree_block根结点, 加入这个分支
   > XFS_BMBT_KEY_ADDR(xfs_mount, xfs_btree_block, 1)
   - 第一个分支的key就是叶子节点第一个xfs_bmbt_rec的startoff
   > XFS_BMBT_REC_ADDR(xfs_mount, xfs_btree_block, 1)
   > xfs_bmbt_disk_get_startoff(xfs_bmbt_rec)
   - 设置第一个分支的指针就是上面xfs_buf的磁盘地址
   > XFS_BMBT_PTR_ADDR(xfs_mount, xfs_btree_block, 1, xfs_bmbt_get_maxrecs(xfs_btree_cur, level))

   - 然后log叶子节点的改动
   - 首先是xfs_btree_block
   > xfs_btree_log_block(xfs_btree_cur, xfs_btree_block, XFS_BB_ALL_BITS)
   - 然后是xfs_bmbt_rec数组
   > xfs_btree_log_recs(xfs_btree_cur, xfs_btree_block, 1, xfs_btree_block->bb_numrecs)
   - 最后设置logflags
   - XFS_ILOG_CORE|xfs_ilog_fbroot(whichfork)

   - 这里修改的包括btree的叶子节点, xfs_ifork中的xfs_btree_block
   - xfs_icdinode->di_format, 以及di_nblocks
   - 完全没有修改xfs_icdinode的data fork

** xfs_bmap_local_to_extents_empty(xfs_inode, whichfork)
   - 把fork的磁盘格式从XFS_DINODE_FMT_LOCAL改为XFS_DINODE_FMT_EXTENTS, 虽然是空的extent数组
   - 操作的不是regular文件的data fork!
   - 现在xfs_icdinode->di_format是XFS_DINODE_FMT_LOCAL
   > XFS_IFORK_FORMAT(xfs_inode, whichfork)
   - 而且现在xfs_ifork->if_bytes ==0, extent数量是0, extent是什么数据? 
   > XFS_IFORK_NEXTENTS(xfs_inode, whichfork)
   - 重新计算di_forkoff 
   > xfs_bmap_forkoff_reset(xfs_mount, xfs_inode, whichfork)
   - 去掉xfs_ifork->if_flags的XFS_IFINLINE, 设置XFS_IFEXTENTS 
   - 还有di_format的XFS_DINODE_FMT_EXTENTS 
   > XFS_IFORK_FMT_SET(xfs_inode, whichfork, XFS_DINODE_FMT_EXTENTS)

   - 这里修改的是xfs_icdinode->di_format/di_forkoff
   - 还有xfs_ifork->if_flags标志, 没有修改xfs_ifork中的数据

** xfs_bmap_local_to_extents(xfs_trans, xfs_inode, xfs_fsblock_t, xfs_extlen_t, logflag, whichfork, init_fn)
   - regular文件的data fork不使用XFS_DINODE_FMT_LOCAL, 所以这里操作的肯定不是regular的data fork, 可能其他文件或attr fork
   - 获取xfs_ifork 
   > XFS_IFORK_PTR(xfs_inode, whichfork)
   - 磁盘格式是XFS_DINODE_FMT_LOCAL 
   > XFS_IFORK_FORMAT(xfs_inode, whichfork)
   - 如果xfs_ifork->if_bytes是0,表示xfs_ifork没有管理任何数据,也就是xfs_icdinode的fork区域没有数据
   - 重新计算xfs_ifork的标志,和xfs_icdinode的id_forkoff/id_format, 直接退出
   > xfs_bmap_local_to_extents_empty(xfs_inode, whichfork)

   - 否则需要分配空间，使用xfs_bmbt_rec索引他们，而且把xfs_bmbt_rec放到fork区域
   - 检查xfs_ifork->if_flags, 现在应该只有XFS_IFINLINE

   - 分配磁盘空间, 准备xfs_alloc_arg
   - 设置xfs_alloc_arg->minlen, maxlen, prod是1
   - 设置xfs_alloc_arg->firstblock = 参数firstblock
   - 如果firstblock是NULLFSBLOCK 
   - 设置xfs_alloc_arg->fsbno 为inode的位置 
   > XFS_INO_TO_FSB(xfs_alloc_arg->xfs_mount, xfs_inode->i_ino)
   - 设置xfs_alloc_arg->type = XFS_ALLOCTYPE_START_BNO, 使用Inode后面的磁盘空间
   - 否则使用firstblock, 设置xfs_alloc_arg->fsbno = firstblock, 使用这个位置附近的磁盘空间 
   - 设置xfs_alloc_arg->type = XFS_ALLOCTYPE_NEAR_BNO
   > xfs_alloc_vextent(xfs_alloc_arg)

   - 构造xfs_buf, 分配内存空间准备写入空间的数据
   > xfs_btree_get_bufl(xfs_alloc_arg->xfs_mount, xfs_trans, xfs_alloc_arg->fsbno, 0)
   - 使用回调函数初始化, 应该是把xfs_ifork的inline数据写到xfs_buf中
   > init_fn(xfs_trans, xfs_buf, xfs_inode, xfs_ifork)
   - 然后记录xfs_buf的修改, 数据量是xfs_ifork->if_bytes
   > xfs_trans_log_buf(xfs_trans, xfs_buf, 0, xfs_ifork->if_bytes -1 )

   - 释放xfs_ifork的inline数据使用的内存
   > xfs_idata_realloc(xfs_inode, -xfs_ifork->if_bytes, whichfork)
   - xfs_ifork转化为保存xfs_bmbt_rec_host数组
   > xfs_bmap_local_to_extents_empty(xfs_inode, whichfork)
   - 目前只有一个xfs_bmbt_rec_host, 分配对应的内存空间, 应该还是使用xfs_ifork自己的空间
   > xfs_iext_add(xfs_ifork, 0, 1)
   - 初始化xfs_bmbt_rec_host
   > xfs_iext_get_ext(xfs_ifork, 0)
   - 把上面磁盘位置信息放进去, br_startoff是0
   > xfs_bmbt_set_allf(xfs_bmbt_rec_host, 0, xfs_alloc_arg->fsbno, 1, XFS_EXT_NORM)

   - 设置xfs_icdinode, di_anextents/di_nextents, di_nblocks = 1
   > XFS_IFORK_NEXT_SET(xfs_inode, whichfork, 1)

   - 计算logflags, 表示应该log xfs_inode的哪些数据, XFS_ILOG_CORE表示xfs_icdinode, 还有对应的fork
   - 添加对应的log标志 XFS_ILOG_DEXT
   > xfs_ilog_fext(whichfork)

   - 这里修改xfs_icdinode与fork相关的成员, 还有对应的fork部分的数据,把它的数据放到单独的block中
   - fork部分应该填入xfs_bmbt_rec数组,但这里没有实现???
   - 还需要重新设置xfs_ifork, 对应的管理xfs_bmbt_rec_host

   - xfs的inode的数据分成3部分, xfs_dinode/xfs_icdinode, 2个fork/xfs_ifork
   - xfs_icdinode/xfs_ifork是对磁盘中xfs_dinode所在的block的数据的缓存, 上面的修改都没有改动磁盘的数据，甚至写入对应的xfs_buf
   - 所以这里的修改只是操作xfs_icdinode, 缓存固定的metadata;和xfs_ifork,缓存fork的metadata
   - 内存和磁盘的数据最终必须是一致的，但他们管理使用不同的格式, xfs_icdinode和xfs_dinode可能使用相同的格式, xfs_ifork和fork使用完全不同的格式

** xfs_bmap_add_attrfork_btree(xfs_trans, xfs_inode, xfs_fsblock_t firstblock, xfs_bmap_free, flags)
   - 当attr fork要变为XFS_DINODE_FMT_BTREE格式, 但在xfs_dinode中对应的空间不够, 需要缩减data attr占用的空间
   - 而且data fork使用XFS_DINODE_FMT_BTREE, 通过增加它的高度，使根结点只有一个分支，来释放data fork的空间
   - 如果现在data fork占用的空间没有超过限制, 不需要释放, 直接返回
   - 设置flags的XFS_ILOG_DBROOT, 表示要log data fork的xfs_bmdr_block?
   - xfs_inode->xfs_ifork->if_broot_bytes <= XFS_IFORK_DSIZE(xfs_inode)
   - 否则增加xfs_ifork->xfs_btree_block的高度
   - 准备xfs_btree_cur
   > xfs_bmbt_init_cursor(xfs_mount, xfs_trans, xfs_inode, XFS_DATA_FORK)
   - 设置xfs_btree_cur->bc_private->b->xfs_bmap_free, firstblock为参数firstblock
   - 查找第一个叶子节点
   > xfs_bmbt_lookup_ge(xfs_btree_cur, 0, 0, 0, stat)
   - 分配一个新的根结点
   > xfs_btree_new_iroot(xfs_btree_cur, flags, stat)
   - 更新参数firstblock = xfs_btree_cur->bc_private->b->firstblock
   - 释放xfs_btree_cur 
   > xfs_btree_del_cursor(xfs_btree_cur, XFS_BTREE_NOERROR)

** xfs_bmap_add_attrfork_extents(xfs_trans, xfs_inode, xfs_fsblock_t firstblock, xfs_bmap_free, flags)
   - attr fork的空间太小, 需要压缩data fork的空间
   - 当前data fork使用XFS_DINODE_FMT_EXTENTS, 如果超过限制，变为使用XFS_DINODE_FMT_BTREE格式
   - 如果xfs_bmbt_rec_host的数量没有超过限制, 直接返回
   > xfs_inode->xfs_ifork->di_nextents * sizeof(xfs_bmbt_rec) <= XFS_IFORK_DSIZE(xfs_inode)
   - 否则xfs_ifork转化为XFS_DINODE_FMT_BTREE 
   > xfs_bmap_extents_to_btree(xfs_trans, xfs_inode, firstblock, xfs_bmap_free, xfs_btree_cur, 0, flags, XFS_DATA_FORK)

** xfs_bmap_add_attrfork_local(xfs_trans, xfs_inode, xfs_fsblock_t, xfs_bmap_free_t, flags)
   - attr fork空间太小, 需要压缩data fork的空间
   - 当前data fork使用XFS_DINODE_FMT_LOCAL, 转化为XFS_DINODE_FMT_EXTENTS格式
   - 现在data fork占用的空间是xfs_ifork->if_bytes
   > XFS_IFORK_DSIZE(xfs_inode)
   - 如果没有超过限制,直接返回, 否则需要转化
   - 如果是dir文件,使用xfs_da_args实现 
   > xfs_dir2_sf_to_block(xfs_da_args)
   - 如果是link文件, 分配一个block保存数据
   > xfs_bmap_local_to_extents(xfs_trans, xfs_inode, firstblock, 1, flags, XFS_DATA_FORK, xfs_symlink_local_to_remote)
   - 不可能是其他文件

** xfs_bmap_add_attrfork(xfs_inode, size, rsvd)
   - 向attr fork中写入数据, 数据量是size
   - 现在attr fork中没有数据, xfs_icdinode->di_forkoff==0, 表示attr fork空间为0
   > XFS_IFORK_Q(xfs_inode) ==0

   - 构造专门的xfs_trans
   > xfs_trans_alloc(xfs_mount, XFS_TRANS_ADDAFORK)
   - 估计可能占用的最多的磁盘空间, 这是reserve的FS磁盘空间, 下面xfs_mount->m_resv是reserve的log队列的空间
   > XFS_ADDAFORK_SPACE_RES(xfs_mount)
   - 如果rsvd >0, 设置xfs_trans->t_flags的XFS_TRANS_RESERVE, 表示磁盘空间不够时,使用预留的空间
   - reserve FS磁盘空间和log队列空间
   > xfs_trans_reserve(xfs_trans, xfs_mount->m_resv->tr_addafork, blks, 0)

   - 锁住xfs_inode
   > xfs_ilock(xfs_inode, XFS_ILOCK_EXCL)
   - 设置xfs_ifork->di_aformat为XFS_DINODE_FMT_EXTENTS, 都没有数据为何还要设置为XFS_DINODE_FMT_EXTENTS?

   - 创建xfs_inode使用的xfs_inode_log_item, 放到xfs_trans中
   > xfs_trans_ijoin(xfs_trans, xfs_inode, XFS_ILOCK_EXCL)
   - 把对xfs_icdinode的修改标注到xfs_inode_log_item中
   > xfs_trans_log_inode(xfs_trans, xfs_inode, XFS_ILOG_CORE)

   - 根据data fork的数据计算xfs_icdinode->di_forkoff,现在还是0
   - 对于XFS_DINODE_FMT_DEV, 就是sizeof(xfs_dev_t)/8
   - 对于XFS_DINODE_FMT_UUID, 就是sizeof(uuid_t) /8
   - 对于XFS_DINODE_FMT_LOCAL/EXTENTS/BTREE 
   > xfs_attr_shortform_bytes(xfs_inode, size)
   - 如果计算的无效,使用默认的 
   > xfs_default_attroffset(xfs_inode)

   - 创建attr fork使用的xfs_ifork
   - 设置xfs_ifork->if_flags的XFS_IFEXTENTS, attr fork直接使用xfs_bmbt_rec_host管理空间??

   - 初始化xfs_bmap_free, 都从新设为0, 用来分配空间
   - 重新计算data fork的存储格式, di_format
   - 如果使用过量的空间,需要转化为其他格式,释放空间给attr fork
   - 如果是XFS_DINODE_FMT_LOCAL,可能转化为XFS_DINODE_FMT_EXTENTS
   > xfs_bmap_add_attrfork_local(xfs_trans, xfs_inode, firstblock, xfs_bmap_free, logflags)
   - 如果是XFS_DINODE_FMT_EXTENTS, 可能转化为XFS_DINODE_FMT_BTREE
   > xfs_bmap_add_attrfork_extents(xfs_trans, xfs_inode, firstblock, xfs_bmap_free, logflags)
   - 如果是XFS_DINODE_FMT_BTREE, 可能增加高度
   > xfs_bmap_add_attrfork_btree(xfs_trans, xfs_inode, firstblock, xfs_bmap_free, logflags)

   - 根据上面的logflags, 计算xfs_inode_log_item的标志
   > xfs_trans_log_inode(xfs_trans, xfs_inode, logflags)
   - 上面的操作应该不会释放空间!! 
   - 如果有的话, 释放这些空间, 创建对应的xfs_efd_log_item
   > xfs_bmap_finish(xfs_trans, xfs_bmap_free, committed)

   - 提交xfs_trans, 可能不是开始的xfs_trans, 上面释放空间时就会替换为新的
   > xfs_trans_commit(xfs_trans, XFS_TRANS_RELEASE_LOG_RES)

** xfs_bmap_read_extents(xfs_trans, xfs_inode, whichfork)
   - 把磁盘中btree中的xfs_bmbt_rec全部缓存到xfs_ifork中
   - 只需要先找到第一个叶子节点,然后使用右兄弟指针，遍历所有的叶子节点

   - 首先获取xfs_ifork, 以及btree的根结点xfs_btree_block / xfs_ifork->if_broot
   > XFS_IFORK_PTR(xfs_inode, whichfork)
   - 根据节点的第一个分支,找到第一个叶子节点
   - 获取根结点第一个分支指针
   > XFS_BMAP_BROOT_PTR_ADDR(xfs_mount, xfs_btree_block, 1, xfs_ifork->if_broot_bytes)
   - 循环向下遍历, 使用xfs_buf读取节点的数据
   > xfs_btree_read_bufl(xfs_mount, xfs_trans, bno, 0, xfs_buf, XFS_BMAP_BTREE_REF, xfs_bmbt_buf_ops)
   - 获取xfs_btree_block, XFS_BUF_TO_BLOCK(xfs_buf)
   - 获取第一个分支指针 
   > XFS_BMBT_PTR_ADDR(xfs_mount, xfs_btree_block, 1, xfs_mount->m_bmap_dmxr[1])
   - 然后释放xfs_buf, 使用上面指针的地址继续循环
   > xfs_trans_brelse(xfs_trans, xfs_buf)
   
   - 然后遍历这些叶子节点,获取对应的xfs_bmbt_rec数据, 把数据复制给xfs_ifork
   - xfs_bmbt_rec数组长度不能xfs_ifork->if_bytes, 也就是xfs_dinode->di_nextents/di_anextents

   - 开始处理一个叶子节点, 获取xfs_btree_block
   - 检查它包含的xfs_bmbt_rec的数量, 不能超过上面xfs_ifork的限制
   > xfs_btree_get_numrecs(xfs_btree_block)
   - 检查xfs_buf的xfs_btree_block成员
   > xfs_bmap_sanity_check(xfs_mount, xfs_buf, 0)
   - 首先预读右兄弟节点
   > xfs_btree_reada_bufl(xfs_mount, nextbno, 1, xfs_bmbt_buf_ops)

   - 遍历叶子节点里面的xfs_bmbt_rec数组
   - 放到xfs_ifork中, 转化数据类型为xfs_bmbt_rec_host
   > xfs_iext_get_ext(xfs_ifork, i)
   - 检查xfs_bmbt_irec->br_state
   > xfs_check_nostate_extents(xfs_ifork, start, num_recs)
   - 处理完成释放xfs_buf 
   > xfs_trans_brelse(xfs_trans, xfs_buf)
   - 读取兄弟叶子节点, 继续循环
   > xfs_btree_read_bufl(xfs_mount, xfs_trans, bno, 0, xfs_buf, XFS_BMAP_BTREE_REF, xfs_bmbt_buf_ops)

** xfs_bmap_search_multi_extents(xfs_ifork, xfs_fileoff_t bno, eof, xfs_extnum_t, xfs_bmbt_iret got, xfs_bmbt_irec prev)
   - 在xfs_ifork中查找bno对应的xfs_bmbt_rec_host, 它应该覆盖bno
   - xfs_extnum_t是xfs_bmbt_rec_host的索引
   - 后面2个参数是结果,prev指向前一个xfs_bmbt_rec, got指向要查找的结果

   - 查找xfs_ifork的xfs_bmbt_rec_host矩阵
   > xfs_iext_bno_to_ext(xfs_ifork, bno, lastx)
   - 如果找不到xfs_bmbt_rec_host覆盖bno, lastx指向下一个 
   - 如果bno超过文件大小, lastx = xfs_ifork->if_bytes, 也就是最后一个xfs_bmbt_rec后面一个无效位置

   - 如果返回的lastx>0,他可能是无效的, 但lastx-1是有效的
   - 获取前一个xfs_bmbt_rec_host, 转化为xfs_bmbt_irec
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, lastx-1), xfs_bmbt_irec)
   - 否则prev设为无效, br_startoff = NULLFILEOFF(-1)

   - 如果lastx有效表示找到xfs_bmbt_rec_host, 即使它可能不覆盖bno
   - 设置eofp = 0, 获取对应的xfs_bmbt_irec给got, 返回这个xfs_bmbt_rec_host, 虽然

   - 否则表示没有找到, 设置eofp = 1, 使got和prev一样, 返回NULL
   > xfs_bmbt_get_all(xfs_bmbt_rec_host, xfs_bmbt_irec)

   - 如果xfs_ifork中没有xfs_bmbt_rec_host, 什么都返回NULL, eof=1
   - 如果xfs_ifork中有xfs_bmb_rec_host
   - 如果bno超过文件大小,eof=1, 而且prev/got/lastidx都指向最后一个, 返回NULL
   - 如果bno没有超过eof,没有hole, got/xfs_bmbt_rec_host/lastidx指向找到的, eof=0
   - 如果bno没有超过eof,有hole, got/xfs_bmbt_rec_host/lastidx指向bno后面的xfs_bmbt_rec, eof =0
   - 如果bno没有超过eof,但是第一个, prev->br_startoff是NULLFILEOFF, 否则指向got前面的xfs_bmbt_rec
     
** xfs_bmap_search_extents(xfs_inode, xfs_fileoff_t, fork, eofp, xfs_extnum_t lastexp, xfs_bmbt_irec gotp, xfs_bmbt_irec prep)
   - 在xfs_ifork中查找xfs_bmbt_rec_host / xfs_bmbt_irec
   > XFS_IFORK_PTR(xfs_inode, whichfork)
   > xfs_bmap_search_multi_extents(xfs_ifork, bno, eof, lastxp, xfs_bmbt_irec gotp, prevp)
   - 检查返回的结果, xfs_bmbt_irec->br_startblock不能是0???

** xfs_bmap_first_unused(xfs_trans, xfs_inode, xfs_extlen_t len, xfs_fileoff_t first_unused, whichfork)
   - 查找first_unused后面的,长度超过len的hole的xfs_bmbt_rec_host, 返回它在xfs_ifork中的索引
   - 对于reg可以理解, 对于dir怎么回事?
   - xfs_icdinode->di_format/di_aformat必须是XFS_DINODE_FMT_BTREE/LOCAL/EXTENTS
   - 如果是XFS_DINODE_FMT_LOCAL, 直接返回0
   - 获取xfs_ifork 
   > XFS_IFORK_PTR(xfs_inode, whichfork)
   - 如果xfs_ifork->if_flags没有XFS_IFEXTENTS, 读取xfs_bmbt_rec数据
   > xfs_iread_extents(xfs_trans, xfs_inode, whichfork)
   - 遍历所有的xfs_bmbt_rec_host, 查找一个xfs_bmbt_rec_host,它和前一个之间没有临接,而且距离超过len
   - 为何不先查找first_unused对应的xfs_bmbt_rec_host? 
   > xfs_iext_get_ext(xfs_ifork, index)
   - max表示前一个xfs_bmbt_rec_host的结束位置
   - off表示当前xfs_bmbt_rec_host的开始位置
   > xfs_bmbt_get_startoff(xfs_bmbt_rec_host)
   - 比较max和off,判断在两个xfs_bmbt_rec_host之间是否存在空洞
   - off >= lowest+len 保证下面的比较不会溢出?
   - off-max >= len, hole长度超过len
   - 如果找到first_unused返回max, 也就是空洞的开始位置, 否则返回eof, 最后一个xfs_bmbt_rec_host的结束位置

** xfs_bmap_last_before(xfs_trans, xfs_inode, xfs_fileoff_t last_block, whichfork)
   - 查找last_block之前的使用磁盘的文件位置, 如果它本来就有磁盘位置,不需要修改
   - 在directory操作中使用
   - 先检查di_format/di_aformat, 必须是XFS_DINODE_FMT_BTREE/LOCAL/EXTENTS
   - 如果是XFS_DINODE_FMT_LOCAL, 返回0
   - 获取xfs_ifork, 准备xfs_bmbt_rec_host 
   > xfs_iread_extents(xfs_trans, xfs_inode, whichfork)
   - 查找last_block-1对应的xfs_bmbt_rec_host
   > xfs_bmap_search_extents(xfs_inode, bno, whichfork, eof, xfs_extnum_t, xfs_bmbt_irec got, xfs_bmbt_irec prev)
   - 如果eof==1, 表示超出文件范围, 或者找到的xfs_bmbt_rec_host没有覆盖bno, 说明last_block处没有磁盘信息
   - 如果prev->br_startoff是NULLFILEOFF, 表示文件没有xfs_bmbt_rec信息, 设置last_block=0
   - 否则它在空洞里面, 更新为前面的xfs_bmbt_irec的结束位置
   > xfs_bmbt_irec->br_startoff + br_blockcount

** xfs_bmap_last_extent(xfs_trans, xfs_inode, whichfork, xfs_bmbt_irec, is_empty)
   - 获取最后一个xfs_bmbt_irec
   - 如果xfs_ifork->if_flags没有XFS_IFEXTENTS, 首先读取磁盘的xfs_bmbt_rec 
   > xfs_iread_extents(xfs_trans, xfs_inode, whichfork)
   - 根据xfs_ifork->if_bytes计算最后一个xfs_bmbt_rec索引数
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, nextents-1), xfs_bmbt_irec)
   - 如果没有xfs_bmbt_rec_host数据,设置is_empty = 1

** xfs_bmap_isaeof(xfs_bmalloca, whichfork)
   - 用来计算xfs_bmalloca->aeof, 表示要创建的xfs_bmbt_rec是否在文件最后
   - 获取最后一个xfs_bmbt_rec 
   > xfs_bmap_last_extent(NULL, xfs_bmalloca->xfs_inode, whichfork, xfs_bmbt_irec, is_empty)
   - 检查xfs_bmalloca->offset是否超过eof
   - 如果上面返回is_empty = 1, 没有xfs_bmbt_rec信息, 设置aeof=1, 任何分配都超过eof
   - 如果xfs_bmalloca->offset >= xfs_bmbt_irec->br_startoff + br_blockcount, 设置aeof =1
   - 如果它在最后一个xfs_bmbt_rec_irec范围内,而且它没有磁盘空间, 设置aeof=1
   > isnullstartblock(xfs_bmbt_irec->br_startblock)

   - 这时分配空间需要对齐地址??

** xfs_bmap_last_offset(xfs_trans, xfs_inode, xfs_fileoff_t, whichfork)
   - 获取文件最大偏移, 使用xfs_bmbt_rec_host数据计算
   - 如果是XFS_DINODE_FMT_LOCAL, 返回0
   - 如果不是XFS_DINODE_FMT_BTREE/EXTENTS,返回EIO
   - 获取最后一个xfs_bmbt_irec
   > xfs_bmap_last_extent(NULL, xfs_inode, whichfork, xfs_bmbt_irec, is_empty)
   - 设置last_block = xfs_bmbt_irec->br_startoff + br_blockcount

** xfs_bmap_one_block(xfs_inode, whichfork)
   - 检查data/attr fork是否只有一个block, 在attr操作中使用
   - 如果xfs_icdinode->di_nextents/di_anextents !=1, 返回0, 只能有一个节点
   > XFS_IFORK_NEXTENTS(xfs_inode, whichfork)
   - 如果不是XFS_DINODE_FMT_EXTENTS, 返回0, btree还需要包括根结点??
   - 获取第一个xfs_bmbt_irec 
   > XFS_IFORK_PTR(xfs_inode, whichfork)
   > xfs_iext_get_ext(xfs_ifork, 0)
   > xfs_bmbt_get_all(xfs_bmbt_rec_hsot, xfs_bmbt_irec)
   - bt_startoff ==0, 而且br_blockcount ==1
   - 如果是data fork, xfs_inode->i_size必须是sb_blocksize, 上面映射的文件长度是1

** xfs_bmalloca 
   #+BEGIN_SRC 
	xfs_fsblock_t		*firstblock; /* i/o first block allocated */
	struct xfs_bmap_free	*flist;	/* bmap freelist */
	struct xfs_trans	*tp;	/* transaction pointer */
	struct xfs_inode	*ip;	/* incore inode pointer */
	struct xfs_bmbt_irec	prev;	/* extent before the new one */
	struct xfs_bmbt_irec	got;	/* extent after, or delayed */

	xfs_fileoff_t		offset;	/* offset in file filling in */
	xfs_extlen_t		length;	/* i/o length asked/allocated */
	xfs_fsblock_t		blkno;	/* starting block of new extent */

	struct xfs_btree_cur	*cur;	/* btree cursor */
	xfs_extnum_t		idx;	/* current extent index */
	int			nallocs;/* number of extents alloc'd */
	int			logflags;/* flags for transaction logging */

	xfs_extlen_t		total;	/* total blocks needed for xaction */
	xfs_extlen_t		minlen;	/* minimum allocation size (blocks) */
	xfs_extlen_t		minleft; /* amount must be left after alloc */
	char			eof;	/* set if allocating past last extent */
	char			wasdel;	/* replacing a delayed allocation */
	char			userdata;/* set if is user data */
	char			aeof;	/* allocated space at eof */
	char			conv;	/* overwriting unwritten extents */
	char			stack_switch;
	int			flags;
	struct completion	*done;
	struct work_struct	work;
	int			result;   
   #+END_SRC

** xfs_bmap_add_extent_delay_real(xfs_bmalloca)
   - xfs_bmalloca分配空间之后, 更新xfs_ifork中的xfs_bmbt_rec_host
   - 原来是xfs_bmbt_irec指向无效地址空间,也就是delalloc, 转化为使用有效的磁盘空间
   - xfs_bmalloca->got是新的xfs_bmbt_irec, new, 对应旧的是xfs_bmalloca->idx指向的xfs_bmbt_rec_host
   - 获取data fork, xfs_bmalloca->xfs_inode->xfs_ifork 
   > XFS_IFORK_PTR(xfs_inode, XFS_DATA_FORK)
   - 检查xfs_bmalloca的参数
   - xfs_bmalloca->idx是xfs_bmbt_irec在extents数组中的索引
   - 新的xfs_bmbt_rec->br_startblock是有效的
   > isnullstartblock(xfs_bmbt_irec->br_startblock)
   - xfs_bmalloca->xfs_btree_cur->bc_private->b->flags必须有XFS_BTCUR_BPRV_WASDEL, 分配磁盘时使用wasdel参数

   - 获取旧的xfs_ifork中对应的xfs_bmbt_rec_host
   > xfs_iext_get_ext(xfs_ifork, xfs_bmalloca->idx)
   - 转化为xfs_bmbt_irec, prev
   > xfs_bmbt_get_all(xfs_bmbt_rec_host, xfs_bmbt_irec)
   - prev的范围必须覆盖new

   - 检查new和2端xfs_bmbt_irec的关系, 计算更新xfs_bmbt_rec_host的方法state
   - 如果new和prev的start文件偏移重复,设置BMAP_LEFT_FILLING, BMAP_RIGHT_FILLING
   - 如果2端有xfs_bmbt_irec,也就是不在文件数据开头和末尾
   - 根据idx判断， 设置BMAP_LEFT_VALID, BMAP_RIGHT_VALID
   - 如果2端的xfs_bmbt_irec没有指向有效的磁盘空间, delalloc, 设置XFS_LEFT_DELAY, XFS_RIGHT_DELAY
   > isnullstartblock(xfs_bmbt_irec->br_startblock)
   - 如果2端xfs_bmbt_irec有磁盘位置, 检查是否和new连续, 设置BMAP_LEFT_CONTIG, BMAP_RIGHT_CONTIG
   - state & BMAP_LEFT_VALID, 左边xfs_bmbt_irec存在
   - state没有BMAP_LEFT_DELAY, 左边xfs_bmbt_irec不是delalloc,指向有效的磁盘位置
   - left->br_startoff + left->br_blockcount == new->br_startoff
   - left->br_startblock + left->br_blockcount == new->br_startblock
   - left->br_state == new->br_state?? 这里会是什么?
   - left->br_blockcount + new->br_blockcount <= MAXEXTLEN, 合并之后长度没有超过限制
   - 检查right的xfs_bmbt_irec时,还要考虑3个extent合并是否超过MAXEXTLEN

   - 如果state == BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG, 合并3个extent
   - 修改xfs_bmalloca->idx-1,合并后的xfs_bmbt_irec使用idx-1对应的xfs_bmbt_rec_host
   - 设置idx对应的xfs_bmbt_rec_host的blockcount 
   > xfs_bmbt_set_blockcount(xfs_iext_get_ext(xfs_ifork, xfs_bmalloca->idx), LEFT->br_blockcount + PREV->br_blockcount + RIGHT->br_blockcount)
   - 删除多余的2个xfs_bmbt_rec_host 
   > xfs_iext_remove(xfs_bmalloca->xfs_inode, xfs_bmalloca->idx+1, 2, state) 
   - 修改xfs_inode->xfs_icdinode->di_nextents --, 
   - 删除右边xfs_bmbt_irec对应的xfs_bmbt_rec, 因为它有磁盘空间,所以它在btree中, 而中间的xfs_bmbt_irec是delalloc,没有在btree中
   - 如果xfs_bmalloca->xfs_btree_cur == NULL, 就不释放, 没有使用btree, 而是使用XFS_DINODE_FMT_EXTENTS?
   - 只是设置rval = XFS_ILOG_CORE | XFS_ILOG_DEXT
   - 否则删除右边的xfs_bmbt_rec, 设置rval = XFS_ILOG_CORE
   - 删除btree中的xfs_bmbt_rec不需要再log xfs_ifork
   > xfs_bmbt_lookup_eq(xfs_btree_cur, right->br_startoff, right->br_startblock, right->br_blockcount, i)
   > xfs_btree_delete(xfs_bmalloca->xfs_btree_cur, i)
   - 然后修改左边xfs_bmbt_rec的br_blockcount
   - 让xfs_bmbt_cur指向它
   > xfs_btree_decrement(xfs_bmalloca->xfs_btree_cur, 0, i)
   - 这里只能同时更新left的xfs_bmbt_rec, 文件偏移startoff, 磁盘位置startblock, 长度blockcount, 状态state
   > xfs_bmbt_update(xfs_bmalloca->xfs_btree_cur, left->br_startoff, left->br_startblock, left->br_blockcount + PREV->br_blockcount + right->br_blockcount, left->br_state)

   - 如果state == BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG
   - 右边的xfs_bmbt_irec不能合并,只能和左边的xfs_bmbt_irec合并
   - 修改xfs_bmalloca->idx --, 指向左边的xfs_bmbt_rec_host
   - 使用左边的xfs_bmbt_rec_host表示合并后的
   - xfs_bmbt_set_blockcount(xfs_iext_get_ext(xfs_ifork, xfs_bmalloca->idx), LEFT->br_blockcount + PREV->br_blockcount)
   - 删除prev对应的xfs_bmbt_rec_host
   > xfs_iext_remove(xfs_bmalloca->xfs_inode, idx, 1, stat)

   - 如果xfs_bmalloca->xfs_btree_cur不存在,设置rval = XFS_ILOG_DEXT
   - 这里没有像上面一样修改xfs_icdinode->di_nextents, 所以没有XFS_ILOG_CORE
   - 从这里可看出来对btree的修改和xfs_ifork中的xfs_bmbt_rec_host修改是完全没有关系的
   - 如果不使用btree, 对它的修改和xfs_dinode一块
   - 否则修改btree中的xfs_bmbt_rec
   > xfs_bmbt_lookup_eq(xfs_bmalloca->xfs_btree_cur, left->br_startoff, left->br_startblock, left->br_blockcount, i)
   - 更新startoff, startblock, blockcount
   > xfs_bmbt_update(xfs_bmalloca->xfs_btree_cur, left->br_startoff, left->br_blockcount + prev->br_blockcount, left->br_state)

   - 如果是BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG,
   - 合并右边2个xfs_bmbt_irec, 上面这些合并,都需要new和prev完全重合
   - 更新prev指向的xfs_bmbt_rec_host
   > xfs_bmbt_set_startblock(xfs_bmbt_irec, new->br_startblock)
   > xfs_bmbt_set_blockcount(xfs_bmbt_irec, PREV->br_blockcount + right->br_blockcount)
   - 删除右边的xfs_bmbt_rec_host 
   > xfs_iext_remove(xfs_bmalloca->xfs_inode, idx+1, 1, state)
   - 同样如果xfs_bmalloca->xfs_btree_cur有效, 修改btree中的xfs_bmbt_rec
   - 使用右边的xfs_bmbt_rec
   > xfs_bmbt_lookup_eq(xfs_bmalloca->xfs_btree_cur, right->br_startoff, ..)
   - 需要修改文件偏移,磁盘位置,长度
   > xfs_bmbt_update(xfs_bmalloca->xfs_btree_cur, br_startoff, bf_startblock, PREV->br_blockcount + right->br_blockcount, prev->br_state)

   - 如果state == BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING, 不能和2端的xfs_bmbt_rec合并, 只需要创建新的btree的xfs_bmbt_rec
   - 修改prev对应的xfs_bmbt_rec_host, 指向有效的磁盘位置
   > xfs_bmbt_set_startblock(xfs_bmbmt_rec_host, xfs_bmbt_irec->br_startblock)
   - 增加xfs_inode->xfs_icdinode->id_nextents ++ , 需要插入got对应的xfs_bmbt_rec
   - 如果xfs_bmalloca->xfs_btree_cur无效, 不需要btree操作, 设置rval = XFS_ILOG_CORE|XFS_ILOG_DEXT, 修改xfs_icdinode和xfs_ifork的xfs_bmbt_rec_host
   - 否则插入btree的xfs_bmbt_rec记录
   > xfs_bmbt_lookup_eq(xfs_btree_cur, xfs_bmbt_irec->br_startoff, xfs_bmbt_irec->br_startblock, br_blockcount, i) 
   - 上面肯定查找不到, 但xfs_btree_cur指向的位置可以直接插入
   - 设置xfs_bmalloca->xfs_btree_cur->bc_rec->xfs_bmbt_rec_host->br_state == XFS_EXT_NORM
   > xfs_btree_insert(xfs_bmalloca->xfs_btree_cur, i)
   - 上面查找操作已经设置xfs_bmalloca->xfs_btree_cur

   - 如果state == BMAP_LEFT_FILLING | BMAP_LEFT_CONFIG
   - prv范围大于got, 需要分裂成2个, 而且前一个和左边的合并
   - 先更新左边的xfs_bmbt_rec_host, 增加br_blockcount
   > xfs_bmbt_set_blockcount(xfs_iext_get_ext(xfs_ifork, idx-1), left->br_blockcount + new->br_blockcount)
   - 这时不需要修改xfs_icdinode->di_nextents
   - 修改左边对应的xfs_bmbt_rec
   > xfs_bmbt_lookup_eq(xfs_bmalloca->xfs_btree_cur, left->br_startoff, left->br_startblock, left->br_blockcount, i)
   > xfs_bmbt_update(xfs_bmalloca->xfs_btree_cur, left->br_startoff, left->br_startblock, left->br_blockcount + new->br_blockcount, left->br_state)
   - 然后更新prev指向的xfs_bmbt_rec_host
   - 修改文件偏移br_startoff
   > xfs_bmbt_set_startoff(xfs_bmbt_rec_host, prev->br_startoff + new->br_blockcount)
   - 修改xfs_bmbt_rec_host的长度br_blockcount
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, prev->br_blockcount - new->br_blockcount)
   - prev->br_startblock是无效的磁盘位置, 使用这个长度中的一部分,在分配空间时使用
   > xfs_bmap_worst_indlen(xfs_inode, new->br_blockcount-prev->br_blockcount)
   > startblockval(prev->br_startblock)
   > xfs_bmbt_set_startblock(xfs_bmbt_rec_host, nullstartblock(startoff))

   - 如果state ==BMAP_LEFT_FILLING, prev和got左边端点重合, 有遍不重合,需要分裂prev指向的xfs_bmbt_rec_host
   - 但和两端的xfs_bmbt_rec_host不会合并
   - 先修改prev, 表示后半部分的xfs_bmbt_rec_host
   - 偏移br_startoff, 
   > xfs_bmbt_set_startoff(xfs_bmbt_rec_host, new_endoff)
   - 减小br_blockcount
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, temp)
   - 然后添加新的xfs_bmbt_rec_host
   > xfs_iext_insert(xfs_inode, idx, 1, xfs_bmbt_irec, state) 
   - 增加xfs_inode->xfs_icdinode->id_nextents ++, 需要插入prev对应的xfs_bmbt_rec
   - 找到插入位置
   > xfs_bmbt_lookup_eq(xfs_btree_cur, xfs_bmbt_irec->br_startoff, startblock, blockcount, i)
   - 设置xfs_btree_cur->bc_rec->xfs_bmbt_irec->br_state = XFS_EXT_NORM
   > xfs_btree_insert(xfs_bmalloca->xfs_btree_cur)
   - 检查xfs_inode->di_fmat是否需要转为XFS_DINODE_FMT_BTREE格式 
   > xfs_bmap_needs_btree(xfs_inode, XFS_DATA_FORK)
   - 传入firstblock, 用来分配空间?? 尽量分配连续的空间?
   > xfs_bmap_extents_to_btree(xfs_trans, xfs_bmalloca->xfs_inode, firstblock, xfs_bmap_free, xfs_btree_cur, 1, tmp_rval, XFS_DATA_FORK)
   - 然后更新prev指向的xfs_bmbt_rec_host->br_startblock
   > xfs_bmap_worst_indlen(xfs_inode, temp)
   > startblockval(prev->br_startblock)
   > xfs_iext_get_ext(xfs_ifork, idx+1)
   > xfs_bmbt_set_startblock(xfs_bmbt_rec_host, nullstartblock(new))

   - 如果state是BMAP_RIGHT_FILLING|BMAP_RIGHT_CONTIG
   - 需要把prev分成2部分,后半部分和右边的xfs_bmbt_rec_host合并
   - 首先更新prev对应的xfs_bmbt_rec_ host
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, prev->br_blockcount - new->br_blockcount)
   - 更新右边的xfs_bmbt_rec_host
   > xfs_bmbt_set_allf(xfs_iext_get_ext(xfs_ifork, idx+1), new->br_startoff, new->br_startblock, new->br_blockcount + right->br_blockcount, right->br_state)
   - 然后更新btree中的xfs_bmbt_rec 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, right->br_startoff, right->br_startblock, right->br_blockcount, i)
   > xfs_bmbt_update(xfs_btree_cur, new->br_startoff, startblock, blockcount, state)
   - 更新prev指向的xfs_bmbt_rec_host->br_startblock
   > xfs_bmap_worst_indlen(xfs_inode, temp)
   > xfs_bmbt_set_startblock(xfs_bmbt_rec_host, nullstartblock(da_new))

   - 如果state == BMAP_RIGHT_FILLING
   - 需要分割prev指向的xfs_bmbt_rec_host, 但不用合并
   - 先更新prev指向的xfs_bmbt_rec_host->br_blockcount, 后面还会更新它的br_startblock
   - xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, prev->br_blockcount - new->br_blockcount)
   - 插入new对应的新的xfs_bmbt_rec_host 
   > xfs_iext_insert(xfs_inode, idx+1, 1, xfs_bmbt_irec, state)
   - 增加xfs_inode->xfs_icdinode->id_nextents ++
   - 插入新的btree数据xfs_bmbt_rec
   > xfs_bmap_lookup_eq(xfs_btree_cur, new->br_startoff, new->br_startblock, new->br_blockcount, i)
   - 设置xfs_btree_cur->bc_rec->xfs_bmbt_irec->br_state = XFS_EXT_NORM 
   > xfs_btree_insert(xfs_btree_cur, i)
   - 然后检查是否转化di_format为XFS_DINODE_FMT_BTREE 
   > xfs_bmap_needs_btree(xfs_inode, XFS_DATA_FORK)
   > xfs_bmap_extents_to_btree(xfs_trans, xfs_inode, xfs_bmalloca->firstblock, xfs_bmap_free, xfs_btree_cur, 1, tmp_rval, XFS_DATA_FORK)
   - 然后继续更新prev指向的xfs_bmbt_rec_host->br_startblock
   > xfs_bmap_worst_indlen(xfs_inode, temp)
   > xfs_iext_get_ext(xfs_ifork, idx)
   > xfs_bmbt_set_startblock(xfs_bmbt_rec_host, nullstartblock(da_new))

   - 如果state ==0, 说明got在prev的内部,需要把prev分成3部分
   - 2端的xfs_bmbt_rec_host都是delalloc
   - 第一部分使用原来的xfs_bmbt_rec_host, 更新长度 
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, new->br_startoff - prev->br_startoff)
   - 先准备2个xfs_bmbt_irec, 第一个对应new, 第二个对应第三段
   - 对于第3段, startoff是new的结束，blockcount是prev->br_blockcount+prev->br_startoff - new->br_blockcount - new->br_startoff
   - startblock需要根据新的blockcount计算
   > nullstartblock(xfs_bmap_worst_indlen(xfs_inode, temp2))
   - 插入新的xfs_bmbt_rec_host 
   > xfs_iext_insert(xfs_inode, idx+1, 2, xfs_bmbt_irec, state)
   - 增加xfs_inode->xfs_icdinode->id_nextents ++,只有中间的xfs_bmbt_rec_host才会创建对应的xfs_bmbt_rec
   - 查找btree, 插入new对应的xfs_bmbt_rec
   > xfs_bmbt_lookup_eq(xfs_btree_cur, new->br_startoff, startblock, blockcount, i)
   > xfs_btree_insert(xfs_btree_cur, i)
   - 检查是否转化di_format 
   > xfs_bmap_extents_to_btree(xfs_trans, xfs_inode, xfs_bmalloca->firstblock, xfs_bmap_free, xfs_btree_cur, 1, tmp_rval, XFS_DATA_FORK)
   - 然后更新2端xfs_bmbt_rec_host->br_startblock
   > xfs_bmap_worst_indlen(xfs_inode, temp)
   > xfs_bmbt_set_startblock(xfs_iext_get_ext(xfs_ifork, idx+2), nullstartblock(temp))
   - 对于state的其他组合,都不可能
   - 最后再检查xfs_dinode->di_format是否需要遍为XFS_DINODE_FMT_BTREE
   > xfs_bmap_needs_btree(xfs_inode, XFS_DATA_FORK)
   > xfs_bmap_extents_to_btree(xfs_trans, xfs_inode, firstblock, xfs_bmap_free, xfs_btree_cur, da_old>0, logflags, XFS_DATA_FORK)
   - 最后处理prev的delalloc的空间长度da_old
   - 分裂或合并后,它范围内的delalloc空间肯定会减小 da_new
   - da_new还需要包括btree操作分配的空间
   > xfs_bmalloca->xfs_btree_cur->bc_private->b->allocated
   - da_old - da_new就是多reserve的空间,这里时放掉他们
   > xfs_icsb_modify_counters(xfs_mount, XFS_SBS_FDBLOCKS, da_old - temp, 0)

** xfs_bmap_add_extent_unwritten_real(xfs_trans, xfs_inode, xfs_extnum_t idx, xfs_bmbt_irec new, xfs_fsblock_t first, xfs_bmap_free, logflags)
   - 这里和上面类似?
   - 操作data fork, extent数据  
   > XFS_IFORK_PTR(xfs_inode, XFS_DATA_FORK)
   - idx必须在xfs_fork的xfs_bmbt_rec_host数组长度范围之内
   - xfs_ifork->if_bytes / sizeof(xfs_bmbmt_rec_host)
   - 获取idx对应的xfs_bmbt_rec_host
   - 它必须覆盖参数xfs_bmbt_irec
   > xfs_iext_get_ext(xfs_ifork, idx)
   - 转化为xfs_bmbt_irec
   > xfs_bmbt_get_all(xfs_bmbt_rec_host, prev)
   - 检查extent的状态, 它必须和new对应
   - 如果new->br_state是XFS_EXT_UNWRITTEN, prev必须是XFS_EXT_NORM?? 否则是XFS_EXT_UNWRITTEN??
   - 检查new和prev的关系,计算state
   - 如果prev和new的br_startoff相同设置BMAP_LEFT_FILLING
   - 如果br_startoff + br_blockcount相同,设置BMAP_RIGHT_FILLING
   - 检查2端的extent，先检查前面的extent
   - 如果前面存在extent, idx > 0, 设置BMAP_LEFT_VALID
   - 获取xfs_bmbt_irec, left
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, idx-1), left)
   - 如果letf->br_startblock是null, 设置state的BMAP_LEFT_DELAY 
   > isnullstartblock(left->br_startblock)
   - 如果state有BMAP_LEFT_VALID, 没有BMAP_LEFT_DELAY
   - 文件偏移和磁盘位置, 都和new邻接
   - 而且state相同new相同, 而且br_blockcount累加不超过MAXEXTLEN
   - 设置state的BMAP_LEFT_CONTIG
   - 再检查后面的extent, idx < xfs_ifork->if_bytes / sizeof(xfs_bmbt_rec_host) - 1
   - 设置state的BMAP_RIGHT_VALID, 获取xfs_bmbt_irec right
   - 如果它没有有效的startblock, 设置state的BMAP_RIGHT_VALID
   - 检查它是否可以和new合并
   - 如果state有BMAP_RIGHT_VALID, 没有BMAP_RIGHT_DELAY
   - 文件偏移和磁盘位置和new邻接, state相同
   - 合并之后长度没有超过限制 MAXEXTLEN
   - 根据state处理extent..
   - 如果是BMAP_LEFT_FILLING|XFS_LEFT_CONTIG|XFS_RIGHT_FILLING|XFS_RIGHT_CONTIG
   - 合并3个extent, 需要减小extent的个数, 减小2个 
   - xfs_inode->xfs_icdinode->di_nextents -=2
   - 更新第一个extent的长度 
   > xfs_bmbt_set_blockcount(xfs_iext_get_ext(xfs_ifork, idx), LEFT->br_blockcount+new->br_blockcount+right->br_blockcount)
   - 删除多余的xfs_bmbt_rec_host 
   > xfs_iext_remove(xfs_inode, idx+1, 2, state)
   - 删除btree中的节点
   - 现在prev,right,left都在btree中??
   - 先找到right对应的xfs_bmbt_rec 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, right->br_startoff, right->br_startblock, RIGHT->br_blockcount, i)
   - 删除 
   > xfs_btree_delete(xfs_btree_cur, i)
   - 然后向前移动xfs_btree_cur, 再删除一个记录 ???
   > xfs_btree_decrement(xfs_btree_cur, 0, i)
   > xfs_btree_delete(xfs_btree_cur, i)
   - 然后更新前面xfs_bmbt_rec的长度
   > xfs_bmbt_update(xfs_btree_cur, left->br_startoff, br_startblock, left->br_blockcount + new->br_blockcount + right->br_blockcount, left->br_state)
   - 如果state是BMAP_LEFT_FILLING|BMAP_RIGHT_FILLING|BMAP_LEFT_CONTIG,
   - 把前2个xfs_bmbt_rec合并, 这里需要有BMAP_RIGHT_FILLING, 否则就得分裂extent 
   - 减小xfs_inode->xfs_icdinode->di_nextents --
   - 更新前面xfs_bmbt_rec_host的长度 
   > xfs_bmbt_set_blockcount(xfs_iext_get_ext(xfs_ifork, idx), left->br_blockcount + prev->br_blockcount)
   - 删除prev对应的xfs_bmbt_rec_host 
   > xfs_iext_remove(xfs_inode, idx+1, 1, state)
   - 删除prev对应的xfs_bmbt_rec 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, prev->br_startoff, prev->br_startblock, prev->br_blockcount, i)
   > xfs_btree_delete(xfs_btree_cur, i)
   - 然后更新前面xfs_bmbt_rec对应的长度 
   > xfs_btree_decrement(xfs_btree_cur, i)
   > xfs_bmbt_update(xfs_btree_cur, left->br_startoff, left->br_startblock, left->br_blockcount + prev->br_blockcount)
   - 如果是XFS_LEFT_FILLING|XFS_RIGHT_FILLING|XFS_RIGHT_CONTIG
   - 把后面2个xfs_bmbt_rec_host合并 
   - 减小xfs_inode->xfs_icdinode->di_nextents --
   - 更新prev指向的xfs_bmbt_rec_host的长度 
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, prev->br_blockcount + right->br_blockcount)
   > xfs_bmbt_set_state(xfs_bmbt_rec_host, new->br_state)
   - 删除后面的xfs_bmbt_rec_host
   > xfs_iext_remove(xfs_inode, idx+1, 1, state)
   - 操作brtee, 删除right对应的xfs_bmbt_rec_host
   > xfs_bmbt_lookup_eq(xfs_btree_cur, right->br_startoff, right->br_startblock, right->br_blockcount, i)
   > xfs_bmbt_delete(xfs_btree_cur, i)
   - 更新前面的xfs_bmbt_rec
   > xfs_btree_decrement(xfs_btree_cur, 0, i)
   > xfs_bmbt_update(xfs_btree_cur, new->br_startoff, new->br_startblock, new->br_blockcount + right->br_blockcount, new->br_state)
   - 如果state是BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING
   - 不能合并,但可以转化prev对应的xfs_bmbt_rec
   - 更新xfs_bmbt_rec_host的state 
   > xfs_bmbt_set_state(xfs_bmbt_rec_host, new->br_state)
   - 修改xfs_bmbt_rec 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, new->br_startoff, new->br_startblock, new->br_blockcount, i)
   > xfs_bmbt_update(xfs_btree_cur, new->br_startoff, ..., new->br_state)
   - 如果state是BMAP_LEFT_FILLING|BMAP_LEFT_CONTIG
   - 需要把prev分成2部分, 前面的和left合并
   - 修改left对应的xfs_bmbt_rec_host的长度 
   > xfs_bmbt_set_blockcount(xfs_iext_get_ext(xfs_ifork, idx-1), left->br_blockcount + new->br_blockcount)
   - 修改prev的开始位置, 文件偏移
   > xfs_bmbt_set_startoff(xfs_bmbt_rec_host, prev->br_startoff + new->br_blockcount)
   - prev的磁盘位置有效??? 
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, prev->br_blockcount - new->br_blockcount)
   - 然后更新btree的xfs_bmbt_rec 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, prev->br_startoff, prev->br_startblock, prev->br_blockcount, i)
   - 更新开始位置
   > xfs_bmbt_update(xfs_btree_cur, prev->br_startoff + new->br_blockcount, prev->br_blockcount + new->br_blockcount, prev->br_blockcount - new->br_blockcount, prev->br_state)
   - 修改前一个xfs_bmbt_rec的长度 
   > xfs_bmbt_decrement(xfs_btree_cur, 0, i)
   > xfs_bmbt_update(xfs_btree_cur, left->br_startoff, left->br_startblock, left->br_blockcount + new->br_blockcount, left->br_state)
   - 如果state是BMAP_LEFT_FILLING, 只需要把prev分成2部分, 没有合并
   - 增加xfs_inode->xfs_icdinode->di_nextents ++
   - 先修改prev对应的xfs_bmbt_rec_host 
   > xfs_bmbt_set_startoff(xfs_bmbt_rec_host, new_end)
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, new->br_blockcount)
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, prev->br_blockcount + new->br_blockcount)
   - 在前面插入新的new对应的xfs_bmbt_rec_host
   > xfs_iext_insert(xfs_inode, idx, 1, new, state)
   - 然后修改btree的xfs_bmbt_rec
   > xfs_bmbt_lookup_eq(xfs_btree_cur, prev->br_startoff, prev->br_startblock, prev->br_blockcount, i)
   - 做上面对应的更新 
   > xfs_bmbt_update(xfs_btree_cur, prev->br_startoff + new->br_blockcount, prev->br_startblock + new->br_blockcount, PREV->br_blockcount - new->br_blockcount, prev->br_state)
   - 然后把new给xfs_btree->br_rec->xfs_bmbt_irec, 插入新的xfs_bmbt_rec
   > xfs_btree_insert(xfs_btree_cur, i)
   - 如果state是BMAP_RIGHT_FILLING|BMAP_RIGHT_CONTIG
   - 同样把prev分成2部分,后一部分和rgiht合并
   - 更新prev指向的xfs_bmbt_rec_host的长度 
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, prev->br_blockcount - new->br_blockcount)
   - 更新right对应的xfs_bmbt_rec_host的开始位置
   > xfs_bmbt_set_allf(xfs_iext_get_ext(xfs_ifork, idx), new->br_startoff, new->br_startblock, new->br_blockcount + right->br_blockcount, new->br_state)
   - 更新btree的xfs_bmbt_rec 
   - 首先更新prev对应的xfs_bmbt_rec
   > xfs_bmbt_lookup_eq(xfs_btree_cur, prev->br_startoff, prev->br_startblock, prev->br_blockcount, i)
   > xfs_bmbt_update(xfs_btree_cur, prev->br_startoff, prev->br_blockstart, prev->br_blockcount - new->br_blockcount, prev->br_state)
   - 然后更新right 
   > xfs_btree_increment(xfs_btree_cur, 0, i)
   > xfs_bmbt_update(xfs_btree_cur, new->br_startoff, new->br_startblock, new->br_blockcount + right->br_blockcount, new->br_state)
   - 如果state是BMAP_RIGHT_FILLING, 只会把prev分成2部分,而不会合并
   - 增加xfs_inode->xfs_icdinode->di_nextents ++
   - 修改prve对应的blockcount
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, prev->br_blockcount - new->br_blockcount)
   - 然后使用new创建对应的xfs_bmbt_rec_host 
   > xfs_iext_insert(xfs_inode, idx, 1, new, state)
   - 然后修改btree的xfs_bmbt_rec
   - 首先是prev的blockcount 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, prev->br_startoff, prev->br_startblock, prev->br_blockcount, i)
   > xfs_bmbt_update(xfs_btree_cur, prev->br_startoff, prev->br_blockcount, prev->br_blockcount - new->br_blockcount, prev->br_state)xo
   - 然后插入新的节点, 为何就成了先查找??而不是insert? 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, new->br_startoff, new->br_startblock, new->br_blockcount, i)
   - 修改xfs_btree_cur->bc_rec->xfs_bmbt_irec->br_state = XFS_EXT_NORM 
   > xfs_btree_insert(xfs_btree_cur, i)
   - 如果state是0, prev需要分成3部分, 增加xfs_inode->xfs_icdinode->di_nextents += 2
   - 更新第一部分的长度 
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, new->br_startoff - prev->br_startoff)
   - 然后构造2个xfs_bmbt_irec, 第一个可使用new, 第二个对应第三部分 
   > xfs_iext_insert(xfs_inode, idx, 2, r, state)
   - 然后修改btree的xfs_bmbt_rec
   - 先更新第三部分的长度 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, prev->br_startoff, prev->br_startblock, prev->br_blockcount, i)
   > xfs_bmbt_update(xfs_btree_cur, r[1].br_startoff, ..)
   - 然后使用prev添加第一部分, 给xfs_btree_cur->bc_rec->xfs_bmbt_irec
   - 因为这是xfs_bmbt_cur可以直接插入??
   > xfs_btree_insert(xfs_btree_cur, i)
   - 然后修改xfs_btree_cur, 指向第二部分 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, new->br_startoff, ...)
   > xfs_btree_insert(xfs_btree_cur, i)
   - 对于其他的state, 都是错误的状态
   - 最后检查di_format是否需要变为XFS_DINODE_FMT_BTREE 
   > xfs_bmap_need_btree(xfs_inode, XFS_DATA_FORK)
   > xfs_bmap_extents_to_btree(xfs_trans, xfs_inode, first, xfs_bmap_free, xfs_btree_cur, 0, logflags, XFS_DATA_FORK)
  
** xfs_bmap_add_extent_hole_delay(xfs_inode, xfs_extnum_t idx, xfs_bmbt_irec)
   - 参数xfs_bmbt_irec还没有插入到xfs_ifork中, 而且它是delay allocation
   - 获取xfs_ifork, 2端的xfs_bmbt_iref 
   > XFS_FORK_PTR(xfs_inode, XFS_DATA_FORK)
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, idx-1), left)
   - 检查xfs_bmbt_irec->br_startblock
   - 同样设置state的BMAP_LEFT_VALID|BMAP_LEFT_DELAY
   - 参数xfs_bmbt_irec是delay allocation
   - 参数idx对应的是right的xfs_bmbt_rec_host
   - 如果2端的xfs_bmbt_rec_host->br_blockcount也是无效的磁盘位置,才考虑合并
   - 根据文件偏移,检查是否可合并BMAP_LEFT_CONTIG
   - 如果state是BMAP_LEFT_CONTIG|BMAP_RIGHT_CONGIT
   - 合并3个xfs_bmbt_rec, 这里只会更新xfs_bmbt_rec_host 
   > xfs_bmbt_set_blockcount(xfs_iext_get_ext(xfs_ifork, idx), left->br_blockcount + new->br_blockcount + right->br_blockcount)
   - 这3个xfs_bmbt_rec_host都是delay allocation, br_blockcount只需合并
   - startblockval(left->br_startblock) + startblockval(new->br_blockcount) + startblock(right->br_blockcount)
   > xfs_bmbt_set_startblock(xfs_iext_get_ext(xfs_ifork, idx), nullstartblock(newlen))
   - 然后删除right指向的xfs_bmbt_rec_host 
   > xfs_iext_remove(xfs_inode, idx+1, 1, state)
   - 这里没有btree操作
   - 如果state是BMAP_LEFT_CONTIG, 只需要合并前面的2个xfs_bmbt_rec_host
   - 只需要修改blockcount, startblock
   - 如果state是BMAP_RIGHT_CONGIT, 合并后面2个xfs_bmbt_rec_host
   - 需要修改right的blockcount, startblock, startoff
   - 如果state是0, 不能合并,直接插入新的xfs_bmbt_rec_host 
   > xfs_iext_insert(xfs_ifork, idx, 1, xfs_bmbt_irec, state)
   - startblock会有改变,影响到XFS_SBS_FDBLOCKS的计数

** xfs_bmap_add_extent_hole_real(xfs_bmalloca, whichfork)
   - xfs_bmalloca->idx指向的xfs_bmbt_rec_host是hole,分配磁盘后，索引有效的磁盘空间
   - 分配的磁盘信息在xfs_bmalloca->got中

   - 获取对应的xfs_ifork 
   > XFS_IFORK_PTR(xfs_inode, whichfork)

   - 新的xfs_bmbt_irec->br_startblock必须指向有效的磁盘地址
   > isnullstartblock(new->br_startblock)
   - xfs_bmalloca->idx有效, 指向xfs_ifork中的xfs_bmbt_rec_host

   - 获取2端的xfs_bmbt_irec/xfs_bmbt_rec_host
   - xfs_bmalloca->idx指向右端的, idx-1指向左端的, 分别获取对应的xfs_bmbt_irec
   - 果然xfs_ifork中还没有这个hole的xfs_bmbt_rec
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, idx-1), left)

   - 计算合并和插入的条件
   - 如果存在xfs_bmbt_rec_host, 设置BMAP_LEFT_VALID 
   - 如果磁盘位置无效, 设置BMAP_LEFT_DELAY 
   > isnullstartblock(left->br_startblock)
   - 如果文件偏移磁盘位置连续, 而且不是BMAP_LEFT_DELAY, 而且br_state一样,可以合并设置BMAP_LEFT_CONTIG

   - 如果state是BMAP_LEFT_CONGIT|BMAP_RIGHT_CONTIG, 可以合并3个xfs_bmbt_irec
   - 更新左端的xfs_bmbt_rec_host, 表示合并后的, 更新br_blockcount
   - idx已经指向左端的
   > xfs_bmbt_set_blockcount(xfs_iext_get_ext(xfs_ifork, idx), left->br_blockcount + new->br_blockcount + right->br_blockcount)
   - 删除右端的xfs_bmbt_rec_host, 
   > xfs_iext_remove(xfs_inode, idx+1, 1, state)
   - 减小xfs_icdinode->di_nextents/di_anextents,需要删除右端的xfs_bmbt_rec
   > XFS_IFORK_NEXT_SET(inode, whichfork, XFS_IFORK_NEXTENTS(xfs_inode, whichfork) - 1)
   - 如果xfs_bmalloca->xfs_btree_cur无效, 没有使用btree管理xfs_bmbt_rec 
   - 不需要删除xfs_bmbt_rec, 只需要返回XFS_ILOG_CORE | xfs_ilog_fext(whichfork), 在xfs_icdinode写回时,会把fork数据写回
   - 否则操作btree, 删除右端的xfs_bmbt_rec, 修改左端的xfs_bmbt_rec
   > xfs_bmbt_lookup_eq(xfs_btree_cur, right->br_startoff, br_blockcount, ..)
   > xfs_bmbt_delete(xfs_btree_cur, i)
   > xfs_btree_decrement(xfs_btree_cur, 0, i)
   > xfs_bmbt_update(xfs_btree_cur, left->br_startoff, left->br_startblock, left->br_blockcount + new->br_blockcount + right->br_blockcount, left->br_state)

   - 如果state是BMAP_LEFT_CONTIG, 把got合并到左端的xfs_bmbt_rec/xfs_bmbt_rec_host
   - 修改左端的xfs_bmbt_rec_host的长度
   > xfs_bmbt_set_blockcount(xfs_iext_get_ext(xfs_ifork, idx), left->br_blockcount, new->br_blockcount)
   - xfs_bmbt_rec的总数量没有变化
   - 如果xfs_bmalloca->xfs_btree_cur无效, xfs_bmbt_rec在fork区域,不需要修改, 直接返回xfs_ilog_fext(whichfork)
   - 否则需要修改左端的xfs_bmbt_rec
   > xfs_bmbt_lookup_eq(xfs_btree_cur, left->br_startoff, ...)
   > xfs_bmbt_update(xfs_btree_cur, left->br_startoff, left->br_startblock, left->br_blockcount + new->br_blockcount, left->br_state)

   - 如果state是BMAP_RIGHT_CONTIG, 把got合并到右端的xfs_bmbt_rec/xfs_bmbt_rec_host中
   - 更新右端的xfs_bmbt_rec_host, 修改br_startoff, br_startblock, br_blockcount
   > xfs_bmbt_set_allf(xfs_iext_get_ext(xfs_ifork, idx), new->br_startoff, new->br_startblockoff, new->br_blockcount + right->br_blockcount, new->br_state)
   - 然后更新右端的xfs_bmbt_rec
   > xfs_bmbt_lookup_eq(xfs_btree_cur, right->br_startoff, right->br_startblock, right->br_blockcount, i)
   > xfs_bmbt_update(xfs_btree_cur, new->br_startoff, new->br_startblock, new->br_blockcount + left->br_blockcount, right->br_state)

   - 如果state是0, 没法合并,需要插入xfs_bmbt_rec/xfs_bmbt_rec_host
   - 首先操作xfs_ifork, 插入新的xfs_bmbt_rec_host
   - 在idx位置处, 使用的数据就是new
   > xfs_iext_insert(xfs_ifork, idx, 1, new)
   - 增加xfs_icdinode->di_nextents/di_anextents, 下面返回的rval中需要包含XFS_ILOG_CORE
   - 如果xfs_bmalloca->xfs_btree_cur无效,现在不需要插入xfs_bmbt_rec, 仅仅返回xfs_ilog_fext(whichfork)
   - 否则插入btree的xfs_bmbt_rec, 让xfs_btree_cur指向相应的位置
   > xfs_bmbt_lookup_eq(xfs_btree_cur, new->br_startoff, new->br_startblock, new->br_blockcount, i)
   - 设置xfs_btree_cur->bc_rec->b->br_state
   > xfs_bmbt_insert(xfs_btree_cur, i)

   - 最后检查xfs_inode的di_format/di_aformat是否需要转化
   > xfs_bmap_needs_btree(xfs_inode, whichfork)
   > xfs_bmap_extents_to_btree(xfs_trans, xfs_inode, firstblock, xfs_bmap_free, xfs_btree_cur, 0, logflags, whichfork)

** xfs_bmap_extsize_align(xfs_mount, xfs_bmbt_irec gotp, xfs_bmbt_irec prev, xfs_extlen_t extsz, rt, eof, delay, convert, xfs_fileoff_t off, xfs_extlen_t len)
   - (off,len)是xfs_bmalloca的成员, 表示即将分配磁盘空间的文件偏移, 这里需要做对齐,但又不能和2端的重叠
   - 参数的2个xfs_bmbt_irec对应查找xfs_ifork时返回的2个连续的xfs_bmbt_rec_host
   - 如果(off,len)是hole, 参数2个xfs_bmbt_irec是在2端的, 如果是delalloc, (off,len)应该在got范围内

   - 如果convert !=0, 直接返回
   - 如果delay==0, eof==0, (off,len)和got交叉, 直接返回

   - 使(orig_off,orig_end)对extsz对齐,变为(align_off, align_alen)

   - 检查前一个xfs_bmbt_irec, 如果br_startoff != NULLFILEOFF, 表示它是有效的
   - 获取他的范围, 当前分配的文件范围不能和他重叠
   - 如果prev->br_startoff == NULLFILEOFF, prevo = 0, 表示文件开头
   - 如果是HOLESTARTBLOCK, prevo = br_startoff, 哪里构造hole的xfs_bmbt_irec?
   - 否则, 它是有效的 prevo = br_startoff + br_blockcount
   - 如果align_off < prevo, 调整align_off = prevo

   - 检查got对应的xfs_bmbt_irec, 如果eof==0 或者 br_startoff != NULLFILEOFF, 它才是有效的
   - 如果delay !=0,而且br_startblock == HOLDSTARTBLOCK, 表示为hole
   - 如果delay ==0,而且br_startblock == DELAYSTARTBLOCK, 表示delalloc
   - 表示当前的xfs_bmbt_irec可以覆盖它,设置nexto = br_startoff + br_blockcount
   - 否则不能覆盖, 设置nexto = br_startoff
   - 如果align_off + align_alen > nexto, 调整align_off = nexto - align_alen, 向前移动范围

   - 最后把(align_off, align_alen)给参数(off, len)

** xfs_bmap_adjacent(xfs_bmalloca)
   - 首先计算xfs_bmalloca->blkno, 分配磁盘空间时建议的位置

   - 如果为eof分配空间, 而且前面的xfs_bmbt_irec有磁盘空间, xfs_bmalloca->prev 
   - prev->br_startoff != NULLFILEOFF, 文件偏移有效, br_startblock表示磁盘空间有效 
   > isnullstartblock(prev->br_startblock)
   - 而且它的磁盘结束位置没有超过AG
   - 设置blkno = prev->br_startblock + prev->br_blockcount
   - 对应的文件位置的距离是adjuest xfs_bmalloca->offset - (br_startoff + br_blockcount)
   - 如果adjuest>0, 最好预留出空间给以后的分配使用,当然需要blkno + adjuest有效

   - 如果不是为eof分配空间, 检查2端的xfs_bmbt_irec, prev/gotp
   - 如果prev的文件偏移和磁盘位置都有效, br_startoff != NULLFILEOFF, br_startblock不是delalloc
   > isnullstartblock(br_startblock)
   - 可以使用他的磁盘范围的结束位置 prevbno = prev->br_startoff + prev->br_blockcount
   - (offset,len)表示这次操作的文件范围, 计算和prev的距离
   - adjuest = xfs_bmalloca->offset - prev->br_startoff - prev->br_blockcount
   - 如果偏移不算大 XFS_ALLOC_GAP_UNITS * xfs_bmalloca->length
   - 而且prevbno + prevdiff也可以使用, 没有超过AG边界, 设置prevbno += adjuest
   - 否则设置prevdiff += adjuest, 翻倍文件偏移, 在后面会和后面的文件偏移比较

   - 检查后面的xfs_bmbt_irec, 这里怎么保证它和(off,len)不重叠??
   - 如果他的磁盘地址有效, 就因为它有磁盘位置,也能保证不会重叠
   > isnullstartblock(got->br_startblock)
   - 计算文件偏移的距离
   - got->br_startoff - xfs_bmalloca->offset
   - 如果距离不算太大 XFS_ALLOC_GAP_UNITS * xfs_bmalloca->length, 而且磁盘位置做偏移后也有效
   - ISVALID(br_startblock - ajuest, startblock), 没有跨越AG边界
   - 可以使用的分配地址是br_startblock - adjuest, 因为2者不想叫,所以adjuest > len
   - 如果距离太大，或者偏移之后超过AG边界, 可以使用的提示地址是br_blockcount - xfs_bmalloca->length, 计算距离gotdiff += adjuest - len
   - 不是严格的2倍, 反而很混乱
   - 否则在br_blockcount前面找不到合适的空间, 距离翻倍, gotdiff += adjuest

   - 最后比较prevdiff和gotdiff, 使用比较小的对应的磁盘位置 
   > prevdiff > gotdiff ? prevbno : gotbno

   - 反正比较混乱!!

** xfs_bmap_btalloc_nullfb(xfs_bmalloca, xfs_alloc_arg, xfs_extlen_t blen)
   - 在分配空间时,如果没有一个提示的起始地址, 需要查找一个合适的

   - 如果xfs_bmalloca->userdata有效,而且是filestream, 分配方法是XFS_ALLOCTYPE_NEAR_BNO
   > xfs_inode_is_filestream(xfs_inode)
   - 否则使用XFS_ALLOCTYPE_START_BNO



   - 遍历所有的AG, 直到找到一个xfs_perag, 它的最大空闲空间超过xfs_alloc_arg->maxlen
   - 从xfs_bmalloca->fsbno里面的AG开始遍历, 如果无效从0开始
   > XFS_FSB_TO_AGNO(xfs_mount, xfs_alloc_arg->fsbno)
   > xfs_perag_get(xfs_mount, ag) 
   - 读取AG的pgf数据,获取磁盘空间信息
   > xfs_alloc_pagf_init(xfs_mount, xfs_alloc_arg->xfs_trans, ag, XFS_ALLOC_FLAG_TRYLOCK)
   - 检查xfs_perag中最长的连续空间
   > xfs_alloc_longest_free_extent(xfs_mount, xfs_perag) 
   - 使用blen统计最长的空间

   - 如果没有找到合适的AG, 而且blen < xfs_alloc_arg->minlen 
   - 设置xfs_alloc_arg->minlen = xfs_bmalloca->minlen??
   - 如果blen < xfs_alloc_arg->maxlen, 说明没有足够大的AG
   - 设置xfs_alloc_arg->minlen = blen, 但尽量分配足够长的空间
   - 否则设置xfs_alloc_arg->minlen = xfs_alloc_arg->maxlen, 的确没有空间

   - 在分配开始之前, 准备xfs_alloc_arg->minlen, 并找一个最有大小blen

** xfs_bmap_btalloc(xfs_bmalloca)
   - 分配xfs_bmalloc需要的空间

   - 首先对齐文件的范围, 只有为普通文件数据配分空间时才对齐
   - xfs_bmalloca->userdata !=0
   - 而且这个文件要求地址对齐
   > xfs_get_extsz_hint(xfs_inode)
   > xfs_bmap_extsize_align(xfs_mount, xfs_bmalloca->got, prev, align, 0, xfs_bmalloca->eof, 0, conv, xfs_bmalloca->offset, xfs_bmalloca->length)

   - 计算xfs_bmalloca->blkno, 表示分配空间的提示位置
   - 使用xfs_bmalloca->firstblock, 如果它是NULLFSBLOCK, 使用xfs_dinode的位置
   > XFS_INO_TO_FSB(xfs_mount, xfs_inode->i_ino)
   - 如果是filestream, 复杂一些
   - 然后根据文件中的xfs_bmbt_irec, 精确磁盘位置
   > xfs_bmap_adjacent(xfs_bmalloca)
   - 但这里计算之后不一定使用, 因为可能使用不同于firstblock的AG

   - 准备xfs_alloc_arg, 设置xfs_trans, xfs_mount
   - 提示磁盘位置fsbno = xfs_bmalloca->blkno
   - maxlen = MIN(xfs_bmalloca->length, XFS_ALLOC_AG_MAX_USABLE(xfs_mount))
   - firstblock = xfs_bmalloca->firstblock ??
   - 如果firstblock是NULLFSBLOCK, 计算minlen, 统计blen
   > xfs_bmap_btalloc_nullfb(xfs_bmalloca, xfs_alloc_arg, blen)
   - 否则 如果xfs_bmalloca->xfs_bmap_free->xbf_low !=0 ??
   - 设置xfs_alloc_arg->type 为XFS_ALLOCTYPE_START_BNO??
   - 设置xfs_alloc_arg->total/minlen = xfs_bmalloca->minlen??
   - 否则使用XFS_ALLOCTYPE_NEAR_BNO, total = xfs_bmalloca->total, minlen = xfs_bmalloca->minlen

   - 处理align, xfs_alloc_arg->prod, mod
   - 如果align > 0, 设置prod = align, mod = (prod - offset%prod) % prod
   - 否则align = 0, 如果sb_blocksize > PAGE_CACHE_SIZE, 设置prod = 1, mod = 0
   - 否则prod = PAGE_CACHE_SIZE >> sb_blocklog, mod = prod - offset % prod

   - 如果xfs_bmalloca->xfs_bmap_free->xbf_flow == 0, 表示磁盘空间很多, 在分配失败时设置
   - 而且文件初次分配空间或在文件结尾分配空间 xfs_bmalloca->aeof = 1, 需要做地址对齐
   - 如果xfs_bmalloca->offset ==0, 从文件开头分配
   - xfs_alloc_arg->alignment = stripe_align
   - 设置xfs_alloc_arg->minlen = blen - xfs_alloc_arg->alignment, minalignslop = 0
   - 否则从文件结尾分配
   - 设置xfs_alloc_arg->type = XFS_ALLOCTYPE_THIS_BNO, alignment = 1, tryagain = 1, 失败后会尝试别的??

   - 仔细设置xfs_alloc_arg, 开始分配空间 
   > xfs_alloc_vextent(xfs_alloc_arg)
   - 如果tryagain !=0, 而且没有分配成功, xfs_alloc_arg->fsbno == NULLFSBLOCK 
   - 重新分配, 更新type, fsbno, alignment, minlen
   > xfs_alloc_vextent(xfs_alloc_arg)

   - 如果还没有成功, 而且isalianged ==1, 去掉align条件,重新分配
   - 设置xfs_alloc_arg->alignment = 0
   > xfs_alloc_vextent(xfs_alloc_arg)

   - 如果还没有成功, 而且xfs_alloc_arg->minlen > xfs_bmalloca->minlen
   - 使用XFS_ALLOCTYPE_START_BNO方式, 更新xfs_alloc_arg->minlin
   > xfs_alloc_vextent(xfs_alloc_arg)

   - 如果还没有成功,而且是firstblock==NULLFSBLOCK
   - 使用XFS_ALLOCTYPE_FIRST_AG,尝试其他的AG?
   - 设置fsbno = 0, total = xfs_bmalloca->minlen, minleft = 0
   > xfs_alloc_vextent(xfs_alloc_arg)
   - 设置xfs_bmap_free->xbf_low = 1

   - 如果分配成功, 设置xfs_bmalloca->blkno = xfs_alloc_arg->fsbno,length = xfs_alloc_arg->len
   - 如果xfs_bmalloca->firstblock == NULLFSBLOCK, 设置fsbno = blkno, 以后分配使用
   - 所以新的xfs_bmbt_irec的长度还得根据磁盘分配结果而定

   - 增加xfs_inode->xfs_icdinode->id_nblocks += xfs_alloc_arg->len 
   - log xfs_icdinode
   > xfs_trans_log_inode(xfs_trans, xfs_inode, XFS_ILOG_CORE)

   - 如果xfs_bmalloca->wasdel !=0, 减小对应的delalloc空间  xfs_inode->i_delayed_blks -= len

** xfs_bmap_alloc(xfs_bmalloca)
   > xfs_bmap_btalloc(xfs_bmalloca)

** xfs_bmapi_trim_map(xfs_bmbt_irec val, xfs_bmbt_irec got, xfs_fileoff_t bno, xfs_filblks_t len, xfs_fileoff_t obno, xfs_fileoff_t end, n, flags)
   - 在读取或创建新的xfs_bmbt_rec_host之后,放到xfs_bmbt_irec数组中
   - val/n操作xfs_bmbt_irec数组, (obno,end)表示操作总的范围, got表示新获取的, (bno,len)表示当前要求获取的,它和got可能相同

   - 如果flags有XFS_BMAPI_ENTIRE, 或者got的文件偏移在bono之前, 怎么可能在前面?
   - 不用trim? 把got给val?? 
   - 如果got->br_startblock不是有效的,设置val->br_startblock = DELAYSTARTBLOCK

   - 设置val->br_startoff = obno
   - 如果got->br_startblock不是有效的, 设置br_blockcount = DELAYSTARTBLOCK
   - 否则需要对磁盘位置做偏移, (bno, length)可能在got内部 
   - val->br_startblock = got->br_startblock + bno - got->br_startoff
   - 设置val->br_startblock, 不超过(obno,end), 也不能超过got->br_blockcount - (bno - got->br_startoff)
   - XFS_FILBLKS_MIN(en - bno, got->br_blockcount - (bno - got->br_startoff))
   - state使用got->br_state

   - 太混乱!!

** xfs_bmapi_update_map(xfs_bmbt_irec map, xfs_fileoff_t bno, xfs_filblks_t len, xfs_fileoff_t bono, xfs_fileoff_t end, n, flags)
   - 上面填充了xfs_bmbt_irec, 检查它是否可以和前面的xfs_bmbt_irec合并,如果不能,向前移动n指针

   - 刚刚处理或当前的xfs_bmbt_irec不能超过(obno, len)
   - 更新(bno, len) = (br_startoff+br_blockcount, end - bno), 指向后面的空间
   - 如果n>0, val->br_startoff == val[-1]->br_startoff ? 和前面的范围重叠??
   - 如果n>0, val->br_blockcount != DELAYSTARTBLOCK, 而且前一个xfs_bmbt_irec的磁盘空间有效
   - val[-1]->br_startblock 不是DELAYSTARTBLOCK, HOLDSTARTBLOCK
   - 而且他的磁盘位置和val临接, flags有XFS_BMAPI_IGSTATE, 文件偏移肯定也临接
   - 更新val[-1]->br_blockcount += val->br_blockcount, 合并2个xfs_bmbt_irec
   - 如果n>0, 而且val和前面的xfs_bmbt_irec都是DELAYSTARTBLOCK, 而且文件偏移挨着, 合并2个xfs_bmbt_irec
   - 更新val[-1]->br_blockcount, br_state
   - 如果n==0, 而且xfs_bmbt_irec->br_startoff + br_blockcount < obno, 它不是操作想要的, 没有操作
   - 其他情况, 向前移动xfs_bmbt_irec/n指针

** xfs_bmapi_read(xfs_inode, xfs_fileoff_t bno, xfs_filblks_t len, xfs_bmbt_irec val, nmap, flags)
   - 处理xfs_bmbt_irec数组?? 数组长度是nmap
   - 根据flags计算xfs_ifork
   - flags有XFS_BMAPI_ATTRFORK就是XFS_ATTR_FORK, 否则就是XFS_DATA_FORK 
   > XFS_IFORK_PTR(xfs_inode, whichfork)
   - 如果xfs_ifork->if_flags没有XFS_IFEXTENTS,先读取xfs_bmbt_rec数据 
   > xfs_iread_extents(NULL, xfs_inode, whichfork)
   - 根据bno查找xfs_bmbt_irec 
   > xfs_bmap_search_extents(xfs_inode, bno, whichfork, eof, lastx, xfs_bmbt_irec, prev) 
   - 然后查找(bno, len)范围内的xfs_bmbt_irec, 放到参数(val, nmap)中??
   - trim?? 可能会合并??
   > xfs_bmapi_trim_map(val, xfs_bmbt_irec got, bno, len, obno, end, nflags)
   - 更新什么??  bno会向后移动??
   > xfs_bmapi_update_map(val, bno, len, obno, end, n, flags)
   - 如果xfs_bmbt_irec->br_startoff > bno, 中间有hole, 同样也创建一个xfs_ifork中没有的 
   - (bno, HOLESTARTBLOCK, br_startoff-bno, XFS_EXT_NORM)
   - 对于hole, state竟然是XFS_EXT_NORM
   - 然后向前移动xfs_bmbt_irec 
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, lastx), xfs_bmbt_irec)

** xfs_bmap_reserve_delalloc(xfs_inode, xfs_fileoff_t aoff, xfs_filblks_t len, xfs_bmbt_irec got, xfs_bmbt_irec prev, xfs_extnum_t lastx, eof)
   - delay allocation时的预留空间??
   - 先计算alen?  XFS_FILBLKS_MIN(len, MAXEXTLEN, got->br_startoff - aoff)
   - 计算extent长度的默认值?? 
   > xfs_get_extsz_hint(xfs_inode)
   - 使用他调整分配长度?? 
   > xfs_bmap_extsize_align(xfs_mount, got, prev, extsz, rt, eof, 1, 0, aoff, alen) 
   - 计算indlen?? 
   > xfs_bmap_worst_indlen(xfs_inode, alen)
   - 修改计数XFS_SBS_FDBLOCKS?? 这时预留空间?? 
   > xfs_icsb_modify_counters(xfs_mount, XFS_SBS_FDBLOCKS, -alen, 0)
   - 还有indlen? 
   > xfs_icsb_modify_counters(xfs_mount, XFS_SBS_FDBLOCKS, -indlen, 0)
   - 增加xfs_inode->i_delayed_blks += alen
   - 设置got的信息?? 
   - (aoff, nullstartblock(indlen), alen, XFS_EXT_NORM) 
   - 然后插入xfs_bmbt_rec_host ? 
   > xfs_bmap_add_extent_hole_delay(xfs_inode, lastx, got)
   - 检查插入结果?? 
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, lastx), got)
   
** xfs_bmapi_delay(xfs_inode, xfs_fileoff_t bno, xfs_filblks_t len, xfs_bmbt_irec val, nmap, flags)
   - 首先检查xfs_bmbt_rec是否已经缓存到xfs_ifork中, xfs_ifork->if_flags没有XFS_IFEXTENTS
   > xfs_iread_extents(NULL, xfs_inode, XFS_DATA_FORK)
   - 根据bno查找xfs_bmbt_rec_host 
   > xfs_bmap_search_extents(xfs_inode, bno, XFS_DATA_FORK, eof, lastx, xfs_bmbt_irec got, prev)
   - 遍历xfs_bmbt_rec_host, 查找覆盖(bno, len)的
   - 如果xfs_bmbt_irec->br_startoff > bno, 有一个hole的extent 
   > xfs_bmapi_reserve_delalloc(xfs_inode, bno, len, xfs_bmbt_irec got, prev, lastx, eof)
   - 把它放到参数中 
   > xfs_bmapi_trim_map(xfs_bmbt_irec, got, bno, len, obno, end, n, flags)
   > xfs_bmapi_update_map(xfs_bmbt_irec val, bno, len, obno, end, n, flags)
   - 获取下一个xfs_bmbt_rec_host 
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, lastx), got)

   
** __xfs_bmapi_allocate(xfs_bmalloca)
   - 根据xfs_bmalloca->flags判断分配data fork, 还是attr fork
   - 获取xfs_ifork
   - 如果xfs_bmalloca->wasdel !=0, 按照xfs_bmalloca->got分配空间
   - (length, offset) = (got->br_blockcount, br_startoff)
   - 如果xfs_bmalloca->idx >0, 获取前一个xfs_bmbt_irec 
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, idx-1), xfs_bmalloca->prev)
   - 如果不是delay allocation?? 需要计算分配长度
   - XFS_FILBLKS_MIN(xfs_bmalloca->length, MAXEXTLEN)
   - xfs_bmalloca->eof ==0, length不能超过got->br_startoff - offset
   - 不能和got指向的xfs_bmbt_irec重叠??
   - 如果bmalloca->flags没有XFS_BMAPI_METADATA, 设置xfs_bmalloca->userdata
   - 如果offset ==0, 设置为XFS_ALLOC_INITIAL_USER_DATA,否则是XFS_ALLOC_USERDATA
   - 如果xfs_bmalloca->flags有XFS_BMAPI_CONTIG, 设置minlen = length, 否则为1. 这里分配的单位是fsb??
   - 检查是否需要对齐分配  xfs_mount->m_dalign > 0
   - 如果是分配userdata xfs_bmalloca->flags没有XFS_BMAPI_METADATA, 而且whichfork是XFS_DATA_FORK
   - 而且xfs_bmalloca->length > xfs_mount->m_dalign 
   > xfs_bmap_isaeof(xfs_bmalloca, whichfork)
   - 分配空间  
   > xfs_bmap_alloc(xfs_bmalloca)
   - 设置xfs_btree_cur->bc_private->b_firstblock = xfs_bmalloca->firstblock?? 为什么??
   - 如果没有分配空间, xfs_bmalloca->blkno == NULLFSBLOCK, 直接返回?
   - 如果xfs_ifork->if_flags有XFS_IFBROOT? 而且xfs_bmalloca->cur ==NULL?? 需要补充btree操作??
   - 准备xfs_btree_cur? 
   > xfs_bmbt_init_cursor(xfs_mount, xfs_bmalloca->xfs_trans, xfs_inode, whichfork)
   - 设置xfs_btree_cur->bc_private->b_firstblock = xfs_bmalloca->firstblock, xfs_bmap_free
   - 增加xfs_bmalloca->nallocs ??
   - 把分配的空间给xfs_bmalloca->got
   - (offset, length, blkno, XFS_EXT_NORM) -> (br_startoff, br_blockcount, br_startblock, br_state)
   - 如果xfs_bmalloca->wasdel ==0, 而且xfs_bmalloca->flags有XFS_BMAPI_PREALLOC, 这是pre-allocation
   - 设置got->br_state = XFS_EXT_UNWRITTEN
   - 把新的xfs_bmbt_irec写回xfs_ifork/btree 
   - 如果xfs_bmalloca->wasdel !=0 
   > xfs_bmap_add_extent_delay_real(xfs_bmalloca)
   - 否则写回hole?? 
   > xfs_bmap_add_extent_hole_real(xfs_bmalloca, whichfork)
   - 重新获取对应的xfs_bmbt_irec 
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, idx), xfs_bmalloca->got)

** xfs_bmapi_convert_unwritten(xfs_bmalloca, xfs_bmbt_irec, xfs_filblks_t, flags)
   - 如果xfs_bmbt_irec是XFS_EXT_UNWRITTEN, 而且flags有XFS_BMAPI_PREALLOC?? 直接返回  unwritten -> real??
   - 如果是XFS_EXT_NORM, 而且flags不是XFS_BMAPI_PREALLOC|XFS_BMAPI_CONVERT?? 直接返回 real->unwritten ??
   - 如果xfs_ifork->if_flags是XFS_IFBROOT, 表示磁盘中使用btree存储数据?? 准备xfs_btree_cur  
   > xfs_bmbt_init_cursor(xfs_mount, xfs_trans, xfs_inode, whichfork)
   - 设置xfs_btree_cur->bc_private->b->xfs_bmap_free = xfs_bmalloca->firstblock, xfs_bmap_free? 哪里使用??
   - 重新计算xfs_bmbt_irec
   - 如果原来是XFS_EXT_UNWRITTEN, 变为XFS_EXT_NORM, 否则变为XFS_EXT_UNWRITTEN??
   - 处理xfs_ifork/btree?
   > xfs_bmap_add_extent_unwritten_real(xfs_trans, xfs_inode, idx, xfs_btree_cur, xfs_bmbt_irec, firstblock, xfs_bmap_free, logflags)
   - 需要把上面计算的logflags收集到xfs_bmalloca->logflags 

** xfs_bmapi_write(xfs_trans, xfs_inode, xfs_fileoff_t bno, xfs_filblks_t len, flags, xfs_fsblock_t firstblock, xfs_extlen_t total, xfs_bmbt_irec val, nmap, xfs_bmap_free flist)
   - 把xfs_bmbt_irec写回磁盘? 作相应的转化?
   - 首先检查参数, xfs_inode的di_format必须是XFS_DINODE_FMT_EXTENTS/BTREE
   - flags不能有XFS_BMAPI_IGSTATE?
   - 获取whichfork对应的xfs_ifork
   - 如果firstblock == NULLFSBLOCK? 计算xfs_bmalloc->minleft
   - 否则会使用firstblock分配, 设置xfs_bmalloca->minleft = 0
   - 在分配空间时,不要紧挨着xfs_inode分配?
   - 如果xfs_ifork使用XFS_DINODE_FMT_BTREE存储数据, 设置xfs_bmalloca->minleft = xfs_btree_block->bb_level +1?
   - 否则设置为1
   - 如果xfs_ifork还没有缓存xfs_bmbt_rec, 读取数据, xfs_ifork->if_flags没有XFS_IFEXTENTS
   > xfs_iread_extents(xfs_trans, xfs_inode, whichfork)
   - 查找bno对应的xfs_bmbt_irec 
   > xfs_bmap_search_extents(xfs_inode, bno, whichfork, eof, xfs_bmalloca->idx, xfs_bmalloca->got, xfs_bmalloca->prev)
   - 准备xfs_bmalloca, 使用参数的(xfs_bmap_free, firstblock)
   - 如果flags有XFS_BMAPI_STACK_SWITCH, 设置xfs_bmalloca->stack_switch = 1, 在后面会使用workqueue分配磁盘
   - 遍历(bno, len)的范围, 处理它所覆盖的xfs_bmbt_rec_host
   - 如果eof!=0, 或者got->br_startoff > bno, 表示没有xfs_bmbt_rec包含bno
   - 如果不是hole, 但got->br_startblock无效, 这是delalloc
   > isnullstartblock(got->br_startblock)
   - 如果是hole或者delalloc, 需要分配空间
   - 设置xfs_bmalloca的eof/conv/wasdel/offset/flags/length 
   > xfs_bmapi_allocate(xfs_bmalloca)
   - 创建的xfs_bmbt_irec在xfs_bmalloca->got中,已经添加到xfs_ifork/btree中
   - 参数太混乱???
   > xfs_bmapi_trim_map(val, got, bno, len, obno, end, n, flags)
   - 修改xfs_bmbt_irec->br_state, 应该把XFS_EXT_UNWRITTEN改为XFS_EXT_NORM, 并同步给xfs_ifork/btree
   > xfs_bmapi_convert_unwritten(xfs_bmalloca, val, len, flags)
   - 根据结果更新xfs_bmbt_irec数组, 而且前向移动bno,len
   > xfs_bmapi_update_map(val, bno, len, obno, end, n, flags)
   - 处理下一个xfs_bmbt_rec_host 
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, idx), xfs_bmalloca->got)
   - 检查di_format/di_aformat是否需要改变
   > xfs_bmap_wants_extents(xfs_inode, whichfork)
   > xfs_bmap_btree_to_extents(xfs_trans, xfs_inode, xfs_btree_cur, tmp_logflags, whichfork)
   - 把上面的操作记录到log中
   - 检查xfs_bmalloca->logflags, 决定需要log哪些数据,XFS_ILOG_DEXT/XFS_ILOG_AEXT
   > xfs_ilog_fext(whichfork)
   - 如果format不是XFS_DINODE_FMT_EXTENTS, 不需要log data fork中的数据
   - 检查log_flags的XFS_ILOG_DBROOT/XFS_ILOG_ABROOT, format不是XFS_DINODE_FMT_BTREE, 也不需要log data fork中的根节点数据
   > xfs_trans_log_inode(xfs_trans, xfs_inode, xfs_bmalloca->logflags)
   - 更新firstblock, 设置为xfs_bmalloca->xfs_btree_cur->bc_private->b->firstblock

** xfs_bmap_del_extent(xfs_inode, xfs_trans, xfs_extnum_t idx, xfs_bmap_free, xfs_btree_cur, xfs_bmbt_irec del, logflags, whichfork)
   - 更新或删除xfs_bmbt_irec?
   - 首先获取idx对应的xfs_bmbt_irec 
   > xfs_iext_get_ext(xfs_ifork, idx)
   > xfs_bmbt_get_all(xfs_bmbt_rec_host, got)
   - got必须覆盖del对应的xfs_bmbt_irec?
   - 如果got是delay allocation, 它的磁盘空间无效 
   > isnullstartblock(got->br_startblock)
   - del也必须是delay allocation
   - 如果delay ==0, got不是delay allocation
   - 删除一个磁盘的xfs_bmbt_rec, 需要释放磁盘空间 
   - 查找对应的xfs_bmbt_rec 
   > xfs_bmbmt_lookup_eq(xfs_btree_cur, got->br_startoff, got->br_startblock, got->br_blockcount, i)
   - 如果delay !=0, 不需要删除磁盘空间
   - 根据del和got的范围操作xfs_bmbt_rec
   - 如果完全重叠, 直接删除xfs_bmbt_rec_host 
   > xfs_iext_remove(xfs_inode, idx, 1, BMAP_ATTRFORK / 0)
   - 如果delay ==0, 还要删除磁盘的xfs_bmbt_rec 
   > xfs_btree_delete(xfs_btree_cur, i)
   - 修改xfs_inode->xfs_icdinode->di_nextents 
   > XFS_IFORK_NEXT_SET(xfs_inode, whichfork, XFS_IFORK_NEXTENTS(xfs_inode, whichfork) - 1)
   - 设置flags的XFS_ILOG_CORE,如果这里没有xfs_btree_cur? 不需要操作btree, 但需要操作xfs_dinode? 设置对应的标志 
   > xfs_ilog_fext(whichfork)
   - 如果是start一样,但end不一样, 只需要修改xfs_bmbt_rec_host?
   > xfs_bmbt_set_startoff(xfs_bmbt_rec_host, del->br_startoff + del->br_blockcount)
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, got->br_blockcount - del->br_blockcount)
   - 如果delay !=0, 还需要修改startblock 
   > xfs_bmap_worst_indlen(xfs_inode, tmp)
   > xfs_bmbt_set_startblock(xfs_bmbmt_rec_host, nullstartblock(tmp))
   - 如果delay ==0, 需要修改磁盘位置 
   > xfs_bmbt_set_startblock(xfs_bmbt_rec_host, del->br_startblock + del->br_blockcount)
   - 而且修改对应的btree节点 
   - 如果xfs_btree_cur == NULL, 只需要再后面log对应的xfs_dinode 
   > xfs_ilog_fext(whichfork)
   - 否则直接修改btree 
   > xfs_bmbt_update(xfs_btree_cur, del->br_startoff + br_blockcount, del->br_blockcount + br_blockcount, got->br_blockcount - del->br_blockcount, got->br_state)
   - 如果是end一样,start不一样, 做类似的修改
   - 对于xfs_bmbt_rec_host, 修改br_blockcount 
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, got->br_blockcount - del->br_blockcount)
   - 如果delay ==0, 只需要再修改xfs_bmbt_rec_host->br_startblock 
   > xfs_bmap_worst_indlen(xfs_inode, temp)
   > xfs_bmbt_set_startblock(xfs_bmbt_rec_host, nullstartblock(tmp))
   - 否则还需要修改btree 
   > xfs_bmbt_update(xfs_btree_cur, got->br_startoff, got->br_startblock, got->br_blockcount - del->br_blockcount, got->br_state)
   - 如果start和end都不一样,需要把got分成3段, 创建新的xfs_bmbt_rec_host
   - 首先更新第一段 
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, del->br_startoff - got->br_startoff)
   - 如果delay ==0, 需要修改btree的xfs_bmbt_rec 
   - 先修改第一部分的blockcount
   > xfs_bmbmt_update(xfs_btree_cur, got->br_startoff, ...)
   - 然后插入第三部分
   > xfs_btree_increment(xfs_btree_cur, i)
   - xfs_btree_cur->bc_rec->xfs_bmbt_irec = new
   > xfs_btree_insert(xfs_btree_cur, i)
   - 增加xfs_icdinode->di_nextents
   - 如果delay !=0, 不需要btree操作,只需要计算2部分的startblock 
   - 他们不是真正的磁盘空间,而是一些分配磁盘的辅助信息 
   - 第一部分
   > xfs_bmap_worst_indlen(xfs_inode, temp)
   > xfs_bmbt_set_startblock(xfs_bmbt_rec_host, nullstartblock(temp))
   - 第三部分做同样的处理
   - 把第三部分的xfs_bmbt_irec放到xfs_ifork中
   > xfs_iext_insert(xfs_inode, idx+1, 1, xfs_bmbmt_irec, state)
   - 修改xfs_inode->xfs_icdinode->di_nblocks -= nblks
   - 这里还要释放相关的磁盘空间 
   > xfs_bmap_add_free(del->br_startblock, del->br_blockcount, xfs_bmap_free, xfs_mount)

** xfs_bunmap(xfs_trans, xfs_inode, xfs_fileoff_t bno, xfs_filblks_t len, flags, xfs_extnum_t nexts, xfs_fsblock_t firstblock, xfs_bmap_free flist, done)
   - 获取对应的xfs_ifork, 准备xfs_bmbt_rec_host信息 
   > xfs_iread_extents(xfs_trans, xfs_inode, whichfork)
   - 如果没有xfs_bmbt_rec信息,直接返回??
   - 处理(bno, len)范围内的xfs_bmbt_rec_host
   - 如果参数nexts有效,处理的个数收到限制
   - 设置bno为范围终点 bno+len
   - 查找最后一个xfs_bmbt_irec
   > xfs_bmap_search_extents(xfs_inode, bno, whichfork, eof, lastx, got, prev)
   - 如果eof !=0, 根据xfs_bmbt_irec更新bno
   - 如果xfs_ifork->if_flags有XFS_IFBROOT, 说明磁盘使用btree储存fork信息, 准备xfs_btree_cur
   - 开始循环处理所有的xfs_bmbt_irec 
   > xfs_iext_get_ext(xfs_ifork, lastx)
   > xfs_bmbt_get_all(xfs_bmbt_rec_host, xfs_bmbt_irec)
   - 首先它的范围必须和参数范围有交叉, end > start
   - 如果是交叉, 创建一个临时的xfs_bmbt_irec, 使用参数的范围设置
   - 否则可以使用查找的xfs_bmbt_irec
   - 如果这个xfs_bmbt_irec是delay allocation, 释放预留的磁盘空间? 
   > xfs_icsb_modify_counters(xfs_mount, XFS_SBS_FDBLOCKS, del->br_blockcount, 0)
   - 减小xfs_inode->i_delayed_blks -= del->br_blockcount
   - 删除对应的xfs_bmbt_irec 
   > xfs_bmap_del_extent(xfs_inode, xfs_trans, lastx, xfs_bmap_free, xfs_btree_cur, xfs_bmbt_irec, mtp_logflags, whichfork)
   - 循环完成后,检查di_format/di_aformat是否需要转化 
   > xfs_bmap_needs_btree(xfs_inode, whichfork)
   > xfs_bmap_extents_to_btree(xfs_trans, xfs_inode, firstblock, xfs_bmap_free, xfs_btree_cur, 0, tmp_logflags, whichfork)
   - 这里还得检查是否从btree转到extents 
   > xfs_bmap_wants_extents(xfs_inode, whichfork)
   > xfs_bmap_btree_to_extents(xfs_trans, xfs_inode, xfs_btree_cur, tmp_logflags, whichfork)
   - 最后log处理 
   > xfs_trans_log_inode(xfs_trans, xfs_inode, logflags)

* xfs_bmap_util.c

** xfs_fsb_to_db(xfs_inode, xfs_fsblock_t)
   - 把xfs_fsblock_t地址转化为磁盘绝对地址
   > XFS_FSB_TO_DADDR(xfs_mount, fsb)
   - 它先分解成agno, agbno, 然后对ag的起始地址做偏移
   > XFS_AGB_TO_ADDR(XFS_FSB_TO_AGNO(xfs_mount, fsbno), XFS_FSB_TO_AGBNO(xfs_mount, fsbno)
   - xfs_fsblock_t单位是fsb, xfs_mount->m_blocklog / xfs_sb->sb_blocksize
   - 对于realtime的文件是直接移位实现

** xfs_bmap_finish(xfs_trans, xfs_bmap_free, committed)
   - transaction完成时使用,释放xfs_bmap_free中的extent
   - xfs_trans->t_flags必须有XFS_TRANS_PERM_LOG_RES
   - 如果xfs_bmap_free->xbf_count ==0, 直接返回  设置committed = 0
   - 创建一个xfs_bmap_free_item的log
   > xfs_trans_get_efi(xfs_trans, xfs_bmap_free->xbf_count)
   - 遍历xfs_bmap_free初始化xfs_bmap_free_item
   > xfs_trans_log_efi_extent(xfs_trans, xfs_efi_log_item, xfs_bmap_free_item->xbfi_startblock, xfs_bmap_free_item->xbfi_blockcount)
   - 复制参数xfs_trans, 备份xfs_trans_res? 
   > xfs_trans_dup(xfs_trans)
   - 提交原来的xfs_trans 
   > xfs_trans_commit(xfs_trans, 0)
   - 释放ticket 
   > xfs_log_ticket_put(xfs_trans->xlog_ticket)
   - 重新reserve空间? 就是上面备份的  
   > xf_trans_reserve(xfs_trans, xfs_trans_res, 0, 0)
   - 构造xfs_efd_log_item
   > xfs_trans_get_efd(xfs_trans, xfs_efi_log_item, xfs_bmap_free->xbf_count)
   - 遍历xfs_bmap_free的xfs_bmap_free_item
   - 先释放内存  
   > xfs_free_extent(xfs_trans, xfs_bmap_free_item->xbfi_startblock, xbfi_blockcount)
   - 同时设置xfs_efd_log_item 
   > xfs_trans_log_efd_extent(xfs_trans, xfs_efd_log_item, xbfi_startblock, xbfi_blockcount)
   > xfs_bmap_del_free(xfs_bmap_free_item, NULL, xfs_bmap_free)
   - 最后怎么没有提交xfs_trans??

** xfs_bmap_rtalloc(xfs_bmalloca)
   - realtime的文件使用

** xfs_bmapi_allocate_worker(work_struct)
   - work_struct是xfs_malloca->work, 用来为xfs_bmalloca分配空间
   > __xfs_bmapi_allocate(xfs_bmalloca)
   - 结果给xfs_bmalloca->result, 并唤醒等待的任务  
   > complete(xfs_bmalloca->done)

** xfs_bmapi_allocate(xfs_bmalloca)
   - 如果xfs_bmalloca->stack_switch ==0, 直接调用? 
   > __xfs_bmapi_allocate(xfs_bmalloca)
   - 否则使用workqueue
   > queue_work(xfs_alloc_wq, xfs_bmalloca->work)
   - 等待结果 
   > wait_for_completion(xfs_bmalloca->done)

** xfs_bmap_eof(xfs_inode, xfs_fileoff_t endoff, whichfork, eof)
   - 检查endoff是否超过文件eof
   - 获取最后一个xfs_bmbt_rec
   > xfs_bmap_last_extent(NULL, xfs_inode, whichfork, xfs_bmbt_irec, eof)
   - 比较endoff 和xfs_bmbt_irec->br_startoff + br_blockcount

** xfs_bmap_count_leaves(xfs_ifork, xfs_extnum_t idx, numrecs, count)
   - 累计xfs_ifork中的(idx,numrecs)的xfs_bmbt_rec_host的长度
   - 获取对应的xfs_bmbt_rec_host 
   > xfs_iext_get_ext(xfs_ifork, idx)
   - 累加br_blockcount
   > xfs_bmbt_get_blockcount(xfs_bmbt_rec_host)

** xfs_bmap_disk_count_leaves(xfs_mount, xfs_btree_block, numrecs, count)
   - xfs_btree_block是叶子节点,遍历numrecs个xfs_bmbt_rec
   > XFS_BMBT_REC_ADDR(xfs_mount, xfs_bmbt_rec, indx)
   - 累加blockcount 
   > xfs_bmbt_disk_get_blockcount(xfs_bmbt_rec)

** xfs_bmap_count_tree(xfs_mount, xfs_trans, xfs_ifork, xfs_fsblock_t blockno, levelin, count)
   - 遍历xfs_ifork使用的btree的总的空间,包含节点使用的block数量, 还有xfs_bmbt_rec映射的磁盘数量
   - 读取AG中blockno对应的block, 它是extent映射btree的节点
   > xfs_btree_read_bufl(xfs_mount, xfs_trans, bno, 0, xfs_buf, XFS_BMAP_BTREE_REF, xfs_bmbt_buf_ops)
   - 获取xfs_btree_block 
   > XFS_BUF_TO_BLOCK(xfs_buf)
   - level表示父节点的高度, 用来判断当前节点是叶子节点还是内部节点
   - 如果是内部节点, 遍历这一层的兄弟节点, 统计个数加到count
   > xfs_btree_read_bufl(xfs_mount, xfs_trans, nextbno, 0, xfs_buf, XFS_BMAP_BTREE_REF, xfs_bmbt_buf_ops)
   - 获取节点的右兄弟指针,继续遍历 
   > be64_to_cpu(xfs_btree_block->bb_u->l->bb_rightsib
   - 读出来就释放,这里只是预读 
   > xfs_trans_brelse(xfs_trans, xfs_buf)
   - 然后然后处理下一层, 使用递归实现, 这里完全不需要递归
   - 获取第一个子分支的磁盘位置
   > XFS_BMBT_PTR_ADDR(xfs_mount, xfs_btree_block, 1, xfs_mount->m_bmap_dmxr[1])
   > xfs_bmap_count_tree(xfs_mount, xfs_trans, xfs_ifork, bno, level, count)
   > xfs_trans_brelse(xfs_trans, xfs_buf)
   - 如果是叶子节点, 使用右兄弟指针遍历所有的叶子节点
   - xfs_btree_block->bb_u->l->bb_rightsib
   - 同时累加xfs_bmbt_rec管理的磁盘长度 
   > xfs_bmap_disk_count_leaves(xfs_mount, xfs_btree_block, numrecs, count)
   > xfs_trans_brelse(xfs_mount)
   - 然后读取下一个兄弟节点继续遍历
   > xfs_btree_read_bufl(xfs_mount, xfs_trans, bno, 0, xfs_buf, XFS_BMAP_BTREE_REF, xfs_bmbt_buf_ops)

** xfs_bmap_count_blocks(xfs_trans, xfs_inode, whichfork, count)
   - 获取需要操作的xfs_ifork 
   > XFS_IFORK_PTR(xfs_inode, whichfork)
   - 如果di_format使用XFS_DINODE_FMT_EXTENTS,xfs_ifork在磁盘中没有使用btree,应该相当于根结点只是一个叶子节点
   > xfs_bmap_count_leaves(xfs_ifork, 0, xfs_ifork->if_bytes / sizeof(xfs_bmbt_rec), count)
   - 否则根结点使用xfs_btree_block
   - 得到根结点第一个分支指针
   > XFS_BMAP_BROOT_PTR_ADDR(xfs_mount, xfs_btree_block, 1, xfs_ifork->if_broot_bytes)
   - 开始递归遍历, level是根结点高度 xfs_btree_block->bb_level
   > xfs_bmap_count_tree(xfs_mount, xfs_trans, xfs_ifork, bno, level, count)

** getbmapx 
   - 在ioctl的FS_IOC_FIEMAP中使用,辅助数据结构
   - 或者在xfs的ioctl中使用
   - 它应该表示一个xfs_bmbt_irec的信息
   #+BEGIN_SRC 
	__s64		bmv_offset;	/* file offset of segment in blocks */
	__s64		bmv_block;	/* starting block (64-bit daddr_t)  */
	__s64		bmv_length;	/* length of segment, blocks	    */
	__s32		bmv_count;	/* # of entries in array incl. 1st  */
	__s32		bmv_entries;	/* # of entries filled in (output). */
	__s32		bmv_iflags;	/* input flags (1st structure)	    */
	__s32		bmv_oflags;	/* output flags (after 1st structure)*/
	__s32		bmv_unused1;	/* future use			    */
	__s32		bmv_unused2;	/* future use			    */   
   #+END_SRC

** xfs_getbmapx_fix_eof_hole(xfs_inode, getbmapx, preallocated, end, startblock)
   - 如果eof位置的xfs_bmbt_rec表示Hole,组装对应的getbmapx
   - 如果startblock == HOLESTRATBLOCK, 设置getbmapx->bmv_block = -1
   - 长度是从getbmapx->bmv_block 到 eof, fixlen -= getbmapx->bmv_offset
   > XFS_FSB_TO_BB(xfs_mount, XFS_B_TO_FSB(xfs_mount, XFS_ISIZE(xfs_inode))
   - 如果preallocated !=0, 而且bmv_offset + bmv_length == end? 设置getbmapx->bmv_length = fixlen??  怎么决定getbmapx?
   - 如果startblock是DELAYSTRATBLOCK, 设置bmv_block = -2
   - 否则startblock是有效的磁盘位置, 单位转化为fsb
   > xfs_fsb_to_db(xfs_inode, startblock)
   - 处理extent的开始文件偏移, getbmapx->bmv_offset, 单位转化为fsb
   > XFS_BB_TO_FSB(xfs_mount, getbmapx->bmv_offset)
   - 搜索在data fork中对应的xfs_bmbt_rec_host 
   > xfs_iext_bno_to_ext(xfs_ifork, fileblock, lastx)
   - 如果他是最后一个, 设置getbmapx->bmv_oflags的BMV_OF_LAST

** xfs_getbmap(xfs_inode, getbmapx, xfs_bmap_format, arg)
   - 填充getbmapx的extent磁盘信息 
   - 最后使用xfs_bmap_format把这些信息给arg/fiemap_extent_info
   - 根据getbmapx->bmv_iflags获取操作的xfs_ifork
   - 如果有BMV_IF_ATTRFORK, 就是XFS_ATTR_FORK, 否则是XFS_DATA_FORK
   - 如果是attr fork, 数据量最多是4G, 设置preallocated =0
   - 如果是data fork, di_format必须是XFS_DINODE_FMT_EXTENTS/BTREE/LOCAL
   - extent size hint是什么?? 
   - 如果di_flags使用XFS_DIFLAG_PREALLOC或XFS_DIFLAG_APPEND, 或者有XFS_DIFLAG_EXTSIZE
   - 说明有preallocate, 数据长度限制为最大长度  super_block->s_maxbytes
   - 否则没有preallocate, 数据长度显示为文件大小 
   > XFS_ISIZE(xfs_inode)
   - 根据上面数据长度限制更新getbmapx->bmv_length
   - 如果getbmapx->bmv_length ==0, 直接返回
   - 分配getbmapx数组??  长度是getbmapx->bmv_count
   - 锁住inode, 使用XFS_IOLOCK_SHARED
   > xfs_ilock(xfs_inode, XFS_IOLOCK_SHARED)
   - 如果访问data fork, 而且getbmax->bmv_flags没有BMV_IF_DELALLOC, 不能有delalloc的extent
   - 把数据写回磁盘
   > filmap_write_and_wait(xfs_inode->address_space)
   - 计算需要的文件锁? 下面可能升级锁
   > xfs_ilock_map_shared(xfs_inode)
   - 根据whichfork计算getbmapx->bmv_flags? 
   > xfs_bmapi_aflag(whichfork)
   - 如果原来没有BMV_IF_PREALLOC, 设置XFS_BMAPI_IGSTATE???
   - 遍历getbmap范围内的xfs_bmbt_irec,  (getbmapx->bmv_offset, bmv_length)
   > xfs_bmapi_read(xfs_inode, XFS_BB_TO_FSB(xfs_mount, getbmapx->bmv_offset), XFS_BB_TO_FSB(xfs_mount, getbmapx->bmv_length), xfs_bmbt_irec, nmap, bmapi_flags)
   - 遍历xfs_bmbt_irec, 把信息给getbmapx数组
   - 如果br_state是XFS_EXT_UNWRITTEN, 设置bmv_oflags的BMV_OF_PREALLOC
   - 如果br_startblock是DELAYSTRATBLOCK, 设置bmv_oflags的BMV_OF_DELALLOC
   - br_startoff转化成bmv_offset, 单位变为BB
   - br_blockcount转化为bmv_length, 单位变为BB
   - 主要是设置getbmapx->bmv_block
   > xfs_getbmap_fix_eof_hole(xfs_inode, getbmapx, preallocated, bmvend, br_startblock)
   - 如果是Hole,设置bmv_block == -1, 如果是delay?? bmv_block = -2
   - 对于delay write, 通过bmv_oflags展示. 有磁盘信息,但磁盘中是无效的, 这时preallocation? 
   - 对于hole通过bmv_block, 没有磁盘位置, 也没有数据
   - 对于delay alloc?? DELAYSTRATBLOCK，通过bmv_start / bmv_oflags, 有数据,但没磁盘位置
   - 最后使用回调函数放到args中 
   > formatter(arg, getbmapx, full)

** xfs_bmap_punch_delalloc_range(xfs_inode, xfs_fileoff_t start_fsb, xfs_fileoff_t length)
   - 遍历(start_fsb, length)范围内的xfs_bmbt_irec
   > xfs_bmapi_read(xfs_inode, start_fsb, 1, xfs_bmbt_irec, nmaps, XFS_BMAPI_ENTIRE)
   - 如果不是delay allocation ?? 直接跳过??
   > xfs_bmbt_irec->br_startblock  != DELAYSTRATBLOCK
   - br_blockcount !=0, 肯定不能是0?
   - 准备空的xfs_bmap_free
   - 如果找到delay alloc的xfs_bmbt_irec, 说明start_fsb对应的文件偏移怎么样?
   - 释放底层的xfs_bmbt_irec
   > xfs_bunmapi(NULL, xfs_inode, start_fsb, 1, 0, 1, firstblock, xfs_bmap_free, done)
   - 然后增加start_fsb ++, 继续查找, 这样效率也太慢了

** xfs_can_free_eofblocks(xfs_inode, force)
   - 检查是否删除eof后面的磁盘空间? prealocation/append?
   - 如果xfs_inode->i_size ==0, 而且xfs_inode->i_delayed_blks ==0, 而且inode的address_space->nrpages==0. 磁盘中文件为0, 而且没有pagecache, 返回0
   - 如果xfs_inode->xfs_ifork->if_flags没有XFS_IFEXTENTS,还没有缓存xfs_bmbt_rec, 肯定没有IO或者preallocation. 之前的不会考虑
   - xfs_inode->xfs_ifork->if_flags的XFS_DIFLAG_PREALLOC和XFS_DIFLAG_APPEND表示有空间
   - 如果force ==0或者xfs_inode->i_delayed_blks==0, 返回true,表示可以释放多余磁盘
   - 否则返回false, 没有必要或没有空间可释放

** xfs_free_eofblocks(xfs_mount, xfs_inode, need_iolock)
   - 在inode释放时调用 inode_operations->evict 间接使用
   - 获取xfs_inode大小, end_fsb 普通文件就是 inode->i_size 
   > XFS_B_TO_FSB(xfs_mount, XFS_ISIZE(xfs_inode))
   - 查找end_fsb使用的xfs_bmbt_irec 
   > xfs_bmapi_read(xfs_inode, end_fsb, map_len, xfs_bmbt_irec, 1, 0)
   - 如果没有问题,而且xfs_bmbt_irec不是hole, 使用delayed alloc, xfs_inode->i_delayed_blks >0
   - 需要释放eof后面的磁盘空间
   - 构造xfs_trans, 这是inactive事件?
   > xfs_trans_alloc(xfs_mount, XFS_TRANS_INACTIVE)
   - 锁住文件
   > xfs_ilock_nowait(xfs_inode, XFS_IOLOCK_EXCL)
   > xfs_trans_reserve(xfs_trans, xfs_mount->m_resv->tr_itruncate, 0, 0)
   - 把xfs_inode放到xfs_trans中
   > xfs_trans_ijoin(xfs_trans, xfs_inode, 0)
   - 不需要更新xfs_dinode->di_size?? 文件数据已经写回去? 怎么会有NULL file?
   > xfs_itruncate_extents(xfs_trans, xfs_inode, XFS_DATA_FORK, XFS_ISIZE(xfs_inode))
   - 提交xfs_trans 
   > xfs_trans_commit(xfs_trans, XFS_TRANS_RELEASE_LOG_RES)
   > xfs_inode_clear_eofblocks_tag(xfs_inode)
   - 怎么会有超过eof的xfs_bmbt_rec_host?? 哪里分配的? 或者修改了size?

** xfs_alloc_file_space(xfs_inode, xfs_off_t offset, len, alloc_type)
   - 为文件的(offset,len)范围分配空间? preallocation?
   - alloc_type表示分配的目的, 必须XFS_BMAPI_PREALLOC,XFS_BMAPI_CONVERT
   - 如果文件extent需要地址对齐, 获取xfs_inode->xfs_icdinode->di_extsize
   > xfs_get_extsz_hint(xfs_inode)
   - 对开始偏移和结束偏移都对齐
   - 首先预留磁盘空间, 计算预留数量还需要考虑btree的更新使用的磁盘空间
   - 不应该2个btree?
   > XFS_DIOSTRAT_SPACE_RES(xfs_mount, resblks)
   - 创建xfs_trans, XFS_TRANS_DIOSTRAT?? 战略??
   > xfs_trans_alloc(xfs_mount, XFS_TRANS_DIOSTRAT)
   > xfs_trans_reserve(xfs_trans, xfs_mount->m_resv->tr_write, resblks, resrtextents)
   - 锁住xfs_inode, 并添加到xfs_trans中 
   > xfs_ilock(xfs_inode, XFS_ILOCK_EXCL)
   > xfs_trans_ijoin(xfs_trans, xfs_inode, 0)
   - 创建xfs_bmbt_rec_host? 准备一个xfs_bmap_free?? 
   > xfs_bmap_init(xfs_bmap_free, firstfsb)
   - 分配磁盘空间,或改变preallocation的空间
   > xfs_bmapi_write(xfs_trans, xfs_inode, startoffset_fsb, allocatsize_fsb, alloc_type, firstfsb, 0, xfs_bmbt_irec, nmaps, xfs_bmap_free)
   - 为何会释放内存??
   > xfs_bmap_finish(xfs_trans, xfs_bmap_free, committed)
   - 提交xfs_trans 
   > xfs_trans_commit(xfs_trans, XFS_TRANS_RELEASE_LOG_RES)
   - 根据分配的空间,向前移动startoffset_fsb, 直到分配足够的空间

** xfs_zero_remaining_bytes(xfs_inode, startoff, endoff)
   - 处理没有地址对齐的空间?
   - 如果startoff超过eof, 直接返回
   > XFS_ISIZE(xfs_inode)
   - 如果endoff > eof, 设置为eof
   - 准备一个xfs_buf,大小是blocksize 
   > xfs_buf_get_uncached(xfs_buftarg, BTOBB(xfs_sb->sb_blocksize), 0)
   - 遍历(startoff, endoff)之间的xfs_bmbt_irec 
   > xfs_bmapi_read(xfs_inode, offset_fsb, 1, xfs_bmbt_irec, nmaps, 0)
   - xfs_bmbt_irec->br_startoff必须和offset_fsb相同, 如何保证?
   - 如果xfs_bmbt_irec是hole, br_startblock == HOLDSTRATBLOCK, 不处理
   - xfs_bmbt_irec不能是delalloc?  DELAYSTRATBLOCK
   - 如果br_state是XFS_EXT_UNWRITTEN, 直接返回,不处理
   - 准备xfs_buf, 去掉XBF_DONE,XBF_WRITE, 设置XBF_READ
   - 设置地址为xfs_bmbt_irec->br_startblock, 读取数据 
   > xfsbdstrat(xfs_mount, xfs_buf)
   > xfs_buf_iowait(xfs_buf)
   - 然后设置(startoff, endoff)在这个block内的数据设置为0. 这里的xfs_buf只有一个block
   - 然后把xfs_buf写回去, 去掉XBF_DONE,XBF_READ, 设置XBF_WRITE 
   > xfsbdstrat(xfs_mount, xfs_buf)
   > xfs_buf_iowait(xfs_buf)
   - 然后操作下一个block

** xfs_free_file_space(xfs_inode, xfs_off_t offset, len)
   - 释放(offset,len)范围内的磁盘空间?
   - 首先等待dio完成  
   > inode_dio_wait(inode)
   - 等待数据写回磁盘 
   > fiemap_write_and_wait_range(inode->address_space, offset, -1)
   - 如果offset,len没有block地址对齐,需要把不需要释放的磁盘写为0
   - 如果(offset,len)在一个block上面,直接清空对应的数据, 而且不需要其他操作
   > xfs_zero_remaining_bytes(xfs_inode, offset, len-1)
   - 如果跨越多个block, 需要把2头的数据清空 
   > xfs_zero_remaining_bytes(xfs_inode, XFS_FSB_TO_B(xfs_mount, endoffset_fsb) - 1)
   - 然后释放中间的对齐的block
   - 构造xfs_trans
   > xfs_trans_alloc(xfs_mount, XFS_TRANS_DIOSTRAT)
   > xfs_trans_reserve(xfs_trans, xfs_mount->m_resv->tr_write, resblks, 0)
   - log inode? 
   > xfs_trans_ijoin(xfs_trans, xfs_inode, 0)
   > xfs_bmap_init(xfs_bmap_free, firstfsb)
   - 修改btree/xfs_ifork信息
   > xfs_bunmapi(xfs_trans, xfs_inode, startoffset_fsb, ...)
   - 然后释放磁盘空间 
   > xfs_bmap_finish(xfs_trans, xfs_bmap_free, committed)
   > xfs_trans_commit(xfs_trans, XFS_TRANS_RELEASE_LOG_RES)

** xfs_zero_file_space(xfs_inode, end, len)
   - 遍历(end,len)文件范围, 首先删除pagecache 
   > xfs_alloc_file_space(xfs_inode, start_boundary, end_boundary - start_boundary - 1)
   - 然后分配磁盘空间,创建xfs_bmbt_rec, 修改状态为XFS_FMT_UNWRITTEN
   - 如果地址不是对齐的, 把其他block中的部分数据清0
   - 下面使用address_operations实现
   > xfs_iozero(xfs_inode, offset, start_boundary - offset)

** xfs_swap_extents_check_format(xfs_inode ip, xfs_inode tmpip)
   - swap extents??

** xfs_swap_extents(xfs_inode ip, tip, xfs_swapext)
