* xfs_aops.c

** xfs_count_page_state(page, delalloc, unwritten)
   - 检查page的状态
   - 遍历page的buffer_header 
   > page_buffers(page)
   - 检查buffer_head的状态
   - 如果存在BH_Unwritten, unwritten = 1
   > buffer_unwritten(buffer_head)
   - 如果存在BH_Delay, delalloc = 1 
   > buffer_delay(buffer_head)

** xfs_find_bdev_for_inode(inode)
   - 查找inode的数据使用的磁盘
   - 如果是realtime inode，使用xfs_mount->m_rtdev_targp
   - 否则使用xfs_mount->m_ddev_targp->bt_bdev

** xfs_ioend 
   #+BEGIN_SRC 
	struct xfs_ioend	*io_list;	/* next ioend in chain */
	unsigned int		io_type;	/* delalloc / unwritten */
	int			io_error;	/* I/O error code */
	atomic_t		io_remaining;	/* hold count */
	unsigned int		io_isasync : 1;	/* needs aio_complete */
	unsigned int		io_isdirect : 1;/* direct I/O */
	struct inode		*io_inode;	/* file being written to */
	struct buffer_head	*io_buffer_head;/* buffer linked list head */
	struct buffer_head	*io_buffer_tail;/* buffer linked list tail */ //这里使用的buffer_head->b_private链表?
	size_t			io_size;	/* size of the extent */
	xfs_off_t		io_offset;	/* offset in the file */
	struct work_struct	io_work;	/* xfsdatad work queue */
	struct xfs_trans	*io_append_trans;/* xact. for size update */
	struct kiocb		*io_iocb;
	int			io_result;   
   #+END_SRC

** xfs_destroy_ioend(xfs_ioend)
   - IO完成后释放xfs_ioend, 需要释放buffer_head, bio, inode?
   - 遍历io_buffer_head队列的buffer_head 
   > buffer_head->b_end_io(buffer_head, xfs_ioend->io_error)
   - 如果xfs_ioend->io_iocb有效, 才调用回调??
   > inode_dio_done(xfs_ioend->io_inode)
   - 如果是异步, xfs_ioend->io_isasync 
   > aio_complete(xfs_ioend->io_iocb, xfs_ioend->io_result, 0)
   - 这里回唤醒kiocb??
   - 最后释放xfs_ioend 

** xfs_ioend_is_append(xfs_ioend)
   - 检查是否是append io?
   - xfs_ioend->io_offset + io_size > xfs_inode->xfs_icdinode->di_size ?? 

** xfs_setfilesize_trans_alloc(xfs_ioend)
   - 构造xfs_trans 
   > xfs_trans_alloc(xfs_mount, XFS_TRANS_FSYNC_TS)
   - 预留空间, XFS_FSNC_TS_LOG_RES??
   > xfs_trans_reserve(xfs_trans, 0, XFS_FSYNC_TS_LOG_RES(xfs_mount), 0, 0,0)
   - 把上面创建的xfs_trans给xfs_ioend->io_append_trans
   
** xfs_setfilesize(xfs_ioend) 
   - IO完成后释放更新文件大小
   - 锁住inode 
   > xfs_ilock(xfs_inode, XFS_ILOCK_EXCL) 
   - 计算新的文件大小, 它不能超过i_size, 而且必须比di_size大才需要更新??
   - 在a_ops->write中回更新i_size
   > xfs_new_eof(xfs_inode, xfs_ioend->io_offset + io_size)
   - 设置xfs_inode->xfs_icdinode->di_size 
   > xfs_trans_ijoin(xfs_trans, xfs_inode, XFS_ILOCK_EXCL)
   > xfs_trans_log_inode(xfs_trans, xfs_inode, XFS_ILOG_CORE)

** xfs_finish_ioend(xfs_ioend)
   - 释放xfs_ioend的使用计数,如果减为0, 释放资源?
   > atomic_dec_and_test(xfs_ioend->io_remaining) 
   - 如果xfs_ioend->io_type == XFS_IO_UNWRITTEN? 
   > queue_work(xfs_mount->m_unwritten_workqueue, xfs_ioend->io_work)
   - 如果是append IO? 或者directIO 
   > xfs_ioend_is_append(xfs_ioend)
   > queue_work(xfs_mount->m_data_workqueue, xfs_ioend->io_work)
   - 否则直接释放xfs_ioend 
   > xfs_destroy_ioend(xfs_ioend)

** xfs_end_io(work_struct)
   - 参数是xfs_ioend->io_work
   - 什么是XFS_IO_UNWRITTEN, 只分配空间,但没有写数据?
   > xfs_iomap_write_unwritten(xfs_inode, xfs_ioend->io_offset, xfs_ioend->io_size)
   - 如果是direct IO, 修改文件大小? 
   > xfs_setfilesize_trans_alloc(xfs_ioend)
   > xfs_setfilesize(xfs_ioend)
   - 如果只是append? 
   > xfs_setfilesize(xfs_ioend)
   - 最后释放xfs_ioend 
   > xfs_destroy_ioend(xfs_ioend)

** xfs_finish_ioend_sync(xfs_ioend)
   - 释放xfs_ioend->io_remaining计数 
   - 这是同步方式, 直接调用
   > xfs_end_io(xfs_ioend->io_work)

** xfs_alloc_ioend(inode, type)
   - 构造xfs_ioend, 只是设置io_type = type? 

** xfs_bmbt_irec 
   - extent数据, 单位都是  inode->i_blkbits
   #+BEGIN_SRC 
	xfs_fileoff_t	br_startoff;	/* starting file offset */
	xfs_fsblock_t	br_startblock;	/* starting block number */
	xfs_filblks_t	br_blockcount;	/* number of blocks */
	xfs_exntst_t	br_state;	/* extent state */   
   #+END_SRC

** xfs_map_blocks(inode, offset, xfs_bmbt_irec, type, nonblocking)
   - 查找offset对应的extent?
   - 如果type == XFS_IO_UNWRITTEN, 忽略state? XFS_BMAPI_IGSTATE
   - 先锁住inode, 使用XFS_ILOCK_SHARED 
   > xfs_ilock_nowait(xfs_inode, XFS_ILOCK_SHARED)
   - 如果锁不住,而且nonblocking!=0, 返回EAGAIN
   - 否则等待这个锁 
   > xfs_ilock(xfs_inode, XFS_ILOCK_SHARED)
   - 开始查找extent, 范围是(offset, -1)
   - 最大值是super_block->s_maxbytes
   - 转化为FSB 
   > XFS_B_TO_FSB(xfs_mount, offset)
   - 只会返回1个xfs_bmbt_irec
   > xfs_bmapi_read(xfs_inode, offset_fsb, end_fsb-offset_fsb, xfs_bmbt_irec, nimaps, bmapi_flags)
   - 释放xfs_inode的锁 
   > xfs_iunlock(xfs_inode, XFS_ILOCK_SHARED)
   - 如果type是XFS_IO_DELALLOC,而且没有找到xfs_bmbt_irec, 或者找到的是hole 
   > isnullstartblock(xfs_bmbt_irec->br_startblock)
   - 更新btree? 
   > xfs_iomap_write_unwritten(xfs_inode, offset, count, xfs_bmbt_irec)

** xfs_imap_valid(xfs_inode, xfs_bmbt_irec, offset)
   - 验证xfs_bmbt_irec的有效性
   - offset应该在xfs_bmbt_irec->br_startoff和br_blockcount之间
   - 两者单位是什么?  xfs_inode->i_blkbits, 是bb还是fsb?

** xfs_end_bio(bio, error)
   - bio的回调函数
   - 处理bio->bi_private,也就是xfs_ioend
   - 根据bio->bi_flags的BIO_UPTODATE确定io的结果
   - 首先处理bio 
   > bio_put(bio)
   > xfs_finish_ioend(xfs_ioend)

** xfs_submit_ioend_bio(writeback_control, xfs_ioend, bio)
   - 提交bio, 首先配置bio
   - 增加xfs_ioend->io_remaining计数
   - 设置bio->bi_end_io = xfs_end_bio 
   > submit_bio(writeback_control->sync_mode == WB_SYNC_ALL? WRITE_SYNC:WRITE, bio)

** xfs_alloc_ioend_bio(buffer_head)
   - 构造bio, 为何使用多个iovec?
   > bio_get_nr_vecs(buffer_head->b_bdev)
   > bio_alloc(GFP_NOIO, nvecs)
   - 计算bio的起始位置??
   > buffer_head->b_blocknr * buffer_head->b_size >>9

** xfs_start_buffer_writeback(buffer_head)
   - 检查buffer_head的状态，必须是BH_Mapped, BH_Locked 
   - 不能是BH_Delay? BH_Unwritten??
   - 异步写? 通用的函数, 使bio回调通用的函数
   > mark_buffer_async_write(buffer_head)
   - 设置BH_Uptodate, 清除BH_Dirty 
   > set_buffer_uptodate(buffer_head)
   > clear_buffer_dirty(buffer_head)
   - 没有衍生的操作? 比如修改计数?

** xfs_start_page_writeback(page, clear_dirty, buffers)
   - 写回page? 检查page的状态
   - 必须有PG_locked, 而且没有PG_writeback
   - 如果clear_dirty !=0, 修改标志 
   > clear_page_dirty_for_io(page)
   - 准备启动bio 
   > set_page_writeback(page)
   > unlock_page(page)
   - 如果buffers ==0, 没有必要IO? 
   > end_page_writeback(page)

** bio_add_buffer(bio, buffer_head)
   - 向bio中增加iovec
   > bio_add_page(bio, buffer_head->b_page, buffer_head->b_size, bh_offset(buffer_head))

** xfs_submit_ioend(writeback_control, xfs_ioend, fail)
   - xfs_ioend是单链表, 使用xfs_ioend->io_list
   - 遍历每个xfs_ioend中的buffer_head
   - 修改buffer_head的标志
   > xfs_start_buffer_writeback(buffer_head)
   - 再次遍历, 提交bio 
   - 首先分配bio
   > xfs_alloc_ioend_bio(buffer_head)
   - 后续的buffer_head可以合并到这里
   > bio_add_buffer(bio, buffer_head)
   - 如果无法合并,先提交之前的io, 创建新的 
   > xfs_submit_ioend_bio(writeback_control, xfs_ioend, bio)

** xfs_cancel_ioend(xfs_ioend)
   - 释放xfs_ioend中的buffer_head 
   > clear_buffer_async_write(buffer_head)
   > unlock_buffer(buffer_head)
   - 直接释放xfs_ioend

** xfs_add_to_ioend(inode, buffer_head, xfs_off_t, type, xfs_ioend, need_ioend)
   - 把buffer_head添加到xfs_ioend管理中
   - 首先检查buffer_head能否放到参数中
   - need_ioend ==0, 而且type == xfs_ioend->io_type
   - 把buffer_head放到xfs_ioend->io_buffer_tail中, 果然使用buffer_head->b_private
   - 否则创建新的xfs_ioend 
   > xfs_alloc_ioend(inode, type)
   - 设置xfs_ioend->io_offset 为参数offset
   - 并且把xfs_ioend放到参数的xfs_ioend->io_list链表中
   - 还要增加xfs_ioend->io_size += buffer_head->b_size 

** xfs_map_buffer(inode, buffer_head, xfs_bmbt_irec, xfs_off_t)
   - 根据xfs_bmbt_irec计算buffer_head的磁盘位置
   - xfs_off_t是文件偏移,以字节为单位, 同样转换xfs_bmbt_irec->br_startoff 
   > XFS_FSB_TO_B(xfs_mount, xfs_bmbt_irec->br_startoff)
   - 磁盘位置先转化为磁盘绝对位置, 以BB为单位, fsb包含agno,agbno 
   > xfs_fsb_to_db(xfs_inode, xfs_bmbt_irec->br_startblock)
   - 然后根据文件位置做偏移,转化为inode->i_blkbits为单位, 应该是sectorsize?
   - 设置buffer_head->b_blocknr
   - 设置BH_Mapped

** xfs_map_at_offset(inode, buffer_head, xfs_bmbt_irec, xfs_off_t)
   - 影射buffer_head的磁盘位置  
   > xfs_map_buffer(inode, buffer_head, xfs_bmbt_irec, xfs_off_t)
   - 有设置BH_Mapped? 
   - 去掉BH_Delay, BH_Unwritten

** xfs_check_page_type(page, type)
   - 检查page是否和type一致??
   - 如果paeg在写回PG_writeback, 返回0
   - 如果page有buffer_head, 遍历它的buffer_head
   > page_has_buffers(page)
   - XFS_IO_UNWRITTEN要求BH_Unwritten
   - XFS_IO_DELALLOC要求BH_Delay
   - XFS_IO_OVERWRITE要求BH_Mapped
   - 只有存在和type对应的buffer_head时才返回1

** xfs_convert_page(inode, page, loff_t, xfs_bmbt_irec, xfs_ioend, writeback_control)
   - 为page构造buffer_head, 并影射磁盘信息 
   - 只处理delalloc/unwritten的page
   - 先检查page状态
   - page->index == loff_t, 文件偏移
   - 锁住page, PG_lock, 如果有PG_writeback, 返回
   - 检查io类型 
   > xfs_check_page_type(page, xfs_ioend->io_type)
   - 计算需要IO的buffer_head的个数, 每个处理的长度是inode->i_blkbits?
   - 只有文件的最后一个page需要处理 
   - end_offset = min((page->index + 1) <<PAGE_CACHE_SHIFT, i_size_read(inode))
   - 检查extent信息
   > xfs_imap_valid(inode, xfs_bmbt_irec, end_offset)
   - buffer_head的个数是 end_offset & PAGE_CACHE_SHIFT >> inode->i_blkbits
   - 遍历它的buffer_head
   - 如果page/buffer_head都不是有效的,PG_uptodate/BH_Uptodate, 不处理?
   - 只处理3种buffer_head, BH_Unwritten/BH_Delay/BH_Mapped
   > xfs_imap_valid(inode, xfs_bmbt_irec, offset)
   - 对于BH_Unwritten, 使用io_type是XFS_IO_UNWRITTEN
   - 对于BH_Delay, 使用io_type是XFS_IO_DELALLOC
   - 其他使用XFS_IO_OVERWRITE
   - 影射buffer_head的磁盘位置 
   > xfs_map_at_offset(inode, buffer_head, xfs_bmbt_irec, offset)
   - 提交bio
   > xfs_add_to_ioend(inode, buffer_head, offset, type, xfs_ioend, done)
   - 最后可以更新page的PG_uptodate
   - 释放page的锁, 修改状态
   > xfs_start_page_writeback(page, !page_dirty, count)

** xfs_cluster_write(inode, pgoff_t tindex, xfs_bmbt_irec, writeback_control, pgoff_t tlast)
   - 处理(tindex,tlast)之间的page, 属于同一个extent?
   - 循环处理, 先在address_space中查找 
   > pagevec_lookup(page, inode->address_space, tindex, len)
   - 然后提交所有的page 
   > xfs_convert_page(inode, page, tindex, xfs_bmbt_irec, xfs_ioend, writeback_control)
   - 这样也积累了一个队列的xfs_ioend 

** xfs_vm_invalidatepage(page, offset, length)
   - 释放address_space中的page 
   > block_invalidatepage(page, offset, length)

** xfs_aops_discard_page(page)
   - 检查page是否有delalloc的buffer_head
   > xfs_check_page_type(page, XFS_IO_DELALLOC)
   - 遍历page的buffer_header, 只处理BH_Delay的
   - 为何合理处理整个page的偏移??
   > XFS_B_TO_FSB(xfs_mount, offset)
   > xfs_bmap_punch_delalloc_range(xfs_inode, start_fsb, 1)
   - 释放pagecache 
   > xfs_vm_invalidatepage(page, 0, PAGE_CACHE_SIZE)

** xfs_vm_writepage(page, writeback_control)
   - 这是address_space的回调函数, 把page写回磁盘
   - 对于BH_Delay, 需要分配空间, 然后发送bio
   - 对于BH_Unwritten, 需要做什么?? 
   - 其他的只需要发送bio
   - 检查current->flags的PF_FSTRANS, 不能在transaction中操作??
   - 如果处理文件最有一个page,需要清空文件大小之外的数据 i_size
   - 遍历所有的buffer_head
   - 检查BH_Uptodate, 如果所有的buffer_head都有,才设置PG_uptodate
   - 如果没有BH_Mapped,但有BH_Uptodate? 放到后面处理?
   - 检查buffer_head的状态, 确定对应的io_type
   - 如果和前一个io_type一样,不需要重新获取xfs_bmbt_irec, 否则需要 
   > xfs_map_blocks(inode, offset, xfs_bmbt_irec, type, noblocking) 
   - 验证offset是否在xfs_bmbt_irec里面
   > xfs_imap_valid(inode, xfs_bmbt_irec, offset)
   - 如果xfs_bmbt_irec可用, 计算buffer_head的磁盘位置  
   > xfs_map_at_offset(inode, buffer_head, xfs_bmbt_irec, offset)
   - 把它给xfs_ioend 
   > xfs_add_to_ioend(inode, buffer_head, offset, type, xfs_ioend, new_ioend)
   - 设置page状态 
   > xfs_start_page_writeback(page, 1, count)
   - 然后提交page后面的数据??
   > xfs_cluster_write(inode, page->index+1, xfs_bmbt_irec, xfs_ioend, writeback_control, end_index)
   - 构造log, 为修改文件大小准备? 
   - xfs_ioend->io_type != XFS_IO_UNWRITTEN, 而且是append 
   > xfs_ioend_is_append(xfs_ioend)
   > xfs_setfilesize_trans_alloc(xfs_ioend)
   - 提交xfs_ioend 
   > xfs_submit_ioend(writeback_control, xfs_ioend, err)

** xfs_vm_writepages(address_space, writeback_control)
   - 去掉xfs_inode->i_flags的XFS_ITRUNCATED?? 
   > xfs_iflags_clear(xfs_inode, XFS_ITRUNCATED) 
   - 使用vfs接口处理 
   > generic_writepages(address_space, writeback_control)

** xfs_vm_releasepage(page, gfp_t)
   - 检查page是否可以释放? 
   > xfs_count_page_state(page, delalloc, unwritten)
   - 如果是delaye/unwritten, 不可以释放? 
   - 然后检查buffer_head 
   > try_to_free_buffers(page)

** __xfs_get_blocks(inode, sector_t offset, buffer_head, craete, direct)
   - 分配block?
   - 如果create==0, direct==1, 而且offset超过i_size, 返回0??
   - 锁住inode
   - 如果create ==1, 而且direct==0, 这时普通buffered的IO?
   - 使用XFS_ILOCK_EXCL 
   > xfs_ilock(xfs_inode, XFS_ILOCK_EXCL)
   - 否则,根据extent状态而定  
   > xfs_ilock_map_shared(xfs_inode)
   - 把所有的文件位置/大小转化为字节?
   - 参数sector_t 单位是inode->i_blkbits, buffer_head->b_size单位是字节
   - 然后转化为fsb, 单位是xfs_sb->sb_blocklog
   > XFS_B_TO_FSB(xfs_mount, offset)
   - fsb的位置和大小是2回事, 位置包含agno,agbno, 大小直接是以sb_blocklog为单位的数量
   - 获取xfs_bmbt_irec 
   > xfs_bmapi_read(inode, offset_fsb, end_fsb-offset_fsb, xfs_bmbt_irec, nimaps, XFS_BMAPI_ENTIRE)
   - 如果没有找到xfs_bmbt_irec, 而且create==1, 需要创建extent ?
   - xfs_bmbt_irec->br_startblock是HOLESTARTBLOCK|DELAYSTARTBLOCK
   - 如果是direct, 或者hint? 
   > xfs_get_extsz_hint(xfs_inode)
   - 然后iomap怎么了??
   > xfs_iomap_write_direct(xfs_inode, offset, size, xfs_bmbt_irec, nimaps)
   - 否则是delay分配? 
   > xfs_iomap_write_delay(xfs_inode, offset, size, xfs_bmbt_irec)
   - 如果create==0, 而且没有找到xfs_bmbt_irec?? 直接退出??
   - 然后准备新的xfs_bmbt_irec?
   - 如果xfs_bmbt_irec的磁盘位置不是hole/delay, 映射buffer_head? 
   > xfs_map_buffer(inode, buffer_head, xfs_bmbt_irec, offset)
   - 如果xfs_bmbt_irec->br_state是XFS_EXT_UNWRITTEN, 设置buffer_head 
   > set_buffer_unwritten(buffer_head)
   - 查找block_dev 
   > xfs_find_bdev_for_inode(inode)
   - 如果create ==1, 而且block是之前分配的, 设置BH_New
   - 为何没有BH_Mapped, BH_Uptodate就是新的??
   - offset超过文件大小就是新的?
   - xfs_bmbt_irec是hole,或者state==unwritten, 也是新的
   > set_buffer_new(buffer_head)
   - 如果xfs_bmbt_irec是DELAYSTARTBLOCK? 设置buffer_head 
   > set_buffer_uptodate(buffer_head)
   > set_buffer_mapped(buffer_head)
   > set_buffer_delay(buffer_head)
   - 最后要更新buffer_head->b_size ? 不能超过xfs_bmbt_irec

** xfs_get_blocks(inode, sector_t iblock, buffer_head, create)
   - buffered的io 
   > __xfs_get_blocks(inode, iblock, buffer_head, create, 0)

** xfs_get_blocks_direct(inode, sector_t iblock, buffer_head, create)
   > __xfs_get_blocks(inode, iblock, buffer_head, create, 1)

** xfs_end_io_direct_write(kiocb, loff_t offset, size, private)
   - 更新inode->i_size, 怎么在这里更新?
   > i_size_write(xfs_ioend->io_inode, offset + size)
   - 如果private !=0, 而且size>0, 设置xfs_ioend->io_type = XFS_IO_UNWRITTEN
   > xfs_finish_ioend_sync(xfs_ioend)

** xfs_vm_direct_IO(rw, kiocb, iovec, offset, nr_segs)
   - 如果rw是WRITE, 准备xfs_ioend 
   > xfs_alloc_ioend(inode, XFS_IO_DIRECT)
   - 如果写的范围超过文件大小, 设置xfs_ioend->io_isdirect =1 
   > __blockdev_direct_IO(rw, kiocb, inode, block_device, iovec, offset, nr_segs, xfs_get_blocks_direct, xfs_end_io_direct_write, NULL, 0)
   - 对于READ? 
   > __block_direct_IO(rw, kiocb, inode, block_device, iovec, offset, nr_segs, xfs_get_blocks_direct, NULL, NULL, 0)

** xfs_vm_kill_delalloc_range(inode, start, end)
   - 释放delalloc的磁盘空间?
   - 锁住inode 
   > xfs_ilock(xfs_inode, XFS_ILOCK_EXCL)
   > xfs_bmap_punch_delalloc_range(xfs_inode, start_fsb, end_fsb-offset_fsb)

** xfs_vm_write_failed(inode, page, pos, len)
   - write的错误处理函数?
   - 遍历page的buffer_header
   > xfs_vm_kill_delalloc_range(inode, block_offset, block_offset + buffer_head->b_size)

** xfs_vm_write_begin(file, address_space, pos, len, flags, page, fsdata)
   - 获取page  
   > grab_cache_page_write_begin(address_space, index, flags)
   - 准备block? 
   > __block_write_begin(page, pos, len, xfs_get_blocks)

** xfs_vm_write_end(file, address_space, loff_t pos, len, copied, page, fsdata)
   - 还是使用vfs的接口函数 
   > generic_write_end(file, address_space， pos, len, copied, page, fsdata)

** xfs_vm_bmap(address_space, sector_t block)
   - 锁住xfs_inode, XFS_IOLOCK_SHARED
   > xfs_ilock(xfs_inode, XFS_IOLOCK_SHARED)
   - flush pagecache? 
   > filemap_write_and_wait(address_space)
   - 然后映射?? 
   > generic_block_bmap(address_space, block, xfs_get_blocks)

** xfs_vm_readpage(file, page)
   > mpage_readpage(page, xfs_get_blocks)

** xfs_vm_readpages(file, address_space, list_head, nr_pages)
   - 都使用vfs接口
   > mpage_readpages(address_space, list_head, nr_pages, xfs_get_blocks)

* xfs_iomap.c

** xfs_iomap_eof_align_last_fsb(xfs_mount, xfs_inode, xfs_extlen_t extsize, xfs_fileoff_t last_fsb)
   - 处理文件的eof? last_fsb
   - 首先使用xfs_mount->swidth或xfs_mount->d_dalign对齐
   - 如果eof超过align 
   > XFS_ISIZE(xfs_inode)
   - 然后对齐extsize?? 
   - 修改什么? 
   > xfs_bmap_eof(xfs_inode, new_last_fsb, XFS_DATA_FORK, eof)
  
** xfs_alert_fsblock_zero(xfs_inode, xfs_bmbmt_irec)
   - 调式信息, 输出xfs_bmbt_irec的信息  

** xfs_bmap_free_item 
   #+BEGIN_SRC 
	xfs_fsblock_t		xbfi_startblock;/* starting fs block number */
	xfs_extlen_t		xbfi_blockcount;/* number of blocks in extent */
	struct xfs_bmap_free_item *xbfi_next;	/* link to next entry */   
   #+END_SRC

** xfs_bmap_free
   #+BEGIN_SRC 
	xfs_bmap_free_item_t	*xbf_first;	/* list of to-be-free extents */
	int			xbf_count;	/* count of items on list */
	int			xbf_low;	/* alloc in low mode */   
   #+END_SRC

** xfs_iomap_write_direct(xfs_inode, xfs_off_t offset, size_t count, xfs_bmbt_irec, nmaps)
   - 要写的数据是(offset, count), 如果超过eof, 校正eof? 
   - 获取hint extent size 
   > xfs_get_extsz_hint(xfs_inode)
   - offset + count > XFS_ISIZE(xfs_inode)
   > xfs_iomap_eof_align_last_fsb(xfs_mount, xfs_inode, extsz, last_fsb)
   - 如果对应的xfs_bmbt_irec表示范围是hole, 限制操作范围
   - 校正文件范围,起始位置和长度都要对extsz对齐
   - 创建xfs_trans 
   > xfs_trans_alloc(xfs_mount, XFS_TRANS_DIOSTRAT)
   - 预留空间 
   > xfs_trans_reserve(xfs_trans, resblks, XFS_WRITE_LOG_RES(xfs_mount), resrtextents, XFS_TRANS_PERM_LOG_RES, XFS_WRITE_LOG_COUNT)
   - 锁住inode ? 
   > xfs_ilock(xfs_inode, XFS_ILOCK_EXCL)
   > xfs_trans_ijoin(xfs_trans, xfs_inode, 0)
   - 初始化xfs_bmap_free? 
   > xfs_bmap_init(xfs_bmap_free, firstfsb)
   - 获取xfs_bmbt_irec?? 
   > xfs_bmapi_write(xfs_trans, xfs_inode, offset_fsb, count_fsb, bmapi_flags, firstfsb, 0, xfs_bmbt_irec, nimaps, free_list)
   - 结束transaction 
   > xfs_trans_commit(xfs_trans, XFS_TRANS_RELEASE_LOG_RES)

** xfs_iomap_eof_want_preallocate(xfs_mount, xfs_inode, xfs_off_t offset, size_t count, xfs_bmbt_irec, nimaps, prealloc)
   - 在写操作增加eof时,检查是否能预分配空间? 设置结果给prealloc?
   - 如果写的范围没有超过eof, 直接返回
   - 如果offset + count <= XFS_ISIZE(xfs_inode)
   - 如果prealloc有限制, xfs_mount使用XFS_MOUNT_DFLT_IOSIZE
   - 如果文件太小, 小于xfs_mount->m_writeio_blocks, 直接返回0
   - 读取文件的extent, 检查是否已经有空间? 
   - 在offset+count之后的
   > xfs_bmapi_read(xfs_inode, start_fsb, count_fsb, xfs_bmbt_irec, imaps, 0)
   - 遍历读取的xfs_bmbt_irec, 如果xfs_bmbt_irec->br_startblock不是HOLDSTARTBLOCK/DELAYSTARTBLOCK,直接返回
   - 如果xfs_bmbt_irec->br_startblock是DELAYSTARTBLOCK, 找到delalloc?
   - 只有找不到xfs_bmbt_irec, 或者找到的都是HOLDSTARTBLOCK, 才能设置prealloc=1

** xfs_iomap_eof_prealloc_initial_size(xfs_mount, xfs_inode, xfs_off_t offset, xfs_bmbt_irec, nimaps)
   - 计算与分配的空间?
   - 如果xfs_mount->m_flags有XFS_MOUNT_DFLT_IOSIZE, 使用特定的大小
   - 如果文件太小, 不超过xfs_mount->m_dalign, 使用默认的
   - 查找xfs_bmbt_irec 
   > xfs_bmapi_read(xfs_inode, start_fsb, 1, xfs_bmbt_irec, imaps, XFS_BMAPI_ENTIRE)
   - 如果xfs_bmbt_irec->br_startblock是HOLDSTARTBLOCK, 返回0? 使用默认的?
   - 如果xfs_bmbt_irec->br_blockcount <= MAXEXTLEN/2, 返回xfs_bmbt_irec->br_blockcount * 2 ??
   - 否则返回offset???

** xfs_quota_calc_throttle(xfs_inode, type, xfs_fsblock_t, qshift)

** xfs_iomap_prealloc_size(xfs_mount, xfs_inode, xfs_off_t, xfs_bmbt_irec, nimaps)
   - 首先检查是否使用变化的prealloc size 
   > xfs_iomap_eof_prealloc_initial_size(xfs_mount, xfs_inode, offset, xfs_bmbt_irec, nimaps)
   - 如果返回0, 使用固定的大小
   - 否则使用上面返回的alloc_blocks,计算适当的值
   - 检查文件系统的剩余空间, 如果越少,越少分配 
   - xfs_sb->sb_fdblocks, 标准是xfs_mount->m_low_space[5]
   - 根据上面的条件,缩小alloc_blocks
   - 同时它还不能超过文件系统剩余空间, 否则需要缩小4倍,16倍..
   - 最后默认的,也是最小的是xfs_mount->m_writeio_blocks

** xfs_iomap_write_delay(xfs_inode, xfs_off_t, size_t, xfs_bmbt_irec)
   - 首先获取extent hint? 
   > xfs_get_extsz_hint(xfs_inode)
   - 校正eof ? 
   > xfs_iomap_eof_want_preallocate(xfs_mount, xfs_inode, offset, count, xfs_bmbt_irec, XFS_WRITE_IMAPS, prealloc)
   - 如果需要预分配? 检查与分配的空间?? 
   > xfs_iomap_prealloc_size(xfs_mount, xfs_inode, offset, xfs_bmbt_irec, XFS_WRITE_IMAPS)
   - 然后构造extent? 
   > xfs_bmapi_delay(xfs_inode, offset_fsb, last_fsb-offset_fsb, xfs_bmbt_irec, nimaps, XFS_BMAPI_ENTIRE)
   - 最后设置xfs_inode标志? 
   > xfs_inode_set_eofblocks_tag(xfs_inode)

** xfs_iomap_write_allocate(xfs_inode, xfs_off_t, size_t, xfs_bmbt_irec)
   - 把delayed的extent,转化为已经使用的extent?
   - 首先准备xfs_trans 
   > xfs_trans_alloc(xfs_mount, XFS_TRNS_STRAT_WRITE)
   - 预留空间?? 
   > xfs_trans_reserve(xfs_trans, nres, XFS_WRITE_LOG_RES(xfs_mount), 0, XFS_TRANS_PERM_LOG_RES, XFS_WRITE_LOG_COUNT)
   - 为何要锁住xfs_inode, 才能设置trans? 
   > xfs_trans_ijoin(xfs_trans, xfs_inode, 0)
   - 初始化xfs_bmap_free? 
   > xfs_bmap_init(xfs_bmap_free, first_block)
   - 计算last_block?? 
   > xfs_bmap_last_offset(NULL, xfs_inode, last_block, XFS_DATA_FORK)
   - 修改extent数据?
   > xfs_bmapi_write(xfs_trans, xfs_inode, map_start_fsb, count_fsb, XFS_BMAPI_STACK_SWITCH, first_block, 1, xfs_bmbt_irec, nimaps, xfs_bmap_free)
   - 结束transaction
   > xfs_bmap_finish(xfs_trans, xfs_bmap_free, committed)
   - 提交transaction 
   > xfs_trans_commit(xfs_trans, XFS_TRANS_RELEASE_LOG_RES)
   - 需要循环处理, 直到(offset, count)范围内的extent都处理掉

** xfs_iomap_write_unwritten(xfs_inode, xfs_off_t offset, size_t count)
   - 和上面很想,循环处理(offset, count)内的xfs_bmbt_irec
   > _xfs_trans_alloc(xfs_mount, XFS_TRANS_STRAT_WRITE, KM_NOFS)
   > xfs_trans_reserve(xfs_trans, resblks, XFS_WRITE_LOG_RES(xfs_mount), 0, XFS_TRANS_PERM_LOG_RES, XFS_WRITE_LOG_COUNT)
   > xfs_bmapi_init(xfs_bmap_free, firstfsb)
   > xfs_bmapi_write(xfs_trans, xfs_inode, offset_fsb, count_fsb, XFS_BMAPI_CONVERT, firstfsb, ..)
   - 如果改变文件大小 
   > xfs_new_eof(xfs_inode, i_size)
   - 需要使用trans改变xfs_dinode 
   > xfs_trans_log_inode(xfs_trans, xfs_inode, XFS_ILOG_CORE)

* xfs_bmap.c 
  - bmap tree

** xfs_bmdr_block 
   - 这是数据节点使用的,后面是(key,value)点对
   - 这个在xfs_dinode的fork中
   #+BEGIN_SRC 
	__be16		bb_level;	/* 0 is a leaf */
	__be16		bb_numrecs;	/* current # of data records */   
   #+END_SRC

** xfs_btree_block 
   - 每个btree节点使用的block使用的数据结构
   #+BEGIN_SRC 
	__be32		bb_magic;	/* magic number for block type */
	__be16		bb_level;	/* 0 is a leaf */
	__be16		bb_numrecs;	/* current # of data records */

	__be64		bb_leftsib;
	__be64		bb_rightsib;

	__be64		bb_blkno;
	__be64		bb_lsn;
	uuid_t		bb_uuid;
	__be64		bb_owner;
	__le32		bb_crc;
	__be32		bb_pad; /* padding for alignment */
   
   #+END_SRC

** xfs_bmbt_key 
   - btree中节点使用的key, 分支指针使用磁盘块指针 
   - xfs_bmbt_ptr_t, xfs_bmdr_ptr_t

   #+BEGIN_SRC 
	__be64		br_startoff;	/* starting file offset */   
   #+END_SRC


** xfs_bmap_compute_maxlevels(xfs_mount, whichfork)
   - 计算btree高度的最大值, 首先计算可能的叶子节点的最大值
   - 对于data fork, 记录项最多是MAXEXTNUM, signed int
   - 对于attr fork, 记录项最多MAXAEXTNUM, signed short
   - 叶子节点或内部节点的最小分支是xfs_mount->m_bmap_dmnr[2]
   - 然后计算btree是最小分支时的高度
   - 最后一个节点必须比跟节点小
   - maxrootrecs = xfs_bmdr_maxrecs(xfs_mount, sz, 0)
   - (sz-sizeof(xfs_bmdr_block_t) / (sizeof(xfs_bmdr_key_t) + sizeof(xfs_bmdr_ptr_t))
   - sz表示data fork或attr fork的最小空间
   > XFS_BMDR_SPACE_CALC(MINDBPTRS) / MINADBPTRS
   - 为何不直接使用这2个宏??

** xfs_fsb_to_db(xfs_inode, xfs_fsblock_t)
   - 把fsb指针转化为磁盘绝对地址
   > XFS_FSB_TO_DADDR(xfs_mount, fsb)
   - 它先分解成agno, agbno, 然后对ag的起始地址做偏移
   > XFS_AGB_TO_ADDR(XFS_FSB_TO_AGNO(xfs_mount, fsbno), XFS_FSB_TO_AGBNO(xfs_mount, fsbno)
   - fsb指针单位是fsb, xfs_mount->m_blkbb_log

** xfs_bmbt_lookup_eq(xfs_btree_cur, xfs_fileoff_t off, xfs_fsblock_t bno, xfs_filblks_t len, stat)
   - btree查找可以精确到记录? 还是到叶子节点?
   - 设置xfs_btree_cur->xfs_bmbt_irec的startoff/startblock/blockcount
   - 为何要都设置? 查找是否存在对应的xfs_bmbt_irec? 
   > xfs_btree_lookup(xfs_btree_cur, XFS_LOOKUP_EQ, stat)
  
** xfs_bmbmt_lookup_ge(xfs_btree_cur, xfs_fileoff_t, xfs_fsblock_t, xfs_filblks_t, stat)
   - 设置xfs_btree_cur, 查找btree 
   > xfs_btree_lookup(xfs_btree_cur, XFS_LOOKUP_GE, stat)

** xfs_bmap_needs_btree(xfs_inode, whichfork)
   - 当前是extent数组,才能转化成btree
   - 检查xfs_icdinode->di_format/di_aformat, XFS_IFORK_FORMAT(xfs_inode, whichfork) == XFS_DINODE_FMT_EXTENTS
   - 而且extent数量超过限制 
   > XFS_IFORK_NEXTENTS(xfs_inode, whichfork)
   > XFS_IFORK_MAXEXT(xfs_inode, whichfork)

** xfs_bmap_wants_extents(xfs_inode, whichfork)
   - 当前使用btree存储数据,转为extent
   - 当前xfs_icdinode->di_format/di_aformat使用XFS_DINODE_FMT_BTREE
   > XFS_IFORK_FORMAT(xfs_inode, whichfork)
   - 而且extent低于限制 
   > XFS_IFORK_MAXEXT(xfs_inode, whichfork)

** xfs_bmbt_update(xfs_btree_cur, xfs_fileoff_t, xfs_fsblock_t, xfs_filblks_t, xfs_exntst_t)
   - 使用xfs_btree_cur转移数据
   > xfs_bmbt_disk_set_allf(xfs_bmbt_cur->xfs_bmbt_irec, off, bno, len, state)
   - 写给btree 
   > xfs_btree_update(xfs_btree_cur, xfs_btree_rec)
   - xfs_bmbt_irec中数据单位应该都是fsb

** xfs_bmap_worst_indlen(xfs_inode, xfs_filblks_t len)
   - len是什么长度?
   - 计算最坏情况下btree节点使用的block的个数?
   - len / xfs_mount->m_bmap_dmxr[0] ?? 

** xfs_default_attroffset(xfs_inode)
   - 计算xfs_dinode中attr fock的默认开始位置
   - 如果xfs_sb->sb_inodesize == 256, 只会留下2个节点的btree根结点使用的空间
   > XFS_LITINO(xfs_mount, xfs_icdinode->di_version) - XFS_BMDR_SPACE_CALC(MINABTPTRS)
   - 否则偏移为包含MINABTPTRS*6个记录的根结点的空间,给data fork使用
   > XFS_BMDR_SPACE_CALC( 6 * MINABTPTRS)

** xfs_bmap_forkoff_reset(xfs_mount, xfs_inode, whichfork)
   - 如果参数whichfork是XFS_ATTR_FORK
   - 而且data fork使用XFS_DINODE_FMT_EXTENTS/XFS_DINODE_FMT_LOCAL
   - 重新计算attr fork的空间 dfl_forkoff
   > xfs_default_attroffset(xfs_inode) 
   - 只有偏移扩大时才设置
   - xfs_inode->icdinode->di_forkoff = dfl_forkoff / 8 

** xfs_bmap_count_leaves(xfs_ifork, xfs_extnum_t idx, numrecs, count)
   - 统计xfs_ifork中(idx, numrecs)范围内的xfs_bmbt_rec_host, 影射的磁盘总量
   - 获取这些xfs_bmbt_rec_host 
   > xfs_iext_get_ext(xfs_ifork, idx)
   - 只抽取blockcount
   > xfs_bmbt_get_blockcount(xfs_bmbt_rec_host)
   - 这些xfs_bmbt_rec_host管理分配的磁盘空间??

** xfs_bmap_disk_count_leaves(xfs_mount, xfs_btree_block, numrecs, count)
   - xfs_btree_block指向一个叶子节点
   - 取出这个叶子节点的(numrecs, count)范围内的xfs_bmbt_rec
   > XFS_BMBT_REC_ADDR(xfs_mount, xfs_btree_block, idx)
   - 叶子节点xfs_btree_block后面就是xfs_btree_block数组
   - 累加blockcount 
   > xfs_bmbt_disk_get_blockcount(xfs_btree_block)

** xfs_bmap_count_tree(xfs_mount, xfs_trans, xfs_ifork, xfs_fsblock_t blockno, levelin, count)
   - 这个函数用来统计xfs_ifork占用的磁盘空间,不仅包括btree
   - 还有数据叶子节点影射的空间
   - bno指向的block是btree的节点
   > xfs_btree_read_bufl(xfs_mount, xfs_trans, bno, 0, xfs_buf, XFS_BMAP_BTREE_REF, xfs_bmbt_buf_ops)
   - 从xfs_buf中获取xfs_btree_block 
   > XFS_BUF_TO_BLOCK(xfs_trans)
   - level表示父节点的高度
   - 如果level >1, 这是内部节点
   - 使用xfs_btree_block->bb_u->l->bb_rightsib遍历这一层的所有节点
   > xfs_btree_read_bufl(xfs_mount, xfs_trans, nextbno, 0, xfs_buf, XFS_BMAP_BTREE_REF, xfs_bmbt_buf_ops)
   - 这里不会使用xfs_buf, 立刻释放
   > xfs_trans_brelse(xfs_trans, xfs_buf)
   - 这种遍历只是统计内部节点的个数
   - 然后处理下一层,获得第一个ptr的值, bno
   > XFS_BMBT_PTR_ADDR(xfs_mount, block, 1, xfs_mount->m_bmap_dmxr[1])
   - key和ptr是严格分开的,最大的分支数已经确定
   - 统计下一层节点个数和叶子节点影射的磁盘数量
   - xfs_bmap_count_tree(xfs_mount, xfs_trans, xfs_ifork, bno, level, count)
   - 如果level ==1, 当前节点是叶子节点
   - 还是根据xfs_btree_block->bb_u->l->bb_rightsib遍历最下层的节点
   - 针对每个节点分支, 统计影射的磁盘的总量 
   > xfs_bmap_disk_count_leaves(xfs_mount, xfs_btree_block, numrecs, count)
   - 使用count传递总数,这里还得添加叶子节点的1
   - 然后读取下一个兄弟节点 
   > xfs_btree_read_bufl(xfs_mount, xfs_trans, bno, 0, xfs_buf, XFS_BMAP_BTREE_REF, xfs_bmbt_buf_ops)
   > XFS_BUF_TO_BLOCK(xfs_buf)

** xfs_bmap_sanity_check(xfs_mount, xfs_buf)
   - xfs_buf里面是xfs_btree_block
   - 检查magic, level
   - numrecs !=0, 也不超过最大分支xfs_mount->m_bmap_dmxr[level!=0]

** xfs_bmap_get_bp(xfs_btree_cur, xfs_fsblock_t bno)
   - 查找xfs_btree_cur中和bno对应的xfs_buf?
   - 首先查找xfs_btree_cur->bc_bufs, 它应该是是从跟到叶子节点的路径
   - 然后遍历xfs_btree_cur->bc_tmp->t_items
   - 查找里面的xsf_buf_log_item 
   > XFS_BUF_ADDR(xfs_buf)

** xfs_check_block(xfs_btree_block, xfs_mount, root, sz)
   - xfs_btree_block是btree的内部节点
   - 检查key是否是有序的
   - 检查ptr是否有重复的
   - 如果不满足,说明文件系统崩溃.. 
   - xfs_btree_block可能是根节点,在fork数据中
   > XFS_BMBT_KEY_ADDR(xfs_mount, xfs_btree_block, i)
   > XFS_BMAP_BROOT_PTR_ADDR(xfs_mount, xfs_btree_block, i, sz)
   > XFS_BMAP_PTR_ADDR(xfs_mount, xfs_btree_block, i, dmxr)
   - (key,value)的点对数 
   > xfs_btree_get_numrecs(xfs_btree_block)

** xfs_bmap_check_leaf_extents(xfs_btree_cur, xfs_inode, whichfork)
   - 检查xfs_btree_cur中btree节点的数据有效性
   - xfs_ifork使用XFS_DINODE_FMT_BTREE, attr fork操作都是用这些?
   - 获取xfs_ifork中的跟节点xfs_btree_block, xfs_ifork->if_broot
   - 这里xfs_btree_block的数据结构是带大端的
   - 检查根结点的成员, level,key,value
   > xfs_check_block(xfs_btree_block, xfs_mount, 1, xfs_ifork->if_broot_bytes)xo
   - 然后检查btree的叶子节点的数据有效性
   -这里没有全部遍历内部节点
   - 首先找到第一个叶子节点,使用内部节点的第一个分支
   - 先取出xfs_buf
   > xfs_bmap_get_bp(xfs_btree_cur, XFS_FSB_TO_DADDR(xfs_mount, bno))
   > xfs_btree_read_bufl(xfs_mount, NULL, bno, 0, xfs_buf, XFS_BMAP_BTREE_REF, xfs_bmbt_buf_ops)
   - 获取xfs_btree_block 
   > XFS_BUF_TO_BLOCK(xfs_buf)
   - 检查成员的有效性 
   > xfs_check_block(xfs_btree_block, xfs_mount, 0, 0)
   - 获取第一个分支的value 
   > XFS_BMBT_PTR_ADDR（xfs_mount, xfs_btree_block, 1, xfs_mount->m_bmap_dmxr[1])
   - 如果level不是0, 需要继续查找
   - 找到第一个叶子节点,使用xfs_btree_block->bb_u->l->bb_rightsib遍历所有的叶子节点
   - 对于每个叶子节点,检查它成员的有效性
   > XFS_BMBT_REC_ADDR(xfs_mount, xfs_btree_block, j)
   - 检查xfs_bmbt_rec, 他也是大端定义的
   - 他们指向的文件范围不能交叉
   > xfs_bmbt_disk_get_startoff(xfs_bmbt_rec)
   > xfs_bmbt_disk_get_blockcount(xfs_bmbt_rec)
   - 相邻2个叶子节点也必须比较

** xfs_bmap_trace_extlist(xfs_inode, xfs_extnum_t, whichfork, caller_ip)
   - bmap trace insert entry??

** xfs_bmap_validate_ret(xfs_fileoff_t bno, xfs_filblks_t len, flags, xfs_bmbt_irec, nmap, ret_nmap)
   - 检查xfs_bmbt_irec数组, 哪里获取的?
   - xfs_bmbt_irec->br_blockcount >0, 它表示范围
   - 如果flags有XFS_BMAPI_ENTIRE,(br_startoff,br_blockcount)必须在(bno,len)范围内
   - 否则两个范围必须交叉
   - 而且相邻2个xfs_bmbt_irec不能交叉
   - br_startblock不能是DELAYSTARTBLOCK和HOLESTARTBLOCK

** xfs_bmap_add_free(xfs_fsblock_t bno, xfs_filblks_t len, xfs_bmap_free_t flist, xfs_mount)
   - 构造xfs_bmap_free_item, 记录(bno, len)
   - 把它放到参数xfs_bmap_free->xbf_first的链表中
   - 里面节点按照xfs_bmap_free_item->xbfi_startblock排序

** xfs_bmap_del_free(xfs_bmap_free, xfs_bmap_free_item prev, xfs_bmap_free_item)
   - free是xfs_bmap_free->xbf_first链表上的节点, 删除free
   - 减小xfs_bmap_free->xbf_count 

** xfs_bmap_finish(xfs_trans, xfs_bmap_free, committed)
   - 释放xfs_bmap_free中的所有extent?
   - xfs_trans->t_flags必须有XFS_TRANS_PERM_LOG_RES
   - 构造xfs_efi_log_item, 用来free extent
   > xfs_trans_get_efi(xfs_trans, nextents)
   - 遍历xfs_bmap_free的xfs_bmap_free_list, 填充到xfs_extent
   > xfs_trans_log_efi_extent(xfs_trans, xfs_efi_log_item, xfs_fsblock_t, xfs_extlen_t)
   - 设置xfs_trans->t_flags的XFS_TRANS_DIRTY
   - xfs_log_item->xfs_log_item_desc->lid_flags的XFS_LID_DIRTY
   - 为何要复制xfs_trans 
   > xfs_trans_dup(xfs_trans)
   - 又在提交? 
   > xfs_trans_commit(xfs_trans, 0)
   - 什么是xlog_ticket ?? 
   > xfs_log_ticket_put(xfs_trans->t_ticket)
   - 预留空间
   > xfs_trans_reserve(xfs_trans, 0, logres, 0, XFS_TRANS_PERM_LOG_RES, logcount)
   - 为xfs_trans创建xfs_efd_log_item, extent free done
   > xfs_trans_get_efd(xfs_trans, xfs_efi_log_item, xfs_bmap_free->xbf_count)
   - 然后遍历xfs_bmap_free->xbf_first的xfs_bmap_free_item, 释放空间
   > xfs_free_extent(xfs_trans, xfs_bmap_free_item->xbfi_startblock, xbfi_blockcount)
   - 记录xfs_efd_log_item
   > xfs_trans_log_efd_extent(xfs_trans, xfs_efd_log_item, xbfi_startblock, xbfi_blockcount)
   - 释放xfs_bmap_free_item 
   > xfs_bmap_del_free(xfs_bmap_free, NULL, xfs_bmap_free_item)
   - 在xfs_bmap_free_item/xfs_extent里面都是磁盘位置

** xfs_bmap_cancel(xfs_bmap_free)
   - 直接释放xfs_bmap_free的xfs_bmap_free_item节点

** xfs_bmap_btree_to_extents(xfs_trans, xfs_inode, xfs_btree_cur, logflags, whichfork)
   - 把fork数据从btree改为extents, 把extents队列放到xfs_dinode中
   - 在xfs_icdinode中,extents已经是数组格式?
   - 检查当前的数据
   > XFS_IFORK(xfs_inode, whichfork)
   - 现在xfs_ifork->if_flags有XFS_IFEXTENTS?
   - xfs_icdinode->di_format是XFS_DINODE_FMT_BTREE 
   > XFS_IFORK_FORMAT(xfs_inode, whichfork)
   - 获取xfs_ifork中的跟节点xfs_btree_block, xfs_ifork->if_broot
   - xfs_btree_block->bb_level ==1
   - xfs_btree_block->bb_numrecs ==1
   - xfs_bmbt_maxrecs(xfs_mount, xfs_ifork->if_broot_bytes, 0) ==1
   - 只有一个分支,一个叶子节点, 但bb_numrecs和if_broot_bytes有什么区别??
   - 读出这个叶子节点
   > XFS_BMAP_BROOT_PTR_ADDR(xfs_mount, xfs_broot_block, 1, xfs_ifork->if_broot_bytes)
   > xfs_btree_read_bufl(xfs_mount, xfs_trans, cbno, XFS_BMAP_BTREE_REF, xfs_bmbt_buf_ops)
   - 检查获取的xfs_bmbt_block 
   > XFS_BUF_TO_BLOCK(xfs_buf)
   - 上面的xfs_btree_cur为何没有直接找到叶子节点?
   > xfs_btree_check_block(xfs_btree_cur, xfs_btree_block, 0, xfs_buf)
   - 释放叶子节点使用的block
   > xfs_bmap_add_free(cbno, 1, xfs_btree_cur->bc_private->xfs_bmap_free, xfs_mount)
   - 减小xfs_inode->xfs_icdinode->di_nblocks
   - 为何无效transaction? log xfs_buf?
   > xfs_trans_binval(xfs_trans, xfs_buf)
   - 更新xfs_ifork的broot
   > xfs_iroot_realloc(xfs_inode, -1, whichfork)
   - 更正xfs_btree_cur->bc_bufs[0] ???
   - 检查xfs_ifork->if_broot == NULL
   - 而且xfs_ifork->if_flags没有XFS_IFBROOT
   - 设置xfs_inode->xfs_icdinode->di_format
   > XFS_IFORK_FMT_SET(xfs_inode, whichfork, XFS_DINODE_FMT_EXTENTS)
   - 最后设置参数logflags = XFS_ILOG_CORE|xfs_ilog_fext(whichfork)
   - 这里怎么没有xfs_log_item??

** xfs_bmap_extents_to_btree(xfs_trans, xfs_inode, xfs_fsblock_t firstblock, xfs_bmap_free, xfs_btree_cur, wasdel, logflags, whichfork)
   - 把磁盘的extents格式转化为btree格式
   - 检查当前xfs_ifork 
   > XFS_IFORK_PTR(xfs_inode, whichfork)
   - xfs_icdinode->di_format是XFS_DINODE_FMT_EXTENTS
   > XFS_IFORK_FORMAT(xfs_inode, whichfork) == XFS_DINODE_FMT_EXTENTS
   - 重新分配xfs_ifork的btree 
   > xfs_iroot_realloc(xfs_inode, 1, whichfork)
   - 设置xfs_ifork->if_flags的XFS_IFBROOT, 怎么不在分配时设置?
   - 填充xfs_ifork->xfs_btree_block 
   > xfs_btree_init_block_int(xfs_mount, xfs_btree_block, XFS_BUF_DADDR_NULL, XFS_BMAP_CRC_MAGIC, 1,1, xfs_inode->i_ino, XFS_BTREE_LONG_PTR|XFS_BTREE_CRC_BLOCKS)
   - 准备xfs_btree_cur 
   > xfs_bmbt_init_cursor(xfs_mount, xfs_trans, xfs_inode, whichfork)
   - 设置xfs_btree_cur->pc_private->b, 什么东西?
   - 设置di_format 
   > XFS_IFORK_FMT_SET(xfs_inode, whichfork, XFS_DINODE_FMT_BTREE)
   - 准备xfs_alloc_args, 准备分配block
   - 设置xfs_alloc_args->fsbno = firstblock
   - 如果firstblock == NULLFSBLOCK, 使用inode的位置
   > XFS_INO_TO_FSB(xfs_mount, xfs_inode->i_ino)
   - 当然xfs_alloc_args->type也不一样
   > xfs_alloc_vextent(xfs_alloc_args)
   - 分配不能失败? 因为已经reserve空间
   - 把xfs_alloc_args->fsbno给xfs_btree_cur->bc_private->b_firstblock?
   - 增加xfs_btree_cur->bc_private->b_allocated
   - 增加xfs_icdinode->di_nblocks
   - 准备一个xfs_buf, 会读上来吗??
   > xfs_btree_get_bufl(xfs_mount, xfs_trans, xfs_alloc_args->fsbno, 0)
   - 初始化xfs_buf, 写上头xfs_btree_block 
   > xfs_btree_init_block_int(xfs_mount, xfs_btree_block, xfs_buf->b_bn, XFS_BMAP_CRC_MAGIC, 0, 0, xfs_inode->i_ino, XFS_BTREE_LONG_PTR|XFS_BTREE_CRC_BLOCKS)
   - 然后把xfs_ifork中的xfs_bmbt_rec_host写到xfs_btree_block中
   > xfs_iext_get_ext(xfs_ifork, i)
   - 跳过nullblock, 不写hole? 
   > isnullstartblock(xfs_bmbt_get_startblock(xfs_bmbt_rec_host))
   - 在xfs_ifork的extent矩阵中的格式是没有大短的,但写道xfs_buf中时,转化为大端 
   - 比较xfs_ifork中的extent数量,需要和xfs_icdinode->di_nextents相同 
   > XFS_IFORK_NEXTENTS(xfs_inode, whichfork)
   - 设置xfs_btree_block->bb_numrecs
   > xfs_btree_set_numrecs(xfs_btree_block, cnt)
   - 然后设置btree根结点
   > XFS_BMBT_KEY_ADDR(xfs_mount, xfs_btree_block, 1)
   - 第一个分支的key就是叶子节点第一个xfs_bmbt_rec的startoff
   - 第一个xfs_bmbt_rec
   > XFS_BMBT_REC_ADDR(xfs_mount, xfs_btree_block, 1)
   > xfs_bmbt_disk_get_startoff(xfs_bmbt_rec)
   - 设置第一个分支的value
   > XFS_BMBT_PTR_ADDR(xfs_mount, xfs_btree_block, 1, xfs_bmbt_get_maxrecs(xfs_btree_cur, level))
   - value就是xfs_alloc_args->fsbno
   - 然后log叶子节点的改动
   - 首先是xfs_btree_block
   > xfs_btree_log_block(xfs_btree_cur, xfs_btree_block, XFS_BB_ALL_BITS)
   - 然后是xfs_bmbt_rec 
   > xfs_btree_log_recs(xfs_btree_cur, xfs_btree_block, 1, xfs_btree_block->bb_numrecs)
   - 最后设置logflags
   - XFS_ILOG_CORE|xfs_ilog_fbroot(whichfork)

** xfs_bmap_local_to_extents_empty(xfs_inode, whichfork)
   - 把磁盘格式从local改为extents??
   - 现在xfs_icdinode->di_format是XFS_DINODE_FMT_LOCAL
   > XFS_IFORK_FORMAT(xfs_inode, whichfork)
   - 而且现在xfs_ifork->if_bytes ==0, extent数量是0 
   > XFS_IFORK_NEXTENTS(xfs_inode, whichfork)
   - 重新设置forkoff? 
   > xfs_bmap_forkoff_reset(xfs_mount, xfs_inode, whichfork)
   - 去掉xfs_ifork->if_flags的XFS_IFINLINE, 设置XFS_IFEXTENTS 
   - 还有di_format的XFS_DINODE_FMT_EXTENTS 
   > XFS_IFORK_FMT_SET(xfs_inode, whichfork, XFS_DINODE_FMT_EXTENTS)

** xfs_bmap_local_to_extents(xfs_trans, xfs_inode, xfs_fsblock_t, xfs_extlen_t, logflag, whichfork, init_fn)
   - xfs_inode不是reg文件,而且whichfork必须是XFS_DATA_FORK?
   - 获取xfs_ifork 
   > XFS_IFORK_PTR(xfs_inode, whichfork)
   - 而且磁盘格式是XFS_DINODE_FMT_LOCAL 
   > XFS_IFORK_FORMAT(xfs_inode, whichfork)
   - 如果xfs_ifork->if_bytes是0, 现在还没有extent数据 
   > xfs_bmap_local_to_extents_empty(xfs_inode, whichfork)
   - 否则分配空间?
   - 现在xfs_ifork的格式应该是XFS_IFINLINE
   - 准备xfs_alloc_args, 分配空间 
   - xfs_alloc_args->minlen, maxlen, prod是1
   > xfs_alloc_vextent(xfs_alloc_args)
   - 读取对应的block 
   > xfs_btree_get_bufl(xfs_alloc_args->xfs_mount, xfs_trans, xfs_alloc_args->fsbno, 0)
   - 初始化xfs_buf, 而且把fork数据给xfs_buf
   - 不确定里面是什么，只能说是fork数据
   > init_fn(xfs_trans, xfs_buf, xfs_inode, xfs_ifork)
   - 然后记录log? 
   > xfs_trans_log_buf(xfs_trans, xfs_buf, 0, xfs_ifork->if_bytes -1 )
   - 释放xfs_ifork的内存空间, fork数据已经到extent索引的block中
   > xfs_idata_realloc(xfs_inode, -xfs_ifork->if_bytes, whichfork)
   - 只是重新设置forkoff
   > xfs_bmap_local_to_extents_empty(xfs_inode, whichfork)
   - 增加extent? 
   - 原来xfs_ifork中是local数据，现在添加一个xfs_bmbt_rec_host索引上面创建的xfs_buf
   > xfs_iext_add(xfs_ifork, 0, 1)
   - 获取这个xfs_bmbt_rec_host
   > xfs_iext_get_ext(xfs_ifork, 0)
   - 填充对应的位置信息
   > xfs_bmbt_set_allf(xfs_bmbt_rec_host, 0, xfs_alloc_args->fsbno, 1, XFS_EXT_NORM)
   - 设置fork使用的extent数量为1
   > XFS_IFORK_NEXT_SET(xfs_inode, whichfork, 1)
   - xfs_inode->xfs_icdinode->di_nblocks = 1
   - logflags, 添加对应的log标志 XFS_ILOG_DEXT
   > xfs_ilog_fext(whichfork)

** xfs_bmap_add_attrfork_btree(xfs_trans, xfs_inode, xfs_fsblock_t, xfs_bmap_free, flags)
   - 设置data fork?
   - 如果xfs_inode->xfs_ifork->if_broot_bytes <= XFS_IFORK_DSIZE(xfs_inode)
   - 只需要设置flags的XFS_ILOG_DBROOT???
   - 否则先去磁盘查找  
   - 准备xfs_btree_cur 
   > xfs_bmbt_init_cursor(xfs_mount, xfs_trans, xfs_inode, XFS_DATA_FORK)
   - 设置xfs_btree_cur->bc_private->b->xfs_bmap_free, firstblock为参数xfs_fsblock_t
   - 查找第一个叶子节点??
   > xfs_bmbt_lookup_ge(xfs_btree_cur, 0, 0, 0, stat)
   - 创建新的root? 
   > xfs_btree_new_iroot(xfs_btree_cur, flags, stat)
   - 更新参数xfs_fsblock_t为xfs_btree_cur->bc_private->b->firstblock

** xfs_bmap_add_attrfork_extents(xfs_trans, xfs_inode, xfs_fsblock_t firstblock, xfs_bmap_free, flags)
   - 处理data fork?
   - 如果xfs_bmbt_rec_host数据占的空间没有超过限制, 直接返回
   > xfs_inode->xfs_ifork->di_nextents * sizeof(xfs_bmbt_rec) <= XFS_IFORK_DSIZE(xfs_inode)
   - 否则需要转化为XFS_DINODE_FMT_BTREE 
   > xfs_bmap_extents_to_btree(xfs_trans, xfs_inode, firstblock, xfs_bmap_free, xfs_btree_cur, 0, flags, XFS_DATA_FORK)
   - 如果上面有xfs_btree_cur,还要释放它??
   - 设置xfs_btree_cur->bc_private->b->allocated = 0
   > xfs_btree_del_cursor(xfs_btree_cur, XFS_BTREE_NOERROR)

** xfs_bmap_add_attrfork_local(xfs_trans, xfs_inode, xfs_fsblock_t, xfs_bmap_free_t, flags)
   - 如果fork数据不够多,不需要转化?  xfs_inode->xfs_ifork->if_bytes 
   > XFS_IFORK_DSIZE(xfs_inode)
   - 如果是dir文件,使用xfs_da_args实现 
   > xfs_dir2_sf_to_block(xfs_da_args)
   - 如果是link文件 
   > xfs_bmap_local_to_extents(xfs_trans, xfs_inode, firstblock, 1, flags, XFS_DATA_FORK, xfs_symlink_local_to_remote)
   - reg文件的extent影射信息不会使用local? 

** xfs_bmap_add_attrfork(xfs_inode, size, rsvd)
   - 增加attr数据?? 原来是non-attributed?
   - 必须在transaction之外?
   - xfs_inode->xfs_icdinode->di_forkoff必须是0? 没有data attr数据
   - 构造transaction 
   > xfs_trans_alloc(xfs_mount, XFS_TRANS_ADDAFORK)
   - 预留空间??
   > XFS_ADDAFORK_SPACE_RES(xfs_mount)
   - 如果rsvd >0, 设置xfs_trans->t_flags的XFS_TRANS_RESERVE 
   - 什么东西??
   > xfs_trans_reserve(xfs_trans, blks, XFS_ADDAFORK_LOG_RES(xfs_mount), 0, XFS_TRANS_PERM_LOG_RES, XFS_ADDAFORK_LOG_COUNT)
   - 设置xfs_ifork->di_aformat为XFS_DINODE_FMT_EXTENTS? 还要处理attr fork? 
   - 锁住trans? 
   > xfs_trans_ijoin(xfs_trans, xfs_inode, XFS_ILOCK_EXCL)
   - log inode? 
   > xfs_trans_log_inode(xfs_trans, xfs_inode, XFS_ILOG_CORE)
   - 重新设置xfs_icdinode->di_forkoff 
   - 对于XFS_DINODE_FMT_DEV, 就是sizeof(xfs_dev_t)/8
   - 对于XFS_DINODE_FMT_UUID, 就是sizeof(uuid_t) /8
   - 对于XFS_DINODE_FMT_LOCAL/EXTENTS/BTREE 
   > xfs_attr_shortform_bytes(xfs_inode, size)
   - 如果计算的无效,使用默认的 
   > xfs_default_attroffset(xfs_inode)
   - 创建attr fork, 设置xfs_ifork->if_flags的XFS_IFEXTENTS? 为何要使用这个?
   - 初始化xfs_bmap_free, 都从新设为0
   - 根据xfs_icdinode->di_format, 创建data fork使用的空间
   - 如果是XFS_DINODE_FMT_LOCAL 
   > xfs_bmap_add_attrfork_local(xfs_trans, xfs_inode, firstblock, xfs_bmap_free, logflags)
   - 如果是XFS_DINODE_FMT_EXTENTS 
   > xfs_bmap_add_attrfork_extents(xfs_trans, xfs_inode, firstblock, xfs_bmap_free, logflags)
   - 如果是XFS_DINODE_FMT_BTREE 
   > xfs_bmap_add_attrfork_btree(xfs_trans, xfs_inode, firstblock, xfs_bmap_free, logflags)
   - 根据上面的logflags, log inode 
   > xfs_trans_log_inode(xfs_trans, xfs_inode, logflags)
   - 最后释放上面操作中多余的block? 
   > xfs_bmap_finish(xfs_trans, xfs_bmap_free, committed)
   - 提交transaction 
   > xfs_trans_commit(xfs_trans, XFS_TRANS_RELEASE_LOG_RES)

** xfs_bmap_read_extents(xfs_trans, xfs_inode, whichfork)
   - 首先获取xfs_ifork, xfs_btree_block, xfs_ifork->if_broot
   > XFS_IFORK_PTR(xfs_inode, whichfork)
   - 首先根据节点的第一个分支,找到第一个叶子节点
   - 根结点第一个分支
   > XFS_BMAP_BROOT_PTR_ADDR(xfs_mount, xfs_btree_block, 1, xfs_ifork->if_broot_bytes)
   > xfs_btree_read_bufl(xfs_mount, xfs_trans, bno, 0, xfs_buf, XFS_BMAP_BTREE_REF, xfs_bmbt_buf_ops)
   - 获取xfs_btree_block, XFS_BUF_TO_BLOCK(xfs_buf)
   - 获取第一个分支指针 
   > XFS_BMBT_PTR_ADDR(xfs_mount, xfs_btree_block, 1, xfs_mount->m_bmap_dmxr[1])
   - 然后遍历这些叶子节点,获取对应的xfs_bmbt_rec数据
   - xfs_bmbt_rec数组长度是xfs_ifork->if_bytes决定
   - 获取叶子节点xfs_btree_block 
   > xfs_btree_get_numrecs(xfs_btree_block)
   - 检查是否超过xfs_ifork在内存中的限制
   - 检查xfs_buf的xfs_btree_block成员
   > xfs_bmap_sanity_check(xfs_mount, xfs_buf, 0)
   - 遍历叶子节点里面的xfs_bmbt_rec数组
   - 放到xfs_ifork中, 数据类型从大端转为host
   > xfs_iext_get_ext(xfs_ifork, i)
   - xfs_bmbt_rec/xfs_bmbt_host/xfs_bmbt_irec是一个东西
   - 检查xfs_bmbt_irec的xfs_exntst_t
   > xfs_check_nostate_extents(xfs_ifork, start, num_recs)
   - 读取兄弟叶子节点 
   > xfs_btree_read_bufl(xfs_mount, xfs_trans, bno, 0, xfs_buf, XFS_BMAP_BTREE_REF, xfs_bmbt_buf_ops)
   > xfs_trans_brelse(xfs_trans, xfs_buf)

** xfs_bmap_search_multi_extents(xfs_ifork, xfs_fileoff_t, eof, xfs_extnum_t, xfs_bmbt_iret got, xfs_bmbt_irec prev)
   - 根据xfs_fileoff_t, 查找对应的xfs_bmbt_rec
   - xfs_extnum_t是对应的xfs_bmbt_rec的索引, 后面2个参数是结果,一个是前一个xfs_bmbt_rec, 一个是当前的
   - 如果xfs_fileoff_t指向hole, 返回下一个, 如果超过文件大小, eof设置为1
   - 查找xfs_ifork的ic的xfs_bmbt_rec_host矩阵
   > xfs_iext_bno_to_ext(xfs_ifork, bno, lastx)
   - 如果找到, 而且不是第一个, lastx>0
   - 获取前一个xfs_bmbt_rec, 转化为xfs_bmbt_irec
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, lastx-1), xfs_bmbt_irec)
   - 如果没有超过界线 xfs_ifork->if_bytes / sizeof(xfs_bmbt_rec)
   - 读取找到的 
   > xfs_bmbt_get_all(xfs_bmbt_rec_host, xfs_bmbt_irec)
   - 如果没有找到和是的, 设置eof = 1, 使用前一个xfs_bmbt_irec

** xfs_bmap_search_extents(xfs_inode, xfs_fileoff_t, fork, eofp, xfs_extnum_t lastexp, xfs_bmbt_irec gotp, xfs_bmbt_irec prep)
   - 获取xfs_ifork 
   > XFS_IFORK_PTR(xfs_inode, whichfork)
   - 查找xfs_bmbt_irec 
   > xfs_bmap_search_multi_extents(xfs_ifork, bno, eof, lastxp, xfs_bmbt_irec gotp, prevp)
   - 如果是data fork, 而且返回的xfs_bmbt_irec->br_startblock是0, 返回NULL?

** xfs_bmap_first_unused(xfs_trans, xfs_inode, xfs_extlen_t, xfs_fileoff_t, whichfork)
   - 查找(xfs_fileoff_t后面的,长度超过xfs_extlen_t的hole
   - whichfork? 查找文件的第一个hole? 
   - 对于reg可以理解, 对于dir怎么回事?
   - xfs_icdinode->di_format/di_aformat必须是XFS_DINODE_FMT_BTREE/LOCAL/EXTENTS
   - 如果是XFS_DINODE_FMT_LOCAL, 直接返回0,没有hole?
   - 获取xfs_ifork 
   > XFS_IFORK_PTR(xfs_inode, whichfork)
   - 如果xfs_ifork->if_flags没有XFS_IFEXTENTS, 读取extents数据? 
   > xfs_iread_extents(xfs_trans, xfs_inode, whichfork)
   - 遍历所有的xfs_bmbt_rec_host 
   > xfs_iext_get_ext(xfs_ifork, index)
   - 检查2个xfs_bmbt_rec_host之间的距离
   > xfs_bmbt_get_startoff(xfs_bmbt_rec_host)
   - off >= lowest+len 保证下面的比较不会溢出?
   - off-max >= len, hole长度超过len

** xfs_bmap_last_before(xfs_trans, xfs_inode, xfs_fileoff_t, whichfork)
   - 
   - 先检查di_format/di_aformat, 必须是XFS_DINODE_FMT_BTREE/LOCAL/EXTENTS
   - 如果是XFS_DINODE_FMT_LOCAL, 返回0
   - 获取xfs_ifork, 准备xfs_bmbt_rec_host 
   > xfs_iread_extents(xfs_trans, xfs_inode, whichfork)
   - 根据xfs_fileoff_t查找xfs_bmbt_rec_host 
   > xfs_bmap_search_extents(xfs_inode, bno, whichfork, eof, xfs_extnum_t, xfs_bmbt_irec got, xfs_bmbt_irec prev)
   - 如果eof==1, 或者extent没有覆盖xfs_fileoff_t,不能直接使用
   - 如果xfs_bmbt_irec->br_startoff是NULLFILEOFF, 返回0??
   - 否则使用前一个xfs_bmbt_irec的范围最大值
   > xfs_bmbt_irec->br_startoff + br_blockcount

** xfs_bmap_last_extent(xfs_trans, xfs_inode, whichfork, xfs_bmbt_irec, is_empty)
   - 获取最后一个xfs_bmbt_irec
   - 如果xfs_ifork->if_flags没有XFS_IFEXTENTS, 首先读取磁盘的xfs_bmbt_rec 
   > xfs_iread_extents(xfs_trans, xfs_inode, whichfork)
   - 根据xfs_ifork->if_bytes计算最后一个xfs_bmbt_rec索引数
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, nextents-1), xfs_bmbt_irec)

** xfs_bmap_isaeof(xfs_bmalloca, whichfork)
   - 获取最后一个xfs_bmbt_rec 
   > xfs_bmap_last_extent(NULL, xfs_bmalloca->xfs_inode, whichfork, xfs_bmbt_irec, is_empty)
   - 检查xfs_bmalloca->offset是否是在文件最后
   - 这里并不是使用磁盘位置,而是文件偏移,也就是说有没有造成hole?
   - 记录在xfs_bmalloca->aeof
   - 这是hole extent?
   > isnullstartblock(xfs_bmbt_irec->br_startblock)

** xfs_bmap_eof(xfs_inode, xfs_fileoff_t, whichfork, eof)
   - 判断xfs_fileoff_t是否超过文件大小
   - 没有使用i_size? 反而使用extent信息?
   - 获取最后一个xfs_bmbt_rec 
   > xfs_bmap_last_extent(NULL, xfs_inode, whichfork, xfs_bmbt_irec, eof)
   - 比较xfs_bmbt_irec->br_startoff + br_blockcount

** xfs_bmap_last_offset(xfs_trans, xfs_inode, xfs_fileoff_t, whichfork)
   - 获取文件最大偏移
   - 如果是XFS_DINODE_FMT_LOCAL, 返回0
   - 如果不是XFS_DINODE_FMT_BTREE/EXTENTS,返回EIO??
   - 获取最后一个xfs_bmbt_rec 
   > xfs_bmap_last_extent(NULL, xfs_inode, whichfork, xfs_bmbt_irec, is_empty)
   - 返回xfs_bmbt_irec->br_startoff + br_blockcount

** xfs_bmap_one_block(xfs_inode, whichfork)
   - 检查data/attr fork是否只有一个block?
   - 检查xfs_icdinode->di_nextents/di_anextents 
   > XFS_IFORK_NEXTENTS(xfs_inode, whichfork)
   - 如果不是XFS_DINODE_FMT_EXTENTS, 也不可能?? btree会有多个?
   - 获取第一个xfs_bmbt_irec 
   > XFS_IFORK_PTR(xfs_inode, whichfork)
   > xfs_iext_get_ext(xfs_ifork, 0)
   > xfs_bmbt_get_all(xfs_bmbt_rec_hsot, xfs_bmbt_irec)
   - bt_startoff ==0, 而且br_blockcount ==1
   - 如果是data fork, xfs_inode->i_size必须是sb_blocksize?

** xfs_bmalloca 
   #+BEGIN_SRC 
	xfs_fsblock_t		*firstblock; /* i/o first block allocated */
	struct xfs_bmap_free	*flist;	/* bmap freelist */
	struct xfs_trans	*tp;	/* transaction pointer */
	struct xfs_inode	*ip;	/* incore inode pointer */
	struct xfs_bmbt_irec	prev;	/* extent before the new one */
	struct xfs_bmbt_irec	got;	/* extent after, or delayed */

	xfs_fileoff_t		offset;	/* offset in file filling in */
	xfs_extlen_t		length;	/* i/o length asked/allocated */
	xfs_fsblock_t		blkno;	/* starting block of new extent */

	struct xfs_btree_cur	*cur;	/* btree cursor */
	xfs_extnum_t		idx;	/* current extent index */
	int			nallocs;/* number of extents alloc'd */
	int			logflags;/* flags for transaction logging */

	xfs_extlen_t		total;	/* total blocks needed for xaction */
	xfs_extlen_t		minlen;	/* minimum allocation size (blocks) */
	xfs_extlen_t		minleft; /* amount must be left after alloc */
	char			eof;	/* set if allocating past last extent */
	char			wasdel;	/* replacing a delayed allocation */
	char			userdata;/* set if is user data */
	char			aeof;	/* allocated space at eof */
	char			conv;	/* overwriting unwritten extents */
	char			stack_switch;
	int			flags;
	struct completion	*done;
	struct work_struct	work;
	int			result;   
   #+END_SRC

** xfs_bmap_add_extent_delay_real(xfs_bmalloca)
   - 从delayed allocation转化为real allocation? 
   - xfs_bmalloca->got是分配的xfs_bmbt_irec, new
   - 获取data fork, xfs_bmalloca->xfs_inode->xfs_ifork 
   > XFS_IFORK_PTR(xfs_inode, XFS_DATA_FORK)
   - 检查xfs_bmalloca的参数
   - xfs_bmalloca->idx是xfs_bmbt_irec在extents数组中的索引, 而且xfs_bmbt_irec不是hole 
   > isnullstartblock(xfs_bmbt_irec->br_startblock)
   - 获取xfs_ifork中对应的xfs_bmbt_rec_host
   > xfs_iext_get_ext(xfs_ifork, xfs_bmalloca->idx)
   - 转化为xfs_bmbt_irec, prev
   > xfs_bmbt_get_all(xfs_bmbt_rec_host, xfs_bmbt_irec)
   - prev的范围必须覆盖new
   - 检查new和2端exetnt的关系, 计算合并的条件state
   - 如果new和prev的start文件偏移重复,设置BMAP_LEFT_FILLING, BMAP_RIGHT_FILLING
   - 如果2端有extent, 也就是不在文件数据开头和末尾, 设置BMAP_LEFT_VALID, BMAP_RIGHT_VALID
   - 如果2端的extent没有指向有效的磁盘空间, delay allocation, 设置XFS_LEFT_DELAY, XFS_RIGHT_DELAY
   - 检查2端extent的磁盘位置是否和new连续, 设置BMAP_LEFT_CONTIG, BMAP_RIGHT_CONTIG
   - state & BMAP_LEFT_VALID, 左边extent存在
   - state没有BMAP_LEFT_DELAY, 左边extent不是delay allocation, 分配磁盘空间
   - left->br_startoff + left->br_blockcount == new->br_startoff
   - left->br_startblock + left->br_blockcount == new->br_startblock
   - left->br_state == new->br_state, 这是什么意思???
   - left->br_blockcount + new->br_blockcount <= MAXEXTLEN, 合并之后长度没有超过限制
   - 检查right的extent时,还要考虑3个extent合并是否超过MAXEXTLEN
   - 如果state == BMAP_LEFT_FILLING | BMAP_LEFT_CONTIG | BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG, 合并3个extent
   - 设置xfs_bmalloca->idx-1, 这个index指向left, 为何不直接修改index? 可能还是需要xfs_bmalloc->xfs_btree_cur??
   - 设置idx对应的xfs_bmbt_rec_host的blockcount 
   > xfs_bmbt_set_blockcount(xfs_iext_get_ext(xfs_ifork, xfs_bmalloca->idx), LEFT->br_blockcount + PREV->br_blockcount + RIGHT->br_blockcount)
   - 删除多余的2个xfs_bmbt_rec_host 
   > xfs_iext_remove(xfs_bmalloca->xfs_inode, xfs_bmalloca->idx+1, 2, state) 
   - 修改xfs_inode->xfs_icdinode->di_nextents --, 删除2个,为何就减小1个??
   - 然后删除btree中的节点??
   - 如果xfs_bmalloca->xfs_btree_cur == NULL, 就不释放了?? 设置rval = XFS_ILOG_CORE|XFS_ILOG_DEXT
   - 否则删除右边的extent? 设置rval = XFS_ILOG_CORE?? 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, right->br_startoff, right->br_startblock, right->br_blockcount, i)
   > xfs_btree_delete(xfs_bmalloca->xfs_btree_cur, i)
   > xfs_btree_decrement(xfs_bmalloca->xfs_btree_cur, 0, i)
   - 同时更新left的xfs_bmbt_rec, 文件偏移startoff, 磁盘位置startblock, 长度blockcount, 状态state
   > xfs_bmbt_update(xfs_bmalloca->xfs_btree_cur, left->br_startoff, left->br_startblock, left->br_blockcount + PREV->br_blockcount + right->br_blockcount, left->br_state)
   - 如果没有xfs_btree_cur就不更新了, 而且new没有在btree中??
   - 如果state == BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_LEFT_CONTIG
   - right的extent不存在? delayed? 或者state不一样? 可以直接合并prev和left
   - 修改xfs_bmalloca->idx --
   - xfs_bmbt_set_blockcount(xfs_iext_get_ext(xfs_ifork, xfs_bmalloca->idx), LEFT->br_blockcount + PREV->br_blockcount)
   - 删除prev对应的xfs_bmbt_rec_host
   - 如果xfs_bmalloca->xfs_btree_cur不存在,设置rval = XFS_ILOG_DEXT
   - 否则修改btree节点
   > xfs_bmbt_lookup_eq(xfs_bmalloca->xfs_btree_cur, left->br_startoff, left->br_startblock, left->br_blockcount, i)
   - 更新startoff, startblock, blockcount
   > xfs_bmbt_update(xfs_bmalloca->xfs_btree_cur, left->br_startoff, left->br_blockcount + prev->br_blockcount, left->br_state)
   - 如果是BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING | BMAP_RIGHT_CONTIG,
   - 合并右边2个extent, 上面这些合并,都需要new和prev完全重合
   - 更新prev指向的xfs_bmbt_rec_host 
   > xfs_bmbt_set_startblock(xfs_bmbt_irec, new->br_startblock)
   > xfs_bmbt_set_blockcount(xfs_bmbt_irec, PREV->br_blockcount + right->br_blockcount)
   - 删除right对应的xfs_bmbt_rec_host 
   > xfs_iext_remove(xfs_bmalloca->xfs_inode, idx+1, 1, state)
   - 修改btree节点 
   - 查找right对应的xfs_bmbt_rec
   > xfs_bmbt_lookup_eq(xfs_bmalloca->xfs_btree_cur, right->br_startoff, ..)
   > xfs_bmbt_update(xfs_bmalloca->xfs_btree_cur, br_startoff, bf_startblock, PREV->br_blockcount + right->br_blockcount, prev->br_state)
   - 如果state == BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING, 不需要合并, 只需要创建新的btree节点
   - 修改prev对应的xfs_bmbt_rec_host 
   > xfs_bmbt_set_startblock(xfs_bmbmt_rec_host, xfs_bmbt_irec->br_startblock)
   - 增加xfs_inode->xfs_icdinode->id_nextents ++
   - 查找btree节点?? 不是创建?? 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, xfs_bmbt_irec->br_startoff, xfs_bmbt_irec->br_startblock, br_blockcount, i) 
   - 设置xfs_bmalloca->xfs_btree_cur->bc_rec->xfs_bmbt_rec_host->br_state == XFS_EXT_NORM?? 
   >xfs_btree_insert(xfs_bmalloca->xfs_btree_cur, i)
   - 如果state == BMAP_LEFT_FILLING | BMAP_LEFT_CONFIG, 需要分配prev对应的xfs_bmbt_rec_host?
   - 先更新left, 包含进去新分配的空间
   - 增加blockcount
   > xfs_bmbt_set_blockcount(xfs_iext_get_ext(xfs_ifork, idx-1), left->br_blockcount + new->br_blockcount)
   - 修改btree节点
   > xfs_bmbt_lookup_eq(xfs_bmalloca->xfs_btree_cur, left->br_startoff, left->br_startblock, left->br_blockcount, i)
   > xfs_bmbt_update(xfs_bmalloca->xfs_btree_cur, left->br_startoff, left->br_startblock, left->br_blockcount + new->br_blockcount, left->br_state)
   - 然后更新prev指向的xfs_bmbt_rec_host
   - 修改文件偏移startoff
   > xfs_bmbt_set_startoff(xfs_bmbt_rec_host, prev->br_startoff + new->br_blockcount)
   - 设置extent长度
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, prev->br_blockcount - new->br_blockcount)
   - 设置磁盘位置?? 原来应该是什么?? 
   - 为何计算btree使用的block数量? 还要还要和原来的磁盘开始位置比,取较小值??
   > xfs_bmap_worst_indlen(xfs_inode, new->br_blockcount-prev->br_blockcount)
   > startblockval(prev->br_startblock)
   - 为了下次分配??
   - 设置新的磁盘位置, 这个肯定是hole, 但为以后分配提供一点信息 
   > xfs_bmbt_set_startblock(xfs_bmbt_rec_host, nullstartblock(startoff))
   - 如果state ==BMAP_LEFT_FILLING, 左边连续,但磁盘不连续, 分裂extent? 修改prev对应的xfs_bmbt_rec_host, 然后在之前插入一个新的
   - 先修改prev的文件偏移和extent长度
   > xfs_bmbt_set_startoff(xfs_bmbt_rec_host, new_endoff)
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, temp)
   - 然后创建新的xfs_bmbt_rec_host 
   > xfs_iext_insert(xfs_inode, idx, 1, xfs_bmbt_irec, state) 
   - 增加xfs_inode->xfs_icdinode->id_nextents ++
   - 插入btree节点, 如果不存在为何还查找?
   > xfs_bmbt_lookup_eq(xfs_btree_cur, xfs_bmbt_irec->br_startoff, startblock, blockcount, i)
   - 设置xfs_btree_cur->bc_rec->xfs_bmbt_irec->br_state = XFS_EXT_NORM
   > xfs_btree_insert(xfs_bmalloca->xfs_btree_cur)
   - 检查extent是否需要转为XFS_DINODE_FMT_BTREE格式 
   > xfs_bmap_needs_btree(xfs_inode, XFS_DATA_FORK)
   - 为何要使用firstblock? 用来分配空间??
   > xfs_bmap_extents_to_btree(xfs_trans, xfs_bmalloca->xfs_inode, firstblock, xfs_bmap_free, xfs_btree_cur, 1, tmp_rval, XFS_DATA_FORK)
   - 然后更新prev指向的xfs_bmbt_rec_host的磁盘地址
   > xfs_bmap_worst_indlen(xfs_inode, temp)
   > startblockval(prev->br_startblock)
   - 获取对应的xfs_bmbt_rec_host, 现在快混了！！
   > xfs_iext_get_ext(xfs_ifork, idx+1)
   > xfs_bmbt_set_startblock(xfs_bmbt_rec_host, nullstartblock(new))
   - 如果state是BMAP_RIGHT_FILLING|BMAP_RIGHT_CONTIG, extent需要分类,而且更新right的xfs_bmbt_rec
   - 首先更西prev对应的xfs_bmbt_rec_ host
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, prev->br_blockcount - new->br_blockcount)
   - 更新right对应的xfs_bmbt_rec_host
   > xfs_bmbt_set_allf(xfs_iext_get_ext(xfs_ifork, idx+1), new->br_startoff, new->br_startblock, new->br_blockcount + right->br_blockcount, right->br_state)
   - 然后更新btree节点 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, right->br_startoff, right->br_startblock, right->br_blockcount, i)
   - 直接使用new的起始位置和right的count/state
   > xfs_bmbt_update(xfs_btree_cur, new->br_startoff, startblock, blockcount, state)
   - 这样本不用更新prev指向的xfs_bmbt_rec_host, 但还是更新了startblock
   - 所以磁盘位置是其他地方使用的 
   > xfs_bmap_worst_indlen(xfs_inode, temp)
   > xfs_bmbt_set_startblock(xfs_bmbt_rec_host, nullstartblock(da_new))
   - 如果state == BMAP_RIGHT_FILLING, 需要分割extent, 但不用合并
   - 先更新prev指向的xfs_bmbt_rec_host
   - xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, prev->br_blockcount - new->br_blockcount)
   - 插入new对应的新的xfs_bmbt_rec_host 
   > xfs_iext_insert(xfs_inode, idx+1, 1, xfs_bmbt_irec, state)
   - 增加xfs_inode->xfs_icdinode->id_nextents ++
   - 插入新的btree数据xfs_bmbt_rec
   > xfs_bmap_lookup_eq(xfs_btree_cur, new->br_startoff, new->br_startblock, new->br_blockcount, i)
   - 设置xfs_btree_cur->bc_rec->xfs_bmbt_irec->br_state = XFS_EXT_NORM 
   > xfs_btree_insert(xfs_btree_cur, i)
   - 然后检查是否转化di_format为XFS_DINODE_FMT_BTREE 
   > xfs_bmap_needs_btree(xfs_inode, XFS_DATA_FORK)
   > xfs_bmap_extents_to_btree(xfs_trans, xfs_inode, xfs_bmalloca->firstblock, xfs_bmap_free, xfs_btree_cur, 1, tmp_rval, XFS_DATA_FORK)
   - 然后更新prev指向的xfs_bmbt_rec_host, 更新他的磁盘位置 
   > xfs_bmap_worst_indlen(xfs_inode, temp)
   - 为何不使用上面的xfs_bmbt_rec_host? 还有重新计算??
   > xfs_iext_get_ext(xfs_ifork, idx)
   > xfs_bmbt_set_startblock(xfs_bmbt_rec_host, nullstartblock(da_new))
   - 如果state ==0, 说明新分配的extet在prev的内部,需要把它分成3部分
   - 2端都是delay allocation
   - 第一个端使用原来的xfs_bmbt_rec_host, 更新长度 
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, new->br_startoff - prev->br_startoff)
   - 先准备2个xfs_bmbt_irec, 第一个对应new, 第二个对应第三段
   - 对于第3段, startoff是new的结束，blockcount是prev->br_blockcount+prev->br_startoff - new->br_blockcount - new->br_startoff
   - startblock需要根据新的blockcount计算
   > nullstartblock(xfs_bmap_worst_indlen(xfs_inode, temp2))
   - 插入新的xfs_bmbt_rec_host 
   > xfs_iext_insert(xfs_inode, idx+1, 2, xfs_bmbt_irec, state)
   - 增加xfs_inode->xfs_icdinode->id_nextents ++, 原来只增加btree的记录数量
   - 查找btree, 插入new对应的节点
   > xfs_bmbt_lookup_eq(xfs_btree_cur, new->br_startoff, startblock, blockcount, i)
   > xfs_btree_insert(xfs_btree_cur, i)
   - 检查是否转化di_format 
   > xfs_bmap_extents_to_btree(xfs_trans, xfs_inode, xfs_bmalloca->firstblock, xfs_bmap_free, xfs_btree_cur, 1, tmp_rval, XFS_DATA_FORK)
   - 然后更新2变delay allocation的xfs_bmbt_rec_host的磁盘位置
   - 需要重新计算??
   > xfs_bmap_worst_indlen(xfs_inode, temp)
   > xfs_bmbt_set_startblock(xfs_iext_get_ext(xfs_ifork, idx+2), nullstartblock(temp))
   - 对于state的其他组合,都不可能
   - 最后再检查btree的转化?? 
   > xfs_bmap_needs_btree(xfs_inode, XFS_DATA_FORK)
   - 这里还修改了系统参数?? XFS_SBS_FDBLOCKS??

** xfs_bmap_add_extent_unwritten_real(xfs_trans, xfs_inode, xfs_extnum_t idx, xfs_bmbt_irec new, xfs_fsblock_t first, xfs_bmap_free, logflags)
   - 这里和上面类似?
   - 操作data fork, extent数据  
   > XFS_IFORK_PTR(xfs_inode, XFS_DATA_FORK)
   - idx必须在xfs_fork的xfs_bmbt_rec_host数组长度范围之内
   - xfs_ifork->if_bytes / sizeof(xfs_bmbmt_rec_host)
   - 获取idx对应的xfs_bmbt_rec_host
   - 它必须覆盖参数xfs_bmbt_irec
   > xfs_iext_get_ext(xfs_ifork, idx)
   - 转化为xfs_bmbt_irec
   > xfs_bmbt_get_all(xfs_bmbt_rec_host, prev)
   - 检查extent的状态, 它必须和new对应
   - 如果new->br_state是XFS_EXT_UNWRITTEN, prev必须是XFS_EXT_NORM?? 否则是XFS_EXT_UNWRITTEN??
   - 检查new和prev的关系,计算state
   - 如果prev和new的br_startoff相同设置BMAP_LEFT_FILLING
   - 如果br_startoff + br_blockcount相同,设置BMAP_RIGHT_FILLING
   - 检查2端的extent，先检查前面的extent
   - 如果前面存在extent, idx > 0, 设置BMAP_LEFT_VALID
   - 获取xfs_bmbt_irec, left
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, idx-1), left)
   - 如果letf->br_startblock是null, 设置state的BMAP_LEFT_DELAY 
   > isnullstartblock(left->br_startblock)
   - 如果state有BMAP_LEFT_VALID, 没有BMAP_LEFT_DELAY
   - 文件偏移和磁盘位置, 都和new邻接
   - 而且state相同new相同, 而且br_blockcount累加不超过MAXEXTLEN
   - 设置state的BMAP_LEFT_CONTIG
   - 再检查后面的extent, idx < xfs_ifork->if_bytes / sizeof(xfs_bmbt_rec_host) - 1
   - 设置state的BMAP_RIGHT_VALID, 获取xfs_bmbt_irec right
   - 如果它没有有效的startblock, 设置state的BMAP_RIGHT_VALID
   - 检查它是否可以和new合并
   - 如果state有BMAP_RIGHT_VALID, 没有BMAP_RIGHT_DELAY
   - 文件偏移和磁盘位置和new邻接, state相同
   - 合并之后长度没有超过限制 MAXEXTLEN
   - 根据state处理extent..
   - 如果是BMAP_LEFT_FILLING|XFS_LEFT_CONTIG|XFS_RIGHT_FILLING|XFS_RIGHT_CONTIG
   - 合并3个extent, 需要减小extent的个数, 减小2个 
   - xfs_inode->xfs_icdinode->di_nextents -=2
   - 更新第一个extent的长度 
   > xfs_bmbt_set_blockcount(xfs_iext_get_ext(xfs_ifork, idx), LEFT->br_blockcount+new->br_blockcount+right->br_blockcount)
   - 删除多余的xfs_bmbt_rec_host 
   > xfs_iext_remove(xfs_inode, idx+1, 2, state)
   - 删除btree中的节点
   - 现在prev,right,left都在btree中??
   - 先找到right对应的xfs_bmbt_rec 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, right->br_startoff, right->br_startblock, RIGHT->br_blockcount, i)
   - 删除 
   > xfs_btree_delete(xfs_btree_cur, i)
   - 然后向前移动xfs_btree_cur, 再删除一个记录 ???
   > xfs_btree_decrement(xfs_btree_cur, 0, i)
   > xfs_btree_delete(xfs_btree_cur, i)
   - 然后更新前面xfs_bmbt_rec的长度
   > xfs_bmbt_update(xfs_btree_cur, left->br_startoff, br_startblock, left->br_blockcount + new->br_blockcount + right->br_blockcount, left->br_state)
   - 如果state是BMAP_LEFT_FILLING|BMAP_RIGHT_FILLING|BMAP_LEFT_CONTIG,
   - 把前2个xfs_bmbt_rec合并, 这里需要有BMAP_RIGHT_FILLING, 否则就得分裂extent 
   - 减小xfs_inode->xfs_icdinode->di_nextents --
   - 更新前面xfs_bmbt_rec_host的长度 
   > xfs_bmbt_set_blockcount(xfs_iext_get_ext(xfs_ifork, idx), left->br_blockcount + prev->br_blockcount)
   - 删除prev对应的xfs_bmbt_rec_host 
   > xfs_iext_remove(xfs_inode, idx+1, 1, state)
   - 删除prev对应的xfs_bmbt_rec 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, prev->br_startoff, prev->br_startblock, prev->br_blockcount, i)
   > xfs_btree_delete(xfs_btree_cur, i)
   - 然后更新前面xfs_bmbt_rec对应的长度 
   > xfs_btree_decrement(xfs_btree_cur, i)
   > xfs_bmbt_update(xfs_btree_cur, left->br_startoff, left->br_startblock, left->br_blockcount + prev->br_blockcount)
   - 如果是XFS_LEFT_FILLING|XFS_RIGHT_FILLING|XFS_RIGHT_CONTIG
   - 把后面2个xfs_bmbt_rec_host合并 
   - 减小xfs_inode->xfs_icdinode->di_nextents --
   - 更新prev指向的xfs_bmbt_rec_host的长度 
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, prev->br_blockcount + right->br_blockcount)
   > xfs_bmbt_set_state(xfs_bmbt_rec_host, new->br_state)
   - 删除后面的xfs_bmbt_rec_host
   > xfs_iext_remove(xfs_inode, idx+1, 1, state)
   - 操作brtee, 删除right对应的xfs_bmbt_rec_host
   > xfs_bmbt_lookup_eq(xfs_btree_cur, right->br_startoff, right->br_startblock, right->br_blockcount, i)
   > xfs_bmbt_delete(xfs_btree_cur, i)
   - 更新前面的xfs_bmbt_rec
   > xfs_btree_decrement(xfs_btree_cur, 0, i)
   > xfs_bmbt_update(xfs_btree_cur, new->br_startoff, new->br_startblock, new->br_blockcount + right->br_blockcount, new->br_state)
   - 如果state是BMAP_LEFT_FILLING | BMAP_RIGHT_FILLING
   - 不能合并,但可以转化prev对应的xfs_bmbt_rec
   - 更新xfs_bmbt_rec_host的state 
   > xfs_bmbt_set_state(xfs_bmbt_rec_host, new->br_state)
   - 修改xfs_bmbt_rec 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, new->br_startoff, new->br_startblock, new->br_blockcount, i)
   > xfs_bmbt_update(xfs_btree_cur, new->br_startoff, ..., new->br_state)
   - 如果state是BMAP_LEFT_FILLING|BMAP_LEFT_CONTIG
   - 需要把prev分成2部分, 前面的和left合并
   - 修改left对应的xfs_bmbt_rec_host的长度 
   > xfs_bmbt_set_blockcount(xfs_iext_get_ext(xfs_ifork, idx-1), left->br_blockcount + new->br_blockcount)
   - 修改prev的开始位置, 文件偏移
   > xfs_bmbt_set_startoff(xfs_bmbt_rec_host, prev->br_startoff + new->br_blockcount)
   - prev的磁盘位置有效??? 
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, prev->br_blockcount - new->br_blockcount)
   - 然后更新btree的xfs_bmbt_rec 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, prev->br_startoff, prev->br_startblock, prev->br_blockcount, i)
   - 更新开始位置
   > xfs_bmbt_update(xfs_btree_cur, prev->br_startoff + new->br_blockcount, prev->br_blockcount + new->br_blockcount, prev->br_blockcount - new->br_blockcount, prev->br_state)
   - 修改前一个xfs_bmbt_rec的长度 
   > xfs_bmbt_decrement(xfs_btree_cur, 0, i)
   > xfs_bmbt_update(xfs_btree_cur, left->br_startoff, left->br_startblock, left->br_blockcount + new->br_blockcount, left->br_state)
   - 如果state是BMAP_LEFT_FILLING, 只需要把prev分成2部分, 没有合并
   - 增加xfs_inode->xfs_icdinode->di_nextents ++
   - 先修改prev对应的xfs_bmbt_rec_host 
   > xfs_bmbt_set_startoff(xfs_bmbt_rec_host, new_end)
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, new->br_blockcount)
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, prev->br_blockcount + new->br_blockcount)
   - 在前面插入新的new对应的xfs_bmbt_rec_host
   > xfs_iext_insert(xfs_inode, idx, 1, new, state)
   - 然后修改btree的xfs_bmbt_rec
   > xfs_bmbt_lookup_eq(xfs_btree_cur, prev->br_startoff, prev->br_startblock, prev->br_blockcount, i)
   - 做上面对应的更新 
   > xfs_bmbt_update(xfs_btree_cur, prev->br_startoff + new->br_blockcount, prev->br_startblock + new->br_blockcount, PREV->br_blockcount - new->br_blockcount, prev->br_state)
   - 然后把new给xfs_btree->br_rec->xfs_bmbt_irec, 插入新的xfs_bmbt_rec
   > xfs_btree_insert(xfs_btree_cur, i)
   - 如果state是BMAP_RIGHT_FILLING|BMAP_RIGHT_CONTIG
   - 同样把prev分成2部分,后一部分和rgiht合并
   - 更新prev指向的xfs_bmbt_rec_host的长度 
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, prev->br_blockcount - new->br_blockcount)
   - 更新right对应的xfs_bmbt_rec_host的开始位置
   > xfs_bmbt_set_allf(xfs_iext_get_ext(xfs_ifork, idx), new->br_startoff, new->br_startblock, new->br_blockcount + right->br_blockcount, new->br_state)
   - 更新btree的xfs_bmbt_rec 
   - 首先更新prev对应的xfs_bmbt_rec
   > xfs_bmbt_lookup_eq(xfs_btree_cur, prev->br_startoff, prev->br_startblock, prev->br_blockcount, i)
   > xfs_bmbt_update(xfs_btree_cur, prev->br_startoff, prev->br_blockstart, prev->br_blockcount - new->br_blockcount, prev->br_state)
   - 然后更新right 
   > xfs_btree_increment(xfs_btree_cur, 0, i)
   > xfs_bmbt_update(xfs_btree_cur, new->br_startoff, new->br_startblock, new->br_blockcount + right->br_blockcount, new->br_state)
   - 如果state是BMAP_RIGHT_FILLING, 只会把prev分成2部分,而不会合并
   - 增加xfs_inode->xfs_icdinode->di_nextents ++
   - 修改prve对应的blockcount
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, prev->br_blockcount - new->br_blockcount)
   - 然后使用new创建对应的xfs_bmbt_rec_host 
   > xfs_iext_insert(xfs_inode, idx, 1, new, state)
   - 然后修改btree的xfs_bmbt_rec
   - 首先是prev的blockcount 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, prev->br_startoff, prev->br_startblock, prev->br_blockcount, i)
   > xfs_bmbt_update(xfs_btree_cur, prev->br_startoff, prev->br_blockcount, prev->br_blockcount - new->br_blockcount, prev->br_state)xo
   - 然后插入新的节点, 为何就成了先查找??而不是insert? 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, new->br_startoff, new->br_startblock, new->br_blockcount, i)
   - 修改xfs_btree_cur->bc_rec->xfs_bmbt_irec->br_state = XFS_EXT_NORM 
   > xfs_btree_insert(xfs_btree_cur, i)
   - 如果state是0, prev需要分成3部分, 增加xfs_inode->xfs_icdinode->di_nextents += 2
   - 更新第一部分的长度 
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, new->br_startoff - prev->br_startoff)
   - 然后构造2个xfs_bmbt_irec, 第一个可使用new, 第二个对应第三部分 
   > xfs_iext_insert(xfs_inode, idx, 2, r, state)
   - 然后修改btree的xfs_bmbt_rec
   - 先更新第三部分的长度 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, prev->br_startoff, prev->br_startblock, prev->br_blockcount, i)
   > xfs_bmbt_update(xfs_btree_cur, r[1].br_startoff, ..)
   - 然后使用prev添加第一部分, 给xfs_btree_cur->bc_rec->xfs_bmbt_irec
   - 因为这是xfs_bmbt_cur可以直接插入??
   > xfs_btree_insert(xfs_btree_cur, i)
   - 然后修改xfs_btree_cur, 指向第二部分 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, new->br_startoff, ...)
   > xfs_btree_insert(xfs_btree_cur, i)
   - 对于其他的state, 都是错误的状态
   - 最后检查di_format是否需要变为XFS_DINODE_FMT_BTREE 
   > xfs_bmap_need_btree(xfs_inode, XFS_DATA_FORK)
   > xfs_bmap_extents_to_btree(xfs_trans, xfs_inode, first, xfs_bmap_free, xfs_btree_cur, 0, logflags, XFS_DATA_FORK)
  
** xfs_bmap_add_extent_hole_delay(xfs_inode, xfs_extnum_t idx, xfs_bmbt_irec)
   - 参数xfs_bmbt_irec还没有插入到xfs_ifork中, 而且它是delay allocation
   - 获取xfs_ifork, 2端的xfs_bmbt_iref 
   > XFS_FORK_PTR(xfs_inode, XFS_DATA_FORK)
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, idx-1), left)
   - 检查xfs_bmbt_irec->br_startblock
   - 同样设置state的BMAP_LEFT_VALID|BMAP_LEFT_DELAY
   - 参数xfs_bmbt_irec是delay allocation
   - 参数idx对应的是right的xfs_bmbt_rec_host
   - 如果2端的xfs_bmbt_rec_host->br_blockcount也是无效的磁盘位置,才考虑合并
   - 根据文件偏移,检查是否可合并BMAP_LEFT_CONTIG
   - 如果state是BMAP_LEFT_CONTIG|BMAP_RIGHT_CONGIT
   - 合并3个xfs_bmbt_rec, 这里只会更新xfs_bmbt_rec_host 
   > xfs_bmbt_set_blockcount(xfs_iext_get_ext(xfs_ifork, idx), left->br_blockcount + new->br_blockcount + right->br_blockcount)
   - 这3个xfs_bmbt_rec_host都是delay allocation, br_blockcount只需合并
   - startblockval(left->br_startblock) + startblockval(new->br_blockcount) + startblock(right->br_blockcount)
   > xfs_bmbt_set_startblock(xfs_iext_get_ext(xfs_ifork, idx), nullstartblock(newlen))
   - 然后删除right指向的xfs_bmbt_rec_host 
   > xfs_iext_remove(xfs_inode, idx+1, 1, state)
   - 这里没有btree操作
   - 如果state是BMAP_LEFT_CONTIG, 只需要合并前面的2个xfs_bmbt_rec_host
   - 只需要修改blockcount, startblock
   - 如果state是BMAP_RIGHT_CONGIT, 合并后面2个xfs_bmbt_rec_host
   - 需要修改right的blockcount, startblock, startoff
   - 如果state是0, 不能合并,直接插入新的xfs_bmbt_rec_host 
   > xfs_iext_insert(xfs_ifork, idx, 1, xfs_bmbt_irec, state)
   - startblock会有改变,影响到XFS_SBS_FDBLOCKS的计数

** xfs_bmap_add_extent_hole_real(xfs_bmalloca, whichfork)
   - 给hole的xfs_bmbt_rec添加磁盘信息 
   - 分配的磁盘信息在xfs_bmalloca->got中,还没有放到xfs_ifork中
   - 获取对应的xfs_ifork 
   > XFS_IFORK_PTR(xfs_inode, whichfork)
   - 操作的xfs_bmbt_rec_host是xfs_bmalloca->idx, xfs_bmalloca->got是分配的xfs_bmbt_irec
   - 这个xfs_bmbt_irec->br_startblock必须是有效的 
   > isnullstartblock(new->br_startblock)
   - 获取2端的xfs_bmbt_irec/xfs_bmbt_rec_host
   - xfs_bmalloca->idx指向right, idx-1指向left, 分别获取对应的xfs_bmbt_irec 
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, idx-1), left)
   - 根据xfs_bmbt_irec->br_startblock计算合并的条件
   - 如果存在xfs_bmbt_rec_host, 设置BMAP_LEFT_VALID 
   - 如果磁盘位置无效, 设置BMAP_LEFT_DELAY 
   > isnullstartblock(left->br_startblock)
   - 如果文件偏移磁盘位置连续, 而且不是BMAP_LEFT_DELAY, 而且br_state一样,可以合并设置BMAP_LEFT_CONTIG
   - 如果state是BMAP_LEFT_CONGIT|BMAP_RIGHT_CONTIG, 可以合并3个xfs_bmbt_irec
   - 首先更新xfs_ifork, 修改left的blockcount 
   > xfs_bmbt_set_blockcount(xfs_iext_get_ext(xfs_ifork, idx), left->br_blockcount + new->br_blockcount + right->br_blockcount)
   - 删除right对应的xfs_bmbt_rec_host
   > xfs_iext_remove(xfs_inode, idx+1, 1, state)
   - 修改di_nextents或者di_anextents 
   > XFS_IFORK_NEXT_SET(inode, whichfork, XFS_IFORK_NEXTENTS(xfs_inode, whichfork) - 1)
   - 更新btree中的xfs_bmbt_rec
   - 查找right对应的xfs_bmbt_rec, 直接删除
   > xfs_bmbt_lookup_eq(xfs_btree_cur, right->br_startoff, br_blockcount, ..)
   > xfs_bmbt_delete(xfs_btree_cur, i)
   - 修改left对应的xfs_bmbt_rec 
   > xfs_btree_decrement(xfs_btree_cur, 0, i)
   > xfs_bmbt_update(xfs_btree_cur, left->br_startoff, left->br_startblock, left->br_blockcount + new->br_blockcount + right->br_blockcount, left->br_state)
   - 如果state是BMAP_LEFT_CONTIG, 直接合并前2个extent
   - 修改left对应的xfs_bmbt_rec_host的长度
   > xfs_bmbt_set_blockcount(xfs_iext_get_ext(xfs_ifork, idx), left->br_blockcount, new->br_blockcount)
   - 同时修改btree中的xfs_bmbt_rec
   > xfs_bmbt_lookup_eq(xfs_btree_cur, left->br_startoff, ...)
   > xfs_bmbt_update(xfs_btree_cur, left->br_startoff, left->br_startblock, left->br_blockcount + new->br_blockcount, left->br_state)
   - 如果state是BMAP_RIGHT_CONTIG, 只需要合并后面2个xfs_bmbt_rec_host 
   - 更新xfs_ifork的xfs_bmbt_rec_host 
   - 修改right的startoff, startblock
   > xfs_bmbt_set_allf(xfs_iext_get_ext(xfs_ifork, idx), new->br_startoff, new->br_startblockoff, new->br_blockcount + right->br_blockcount, new->br_state)
   - 然后更新btree的xfs_bmbt_rec 
   > xfs_bmbt_lookup_eq(xfs_btree_cur, right->br_startoff, right->br_startblock, right->br_blockcount, i)
   - 还有额外的更新state
   > xfs_bmbt_update(xfs_btree_cur, new->br_startoff, new->br_startblock, new->br_blockcount + left->br_blockcount, right->br_state)
   - 如果state是0, 没法合并,需要插入xfs_bmbt_rec(_host)
   - 首先操作xfs_ifork, 插入新的xfs_bmbt_rec_host
   - 在idx位置处, 使用的数据就是new
   > xfs_iext_insert(xfs_ifork, idx, 1, new)
   - 然后插入btree的xfs_bmbt_rec 
   - 首先准备xfs_btree_cur, 这个查找是什么操作???
   > xfs_bmbt_lookup_eq(xfs_btree_cur, new->br_startoff, new->br_startblock, new->br_blockcount, i)
   > 把new给xfs_btree_cur->bc_rec->xfs_bmbt_irec
   > xfs_bmbt_insert(xfs_btree_cur, i)
   - 最后检查xfs_inode的di_format/di_aformat是否需要转化
   > xfs_bmap_needs_btree(xfs_inode, whichfork)
   > xfs_bmap_extents_to_btree(xfs_trans, xfs_inode, firstblock, xfs_bmap_free, xfs_btree_cur, 0, logflags, whichfork)

** xfs_bmap_extsize_align(xfs_mount, xfs_bmbt_irec gotp, xfs_bmbt_irec prev, xfs_extlen_t extsz, rt, eof, delay, convert, xfs_fileoff_t off, xfs_extlen_t len)
   - 参数的2个xfs_bmbt_irec应该在(off,len)2端
   - 调整新的extent的大小?
   - (off,len)表示需要的extent? 记录为(orig_off, orig_end)
   - (gotp->br_startoff, br_blockcount)表示分配的结果?
   - 如果delay==0, eof==0, 而且上面2个范围覆盖, 表示覆盖已经存在的xfs_bmbt_rec, 直接返回
   - 使(orig_off,orig_end)对extsz对齐,变为(align_off, align_alen)
   - xfs_bmbt_irec->br_startoff的NULLFILEOFF表示什么?? 最大偏移?
   - 获取前一个xfs_bmbt_irec覆盖的范围, 当前分配的文件范围不能和他重叠
   - 如果prev->br_startoff是NULLFILEOFF, 结束范围就是prevo = 0
   - 如果不是, 但它是hole, prevo = br_startoff
   - prev->br_startblock == HOLDSTARTBLOCK,  
   - 否则 prevo = br_startoff + br_blockcount
   - 如果align_off < prevo, 调整align_off = prevo
   - 检查(align_off, align_alen)是否和后面的覆盖??
   - 如果eof ==0, 而且got->br_startoff != NULLFILEOFF, 这个xfs_bmbt_irec是有效的范围
   - 否则nexto是NULLFILEOFF/-1,也就是不用检查
   - 如果它是delay?? delay !=0,而且br_startblock == HOLDSTARTBLOCK
   - 或者是hole? delay ==0, 而且br_startblock == DELAYSTARTBLOCK
   - 表示当前的xfs_bmbt_irec可以覆盖它,设置nexto = br_startoff + br_blockcount
   - 否则不能覆盖, 设置nexto = br_startoff
   - 如果eof ==0, 检查align_off + align_alen > nexto, 调整align_off = nexto - align_alen
   - 最后把(align_off, align_alen)给参数(off, len)

** xfs_bmap_adjacent(xfs_bmalloca)
   - 首先计算xfs_bmalloca->blkno, 表示分配block时开始的磁盘位置
   - 如果为eof分配空间, 而且前面的xfs_bmbt_irec有磁盘空间, xfs_bmalloca->prev 
   - prev->br_startoff != NULLFILEOFF, 文件偏移有效
   - 磁盘空间有效 
   > isnullstartblock(prev->br_startblock)
   - 而且磁盘结束位置没有超过ag
   - 设置blkno = prev->br_startblock + prev->br_blockcount
   - 如果xfs_bmalloca->offset在上面计算的blkno后面,而且没有超过ag边界,也就是有效的
   - 如果不是为eof分配空间, 检查2边的xfs_bmbt_irec, prev/gotp
   - 如果prev的文件偏移和磁盘位置都有效
   - prevbno = prev->br_startoff + prev->br_blockcount
   - 如果prevbno有效, 没有跨ag边界
   - 使用这个磁盘位置分配空间
   - 如果xfs_bmalloca->offset有效,表示文件偏移? 检查它和prev文件偏移的距离
   - adjuest = xfs_bmalloca->offset - prev->br_startoff - prev->br_blockcount
   - 如果偏移不算大 XFS_ALLOC_GAP_UNITS * xfs_bmalloca->length
   - 而且prevbno + prevdiff也可以使用, 没有超过ag边界, 设置prevbno += adjuest
   - 否则设置prevdiff += adjuest ?  这不是翻倍?? 计算文件偏移的距离???
   - 检查后面的xfs_bmbt_irec, 如果startblock有效 
   > isnullstartblock(got->br_startblock)
   - 文件偏移的距离是 
   - got->br_startoff - xfs_bmalloca->offset
   - 如果距离不算太大 XFS_ALLOC_GAP_UNITS * xfs_bmalloca->length, 而且磁盘位置做偏移后也有效
   - ISVALID(br_startblock - ajuest, startblock), 没有跨越ag边界
   - 可以使用的分配地址是br_startblock - adjuest
   - 如果距离太大, 但偏移之后还是有效的磁盘位置, 使用的提示地址是br_blockcount - xfs_bmalloca->length, 距离是adjuest - xfs_bmalloca->length
   - 否则不能移动br_blockcount, 而且是距离翻倍???  gotdiff
   - 最后比较prevdiff和gotdiff, 使用比较小的对应的磁盘位置 
   > prevdiff > gotdiff ? prevbno : gotbno

** xfs_bmap_btalloc_nullfb(xfs_bmalloca, xfs_alloc_arg, xfs_extlen_t blen)
   - 准备xfs_alloc_arg ??
   - 如果xfs_bmalloca->userdata有效,而且是filestream?? 
   > xfs_inode_is_filestream(xfs_inode)
   - 使用XFS_ALLOCTYPE_NEAR_BNO方式分配,否则使用XFS_ALLOCTYPE_START_BNO??
   - xfs_bmalloca->fsbno是有效的??
   > XFS_FSB_TO_AGNO(xfs_mount, xfs_alloc_arg->fsbno)
   - 开始遍历ag?  遍历为了分配blen空间,而且准备足够的ag
   > xfs_perag_get(xfs_mount, ag) 
   - 如果ag没有page free 信息?? 先读上来  
   > xfs_alloc_pagf_init(xfs_mount, xfs_alloc_arg->xfs_trans, ag, XFS_ALLOC_FLAG_TRYLOCK)
   - 检查xfs_perag中最长的连续空间
   > xfs_alloc_longest_free_extent(xfs_mount, xfs_perag) 
   - 使用blen统计最长的空间
   - 如果是filestream?  准备新的ag??
   > xfs_filestream_new_ag(xfs_alloc_arg, xfs_perag)
   - 循环结束的条件是遍历所有的ag, 或者blen超过xfs_alloc_arg->maxlen??
   - 如果没有找到合适的ag, blen < xfs_alloc_arg->minlen 
   - 设置xfs_alloc_arg->minlen = xfs_bmalloca->minlen??
   - 如果找到的足够大的extent, 先使用找到的
   - 设置xfs_alloc_arg->minlen = blen ?
   - 否则设置xfs_alloc_arg->minlen = xfs_alloc_arg->maxlen
   - 这里是为了准备xfs_alloc_arg->minlen?? 

** xfs_bmap_btalloc(xfs_bmalloca)
   - 分配xfs_bmalloc需要的空间
   - 检查是否需要align ? 
   - 使用align调整分配的范围??
   > xfs_bmap_extsize_align(xfs_mount, xfs_bmalloca->got, prev, align, 0, xfs_bmalloca->eof, 0, conv, xfs_bmalloca->offset, xfs_bmalloca->length)
   - 根据xfs_bmalloca->firstblock找到对应的ag, 它可能是NULLFSBLOCK
   - 如果是NULLFSBLOCK, 使用inode的位置作为分配的提示位置
   > XFS_INO_TO_FSB(xfs_mount, xfs_inode->i_ino)
   - 调整磁盘偏移?? xfs_bmalloca->blkno
   - 准备xfs_alloc_arg
   - 设置xfs_trans, xfs_mount
   - 提示磁盘位置fsbno = xfs_bmalloca->blkno
   - maxlen = MIN(xfs_bmalloca->length, XFS_ALLOC_AG_MAX_USABLE(xfs_mount))
   - firstblock = xfs_bmalloca->firstblock ??
   - 如果firstblock是NULLFSBLOCK? 更新minlen?? 
   > xfs_bmap_btalloc_nullfb(xfs_bmalloca, xfs_alloc_arg, blen)
   - 否则如果xfs_bmalloca->xfs_bmap_free->xbf_low !=0 ??
   - 设置xfs_alloc_type 为XFS_ALLOCTYPE_START_BNO??
   - 设置xfs_alloc_arg->total/minlen = xfs_bmalloca->minlen??
   - 否则使用XFS_ALLOCTYPE_NEAR_BNO, total = xfs_bmalloca->total, minlen = xfs_bmalloca->minlen
   - 处理align? xfs_alloc_arg->prod = align
   - 如果xfs_bmalloca->offset % xfs_alloc_arg->prod !=0, 设置mod = prod/align - mod
   - 否则sb_blocksize > PAGE_CACHE_SIZE, 设置prod = 1, mod = 0 ??
   - 否则prod = PAGE_CACHE_SIZE >> sb_blocklog, mod = prod - offset % prod??
   - 如果xfs_bmalloca->xfs_bmap_free->xbf_flow == 0, 而且xfs_bmalloca->aeof !=0, 什么意思?
   - 如果xfs_bmalloca->offset !=0, 不是从文件开头分配??
   - xfs_alloc_arg->alignment = xfs_mount->m_dalign?
   - 设置xfs_alloc_arg->minlen = blen - xfs_alloc_arg->alignment ??
   - 否则从文件开头分配?? 或者文件的第一次分配空间
   - 设置xfs_alloc_type->type = XFS_ALLOCTYPE_THIS_BNO, alignment = 1, tryagain = 1, 失败后会尝试别的??
   - 仔细设置xfs_alloc_arg, 开始分配空间 
   > xfs_alloc_vextent(xfs_alloc_arg)
   - 如果tryagain !=0, 而且没有分配成功, xfs_alloc_arg->fsbno == NULLFSBLOCK 
   - 重新分配
   > xfs_alloc_vextent(xfs_alloc_arg)
   - 如果还没有成功, 而且isalianged ==1, 去掉align条件,重新分配
   - 设置xfs_alloc_arg->alignment = 0
   - 如果还没有成功, 而且xfs_alloc_arg->minlen > xfs_bmalloca->minlen
   - 使用XFS_ALLOCTYPE_START_BNO方式 
   - 如果还没有成功,而且是nullfb??
   - 使用XFS_ALLOCTYPE_FIRST_AG,  total = xfs_bmalloca->minlen ??
   - 如果分配成功, xfs_bmalloca->blkno = xfs_alloc_arg->fsbno
   - 如果xfs_bmalloca->firstblock == NULLFSBLOCK, 设置他为fsbno
   - xfs_bmalloca->length = xfs_alloc_arg->len
   - 增加xfs_inode->xfs_icdinode->id_nblocks += xfs_alloc_arg->len 
   - log inode, 因为修改了nblock??
   > xfs_trans_log_inode(xfs_trans, xfs_inode, XFS_ILOG_CORE)

** xfs_bmap_alloc(xfs_bmalloca)
   > xfs_bmap_btalloc(xfs_bmalloca)

** xfs_bmapi_trim_map(xfs_bmbt_irec val, xfs_bmbt_irec got, xfs_fileoff_t bno, xfs_filblks_t len, xfs_fileoff_t obno, xfs_fileoff_t end, n, flags)
   - 参数都什么意义??
   - 如果flags有XFS_BMAPI_ENTIRE, 或者got的文件偏移在bono之前
   > br_startoff + br_blockcount  < obno
   - 不用trim? 把got给val?? 如果got没有磁盘空间,设置val->br_startblock = DELAYSTARTBLOCK
   - 设置val->br_startoff = obno
   - 如果got->br_startblock不是有效的, 设置br_blockcount = DELAYSTARTBLOCK
   - 否则需要对磁盘位置做偏移? 
   - val->br_startblock = got->br_startblock + bno - got->br_startoff
   - 长度需要考虑(bno, end), got的长度 
   - XFS_FILBLKS_MIN(en - bno, got->br_blockcount - (bno - got->br_startoff))
   - state使用got->br_state

** xfs_bmapi_update_map(xfs_bmbt_irec map, xfs_fileoff_t bno, xfs_filblks_t len, xfs_fileoff_t bono, xfs_fileoff_t end, n, flags)
   - 首先检查参数
   - val范围必须在end之前?? val不能超过(obno, len)
   - 计算val后面的范围?? 
   - (bno, len) = (br_startoff+br_blockcount, end - bno)
   - 如果n>0, val->br_startoff == val[-1]->br_startoff ? 和前面的范围重叠??
   - 如果n>0, val->br_blockcount != DELAYSTARTBLOCK, 而且前一个xfs_bmbt_irec的磁盘空间有效
   - val[-1]->br_startblock 不是DELAYSTARTBLOCK, HOLDSTARTBLOCK
   - 而且他的磁盘位置和val临接, flags有XFS_BMAPI_IGSTATE, 文件偏移肯定也临接
   - 更新val[-1]->br_blockcount += val->br_blockcount
   - 如果n>0, 而且val和前面的xfs_bmbt_irec都是DELAYSTARTBLOCK, 而且文件偏移挨着, 合并2个xfs_bmbt_irec
   - 更新val[-1]->br_blockcount, br_state
   - 最后n!=0或者val的文件偏移没超过obno?? 向前移动val, n 

** xfs_bmapi_read(xfs_inode, xfs_fileoff_t bno, xfs_filblks_t len, xfs_bmbt_irec val, nmap, flags)
   - 处理xfs_bmbt_irec数组?? 数组长度是nmap
   - 根据flags计算xfs_ifork
   - flags有XFS_BMAPI_ATTRFORK就是XFS_ATTR_FORK, 否则就是XFS_DATA_FORK 
   > XFS_IFORK_PTR(xfs_inode, whichfork)
   - 如果xfs_ifork->if_flags没有XFS_IFEXTENTS,先读取xfs_bmbt_rec数据 
   > xfs_iread_extents(NULL, xfs_inode, whichfork)
   - 根据bno查找xfs_bmbt_irec 
   > xfs_bmap_search_extents(xfs_inode, bno, whichfork, eof, lastx, xfs_bmbt_irec, prev) 
   - 然后查找(bno, len)范围内的xfs_bmbt_irec, 放到参数(val, nmap)中??
   - trim?? 可能会合并??
   > xfs_bmapi_trim_map(val, xfs_bmbt_irec got, bno, len, obno, end, nflags)
   - 更新什么??  bno会向后移动??
   > xfs_bmapi_update_map(val, bno, len, obno, end, n, flags)
   - 如果xfs_bmbt_irec->br_startoff > bno, 中间有hole, 同样也创建一个xfs_ifork中没有的 
   - (bno, HOLESTARTBLOCK, br_startoff-bno, XFS_EXT_NORM)
   - 对于hole, state竟然是XFS_EXT_NORM
   - 然后向前移动xfs_bmbt_irec 
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, lastx), xfs_bmbt_irec)

** xfs_bmap_reserve_delalloc(xfs_inode, xfs_fileoff_t aoff, xfs_filblks_t len, xfs_bmbt_irec got, xfs_bmbt_irec prev, xfs_extnum_t lastx, eof)
   - delay allocation时的预留空间??
   - 先计算alen?  XFS_FILBLKS_MIN(len, MAXEXTLEN, got->br_startoff - aoff)
   - 计算extent长度的默认值?? 
   > xfs_get_extsz_hint(xfs_inode)
   - 使用他调整分配长度?? 
   > xfs_bmap_extsize_align(xfs_mount, got, prev, extsz, rt, eof, 1, 0, aoff, alen) 
   - 计算indlen?? 
   > xfs_bmap_worst_indlen(xfs_inode, alen)
   - 修改计数XFS_SBS_FDBLOCKS?? 这时预留空间?? 
   > xfs_icsb_modify_counters(xfs_mount, XFS_SBS_FDBLOCKS, -alen, 0)
   - 还有indlen? 
   > xfs_icsb_modify_counters(xfs_mount, XFS_SBS_FDBLOCKS, -indlen, 0)
   - 增加xfs_inode->i_delayed_blks += alen
   - 设置got的信息?? 
   - (aoff, nullstartblock(indlen), alen, XFS_EXT_NORM) 
   - 然后插入xfs_bmbt_rec_host ? 
   > xfs_bmap_add_extent_hole_delay(xfs_inode, lastx, got)
   - 检查插入结果?? 
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, lastx), got)
   
** xfs_bmapi_delay(xfs_inode, xfs_fileoff_t bno, xfs_filblks_t len, xfs_bmbt_irec val, nmap, flags)
   - 首先检查xfs_bmbt_rec是否已经缓存到xfs_ifork中, xfs_ifork->if_flags没有XFS_IFEXTENTS
   > xfs_iread_extents(NULL, xfs_inode, XFS_DATA_FORK)
   - 根据bno查找xfs_bmbt_rec_host 
   > xfs_bmap_search_extents(xfs_inode, bno, XFS_DATA_FORK, eof, lastx, xfs_bmbt_irec got, prev)
   - 遍历xfs_bmbt_rec_host, 查找覆盖(bno, len)的
   - 如果xfs_bmbt_irec->br_startoff > bno, 有一个hole的extent 
   > xfs_bmapi_reserve_delalloc(xfs_inode, bno, len, xfs_bmbt_irec got, prev, lastx, eof)
   - 把它放到参数中 
   > xfs_bmapi_trim_map(xfs_bmbt_irec, got, bno, len, obno, end, n, flags)
   > xfs_bmapi_update_map(xfs_bmbt_irec val, bno, len, obno, end, n, flags)
   - 获取下一个xfs_bmbt_rec_host 
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, lastx), got)

   
** __xfs_bmapi_allocate(xfs_bmalloca)
   - 根据xfs_bmalloca->flags判断分配data fork, 还是attr fork
   - 获取xfs_ifork
   - 如果xfs_bmalloca->wasdel !=0, 按照xfs_bmalloca->got分配空间
   - (length, offset) = (got->br_blockcount, br_startoff)
   - 如果xfs_bmalloca->idx >0, 获取前一个xfs_bmbt_irec 
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, idx-1), xfs_bmalloca->prev)
   - 如果不是delay allocation?? 需要计算分配长度
   - XFS_FILBLKS_MIN(xfs_bmalloca->length, MAXEXTLEN)
   - xfs_bmalloca->eof ==0, length不能超过got->br_startoff - offset
   - 不能和got指向的xfs_bmbt_irec重叠??
   - 如果bmalloca->flags没有XFS_BMAPI_METADATA, 设置xfs_bmalloca->userdata
   - 如果offset ==0, 设置为XFS_ALLOC_INITIAL_USER_DATA,否则是XFS_ALLOC_USERDATA
   - 如果xfs_bmalloca->flags有XFS_BMAPI_CONTIG, 设置minlen = length, 否则为1. 这里分配的单位是fsb??
   - 检查是否需要对齐分配  xfs_mount->m_dalign > 0
   - 如果是分配userdata xfs_bmalloca->flags没有XFS_BMAPI_METADATA, 而且whichfork是XFS_DATA_FORK
   - 而且xfs_bmalloca->length > xfs_mount->m_dalign 
   > xfs_bmap_isaeof(xfs_bmalloca, whichfork)
   - 分配空间  
   > xfs_bmap_alloc(xfs_bmalloca)
   - 设置xfs_btree_cur->bc_private->b_firstblock = xfs_bmalloca->firstblock?? 为什么??
   - 如果没有分配空间, xfs_bmalloca->blkno == NULLFSBLOCK, 直接返回?
   - 如果xfs_ifork->if_flags有XFS_IFBROOT? 而且xfs_bmalloca->cur ==NULL?? 需要补充btree操作??
   - 准备xfs_btree_cur? 
   > xfs_bmbt_init_cursor(xfs_mount, xfs_bmalloca->xfs_trans, xfs_inode, whichfork)
   - 设置xfs_btree_cur->bc_private->b_firstblock = xfs_bmalloca->firstblock, xfs_bmap_free
   - 增加xfs_bmalloca->nallocs ??
   - 把分配的空间给xfs_bmalloca->got
   - (offset, length, blkno, XFS_EXT_NORM) -> (br_startoff, br_blockcount, br_startblock, br_state)
   - 如果xfs_bmalloca->wasdel ==0, 而且xfs_bmalloca->flags有XFS_BMAPI_PREALLOC, 这是pre-allocation
   - 设置got->br_state = XFS_EXT_UNWRITTEN
   - 把新的xfs_bmbt_irec写回xfs_ifork/btree 
   - 如果xfs_bmalloca->wasdel !=0 
   > xfs_bmap_add_extent_delay_real(xfs_bmalloca)
   - 否则写回hole?? 
   > xfs_bmap_add_extent_hole_real(xfs_bmalloca, whichfork)
   - 重新获取对应的xfs_bmbt_irec 
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, idx), xfs_bmalloca->got)

** xfs_bmapi_allocate_worker(work_struct)
   - 使用workqueue去分配空间?? 
   - work_struct是xfs_bmalloca->work 
   > __xfs_bmapi_allocate(xfs_bmalloca)
   - 唤醒等待的任务 
   > complete(xfs_bmalloca->done)

** xfs_bmapi_allocate(xfs_bmalloca)
   - 如果xfs_bmalloca->stack_switch ==0?? 直接分配空间 
   > __xfs_bmapi_allocate(xfs_bmalloca)
   - 否则使用xfs_alloc_wq 
   > queue_work(xfs_alloc_wq, xfs_bmalloca->work)
   - 等待分配完成, 为何不刷新workqueue?  

** xfs_bmapi_convert_unwritten(xfs_bmalloca, xfs_bmbt_irec, xfs_filblks_t, flags)
   - 如果xfs_bmbt_irec是XFS_EXT_UNWRITTEN, 而且flags有XFS_BMAPI_PREALLOC?? 直接返回  unwritten -> real??
   - 如果是XFS_EXT_NORM, 而且flags不是XFS_BMAPI_PREALLOC|XFS_BMAPI_CONVERT?? 直接返回 real->unwritten ??
   - 如果xfs_ifork->if_flags是XFS_IFBROOT, 表示磁盘中使用btree存储数据?? 准备xfs_btree_cur  
   > xfs_bmbt_init_cursor(xfs_mount, xfs_trans, xfs_inode, whichfork)
   - 设置xfs_btree_cur->bc_private->b->xfs_bmap_free = xfs_bmalloca->firstblock, xfs_bmap_free? 哪里使用??
   - 重新计算xfs_bmbt_irec
   - 如果原来是XFS_EXT_UNWRITTEN, 变为XFS_EXT_NORM, 否则变为XFS_EXT_UNWRITTEN??
   - 处理xfs_ifork/btree?
   > xfs_bmap_add_extent_unwritten_real(xfs_trans, xfs_inode, idx, xfs_btree_cur, xfs_bmbt_irec, firstblock, xfs_bmap_free, logflags)
   - 需要把上面计算的logflags收集到xfs_bmalloca->logflags 

** xfs_bmapi_write(xfs_trans, xfs_inode, xfs_fileoff_t bno, xfs_filblks_t len, flags, xfs_fsblock_t firstblock, xfs_extlen_t total, xfs_bmbt_irec val, nmap, xfs_bmap_free flist)
   - 把xfs_bmbt_irec写回磁盘? 作相应的转化?
   - flags不能有XFS_BMAPI_IGSTATE?
   - 如果firstblock == NULLFSBLOCK? 计算xfs_bmalloc->minleft, 否则设置为0
   - 如果xfs_ifork使用XFS_DINODE_FMT_BTREE存储数据, 设置xfs_bmalloca->minleft = xfs_btree_block->bb_level +1?
   - 否则设置为1
   - 如果xfs_ifork还没有缓存磁盘的xfs_bmbt_rec, 读取数据, xfs_ifork->if_flags没有XFS_IFEXTENTS
   > xfs_iread_extents(xfs_trans, xfs_inode, whichfork)
   - 查找bno对应的xfs_bmbt_irec 
   > xfs_bmap_search_extents(xfs_inode, bno, whichfork, eof, xfs_bmalloca->idx, xfs_bmalloca->got, xfs_bmalloca->prev)
   - 准备xfs_bmalloca, 使用参数的(xfs_bmap_free, firstblock)
   - 如果flags有XFS_BMAPI_STACK_SWITCH, 设置xfs_bmalloca->stack_switch = 1 ??
   - 遍历(bno, len)的范围, 处理它所覆盖的xfs_bmbt_rec_host?
   - 如果eof!=0, 或者got->br_startoff > bno, 表示存在一个hole?
   - 如果不是hole, 但got->br_startblock无效, 这是delay allocation? 
   > isnullstartblock(got->br_startblock)
   - 如果是hole或者delalloc, 创建xfs_bmbt_irec?
   - 设置xfs_bmalloca的eof/conv/wasdel/offset/flags/length 
   > xfs_bmapi_allocate(xfs_bmalloca)
   - 处理分配的结果??
   > xfs_bmapi_trim_map(val, got, bno, len, obno, end, n, flags)
   - 修改xfs_ifork/btree
   > xfs_bmapi_convert_unwritten(xfs_bmalloca, val, len, flags)
   - 把结果放到参数中??
   > xfs_bmapi_update_map(val, bno, len, obno, end, n, flags)
   - 处理下一个xfs_bmbt_rec_host 
   > xfs_bmbt_get_all(xfs_iext_get_ext(xfs_ifork, idx), xfs_bmalloca->got)
   - 检查di_format/di_aformat是否需要转化?? 
   > xfs_bmap_wants_extents(xfs_inode, whichfork)
   > xfs_bmap_btree_to_extents(xfs_trans, xfs_inode, xfs_btree_cur, tmp_logflags, whichfork)
   - 把上面的操作记录到log中
   - 检查xfs_bmalloca->logflags?? XFS_ILOG_DEXT/XFS_ILOG_AEXT
   > xfs_ilog_fext(whichfork)
   - 如果format不是XFS_DINODE_FMT_EXTENTS? 去掉对应的log?
   - 检查log_flags的XFS_ILOG_DBROOT/XFS_ILOG_ABROOT, format必须是XFS_DINODE_FMT_BTREE
   > xfs_trans_log_inode(xfs_trans, xfs_inode, xfs_bmalloca->logflags)
   - 更新firstblock, 设置为xfs_bmalloca->xfs_btree_cur->bc_private->b->firstblock

** xfs_bmap_del_extent(xfs_inode, xfs_trans, xfs_extnum_t idx, xfs_bmap_free, xfs_btree_cur, xfs_bmbt_irec del, logflags, whichfork)
   - 更新或删除xfs_bmbt_irec?
   - 首先获取idx对应的xfs_bmbt_irec 
   > xfs_iext_get_ext(xfs_ifork, idx)
   > xfs_bmbt_get_all(xfs_bmbt_rec_host, got)
   - got必须覆盖del对应的xfs_bmbt_irec?
   - 如果got是delay allocation, 它的磁盘空间无效 
   > isnullstartblock(got->br_startblock)
   - del也必须是delay allocation
   - 如果delay ==0, got不是delay allocation
   - 删除一个磁盘的xfs_bmbt_rec, 需要释放磁盘空间 
   - 查找对应的xfs_bmbt_rec 
   > xfs_bmbmt_lookup_eq(xfs_btree_cur, got->br_startoff, got->br_startblock, got->br_blockcount, i)
   - 如果delay !=0, 不需要删除磁盘空间
   - 根据del和got的范围操作xfs_bmbt_rec
   - 如果完全重叠, 直接删除xfs_bmbt_rec_host 
   > xfs_iext_remove(xfs_inode, idx, 1, BMAP_ATTRFORK / 0)
   - 如果delay ==0, 还要删除磁盘的xfs_bmbt_rec 
   > xfs_btree_delete(xfs_btree_cur, i)
   - 修改xfs_inode->xfs_icdinode->di_nextents 
   > XFS_IFORK_NEXT_SET(xfs_inode, whichfork, XFS_IFORK_NEXTENTS(xfs_inode, whichfork) - 1)
   - 设置flags的XFS_ILOG_CORE,如果这里没有xfs_btree_cur? 不需要操作btree, 但需要操作xfs_dinode? 设置对应的标志 
   > xfs_ilog_fext(whichfork)
   - 如果是start一样,但end不一样, 只需要修改xfs_bmbt_rec_host?
   > xfs_bmbt_set_startoff(xfs_bmbt_rec_host, del->br_startoff + del->br_blockcount)
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, got->br_blockcount - del->br_blockcount)
   - 如果delay !=0, 还需要修改startblock 
   > xfs_bmap_worst_indlen(xfs_inode, tmp)
   > xfs_bmbt_set_startblock(xfs_bmbmt_rec_host, nullstartblock(tmp))
   - 如果delay ==0, 需要修改磁盘位置 
   > xfs_bmbt_set_startblock(xfs_bmbt_rec_host, del->br_startblock + del->br_blockcount)
   - 而且修改对应的btree节点 
   - 如果xfs_btree_cur == NULL, 只需要再后面log对应的xfs_dinode 
   > xfs_ilog_fext(whichfork)
   - 否则直接修改btree 
   > xfs_bmbt_update(xfs_btree_cur, del->br_startoff + br_blockcount, del->br_blockcount + br_blockcount, got->br_blockcount - del->br_blockcount, got->br_state)
   - 如果是end一样,start不一样, 做类似的修改
   - 对于xfs_bmbt_rec_host, 修改br_blockcount 
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, got->br_blockcount - del->br_blockcount)
   - 如果delay ==0, 只需要再修改xfs_bmbt_rec_host->br_startblock 
   > xfs_bmap_worst_indlen(xfs_inode, temp)
   > xfs_bmbt_set_startblock(xfs_bmbt_rec_host, nullstartblock(tmp))
   - 否则还需要修改btree 
   > xfs_bmbt_update(xfs_btree_cur, got->br_startoff, got->br_startblock, got->br_blockcount - del->br_blockcount, got->br_state)
   - 如果start和end都不一样,需要把got分成3段, 创建新的xfs_bmbt_rec_host
   - 首先更新第一段 
   > xfs_bmbt_set_blockcount(xfs_bmbt_rec_host, del->br_startoff - got->br_startoff)
   - 如果delay ==0, 需要修改btree的xfs_bmbt_rec 
   - 先修改第一部分的blockcount
   > xfs_bmbmt_update(xfs_btree_cur, got->br_startoff, ...)
   - 然后插入第三部分
   > xfs_btree_increment(xfs_btree_cur, i)
   - xfs_btree_cur->bc_rec->xfs_bmbt_irec = new
   > xfs_btree_insert(xfs_btree_cur, i)
   - 增加xfs_icdinode->di_nextents
   - 如果delay !=0, 不需要btree操作,只需要计算2部分的startblock 
   - 他们不是真正的磁盘空间,而是一些分配磁盘的辅助信息 
   - 第一部分
   > xfs_bmap_worst_indlen(xfs_inode, temp)
   > xfs_bmbt_set_startblock(xfs_bmbt_rec_host, nullstartblock(temp))
   - 第三部分做同样的处理
   - 把第三部分的xfs_bmbt_irec放到xfs_ifork中
   > xfs_iext_insert(xfs_inode, idx+1, 1, xfs_bmbmt_irec, state)
   - 修改xfs_inode->xfs_icdinode->di_nblocks -= nblks
   - 这里还要释放相关的磁盘空间 
   > xfs_bmap_add_free(del->br_startblock, del->br_blockcount, xfs_bmap_free, xfs_mount)

** xfs_bunmap(xfs_trans, xfs_inode, xfs_fileoff_t bno, xfs_filblks_t len, flags, xfs_extnum_t nexts, xfs_fsblock_t firstblock, xfs_bmap_free flist, done)
   - 获取对应的xfs_ifork, 准备xfs_bmbt_rec_host信息 
   > xfs_iread_extents(xfs_trans, xfs_inode, whichfork)
   - 如果没有xfs_bmbt_rec信息,直接返回??
   - 处理(bno, len)范围内的xfs_bmbt_rec_host
   - 如果参数nexts有效,处理的个数收到限制
   - 设置bno为范围终点 bno+len
   - 查找最后一个xfs_bmbt_irec
   > xfs_bmap_search_extents(xfs_inode, bno, whichfork, eof, lastx, got, prev)
   - 如果eof !=0, 根据xfs_bmbt_irec更新bno
   - 如果xfs_ifork->if_flags有XFS_IFBROOT, 说明磁盘使用btree储存fork信息, 准备xfs_btree_cur
   - 开始循环处理所有的xfs_bmbt_irec 
   > xfs_iext_get_ext(xfs_ifork, lastx)
   > xfs_bmbt_get_all(xfs_bmbt_rec_host, xfs_bmbt_irec)
   - 首先它的范围必须和参数范围有交叉, end > start
   - 如果是交叉, 创建一个临时的xfs_bmbt_irec, 使用参数的范围设置
   - 否则可以使用查找的xfs_bmbt_irec
   - 如果这个xfs_bmbt_irec是delay allocation, 释放预留的磁盘空间? 
   > xfs_icsb_modify_counters(xfs_mount, XFS_SBS_FDBLOCKS, del->br_blockcount, 0)
   - 减小xfs_inode->i_delayed_blks -= del->br_blockcount
   - 删除对应的xfs_bmbt_irec 
   > xfs_bmap_del_extent(xfs_inode, xfs_trans, lastx, xfs_bmap_free, xfs_btree_cur, xfs_bmbt_irec, mtp_logflags, whichfork)
   - 循环完成后,检查di_format/di_aformat是否需要转化 
   > xfs_bmap_needs_btree(xfs_inode, whichfork)
   > xfs_bmap_extents_to_btree(xfs_trans, xfs_inode, firstblock, xfs_bmap_free, xfs_btree_cur, 0, tmp_logflags, whichfork)
   - 这里还得检查是否从btree转到extents 
   > xfs_bmap_wants_extents(xfs_inode, whichfork)
   > xfs_bmap_btree_to_extents(xfs_trans, xfs_inode, xfs_btree_cur, tmp_logflags, whichfork)
   - 最后log处理 
   > xfs_trans_log_inode(xfs_trans, xfs_inode, logflags)

** getbmapx 
   #+BEGIN_SRC 
	__s64		bmv_offset;	/* file offset of segment in blocks */
	__s64		bmv_block;	/* starting block (64-bit daddr_t)  */
	__s64		bmv_length;	/* length of segment, blocks	    */
	__s32		bmv_count;	/* # of entries in array incl. 1st  */
	__s32		bmv_entries;	/* # of entries filled in (output). */
	__s32		bmv_iflags;	/* input flags (1st structure)	    */
	__s32		bmv_oflags;	/* output flags (after 1st structure)*/
	__s32		bmv_unused1;	/* future use			    */
	__s32		bmv_unused2;	/* future use			    */   
   #+END_SRC

** xfs_getbmapx_fix_eof_hole(xfs_inode, getbmapx, preallocated, end, startblock)
   - getbmap是什么操作??
   - 如果startblock == HOLESTARTBLOCK
   - 设置getbmapx->bmv_block = -1
   - 如果preallocated !=0, 而且bmv_offset + bmv_length超过文件大小
   > XFS_FSB_TO_BB(xfs_mount, XFS_B_TO_FSB(xfs_mount, XFS_ISIZE(xfs_inode))) 
   - 更新bmv_length = end - bmv_offset
   - 如果startblock是DELAYSTARTBLOCK, 设置bmv_block = -2
   - 否则设置为实际的磁盘大小??
   > xfs_fsb_to_db(xfs_inode, startblock)
   
** xfs_getbmap(xfs_inode, getbmapx, xfs_bmap_format, arg)
   - 根据getbmapx->bmv_iflags计算操作的fork
   - 如果有BMV_IF_ATTRFORK, 就是XFS_ATTR_FORK, 否则是XFS_DATA_FORK
   - 根据文件属性重新计算getbmapx->bmv_length
   - 锁住inode 
   > xfs_ilock(xfs_inode, XFS_IOLOCK_SHARED)
   - 写回数据 
   > filmap_write_and_wait(xfs_inode->address_space)
   > xfs_ilock_map_shared(xfs_inode)
   - 遍历getbmap范围内的xfs_bmbt_irec
   > xfs_bmapi_read(xfs_inode, XFS_BB_TO_FSB(xfs_mount, getbmapx->bmv_offset), XFS_BB_TO_FSB(xfs_mount, getbmapx->bmv_length), xfs_bmbt_irec, nmap, bmapi_flags)
   - 把数据放到getbmapx中
   - 最后使用回调函数放到args中 
   > xfs_bmap_format(arg, getbmapx, full)

** xfs_bmap_punch_delalloc_range(xfs_inode, xfs_fileoff_t start_fsb, xfs_fileoff_t length)
   - 遍历(start_fsb, length)范围内的xfs_bmbt_rec_host 
   > xfs_bmapi_read(xfs_inode, start_fsb, 1, xfs_bmbt_irec, nmaps, XFS_BMAPI_ENTIRE)
   - 如果不是delay allocation ?? 直接跳过??
   > xfs_bmbt_irec->br_startblock  != DELAYSTARTBLOCK
   - 那还释放什么?? 
   > xfs_bunmapi(NULL, xfs_inode, start_fsb, 1, 0, 1, firstblock, xfs_bmap_free, done)
