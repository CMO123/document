* xfs_entent_busy.c

** xfs_extent_busy 
   #+begin_src 
	struct rb_node	rb_node;	/* ag by-bno indexed search tree */
	struct list_head list;		/* transaction busy extent list */
	xfs_agnumber_t	agno;
	xfs_agblock_t	bno;
	xfs_extlen_t	length;
	unsigned int	flags;
#define XFS_EXTENT_BUSY_DISCARDED	0x01	/* undergoing a discard op. */
#define XFS_EXTENT_BUSY_SKIP_DISCARD	0x02	/* do not discard */
   #+end_src

** 总结
   - 使用rb_tree管理已经给alloc_group释放,但没有提交到btree中的extent.  
   - rb_root是xfs_perag->pagb_tree.使用xfs_extent_busy->bno索引.
   - xfs_extent_busy->list是xfs_perag->t_busy
   - 在ag释放extent时,创建xfs_extent_busy管理空闲空间
   - 分配metadata空间时,可以复用xfs_extent_busy的空间.
   - 在分配data空间时,在btree上找到后,需要过滤掉xfs_busy_extent的空间.也就是data不能使用这种空间.
   - 在分配data空间时,如果btree中没有空间,而且free_list有空间,使用xfs_extent_busy去结束log什么的??能回收空间吗?



* xfs_aops.c 

** io flags
   #+begin_src 
	XFS_IO_DIRECT = 0,	/* special case for direct I/O ioends */
	XFS_IO_DELALLOC,	/* covers delalloc region */
	XFS_IO_UNWRITTEN,	/* covers allocated but uninitialized data */
	XFS_IO_OVERWRITE,	/* covers already allocated extent */
   #+end_src

** xfs_ioend 
   #+begin_src 
	struct xfs_ioend	*io_list;	/* next ioend in chain */
	unsigned int		io_type;	/* delalloc / unwritten */
	int			io_error;	/* I/O error code */
	atomic_t		io_remaining;	/* hold count */
	unsigned int		io_isasync : 1;	/* needs aio_complete */
	unsigned int		io_isdirect : 1;/* direct I/O */
	struct inode		*io_inode;	/* file being written to */
	struct buffer_head	*io_buffer_head;/* buffer linked list head */
	struct buffer_head	*io_buffer_tail;/* buffer linked list tail */
	size_t			io_size;	/* size of the extent */
	xfs_off_t		io_offset;	/* offset in the file */
	struct work_struct	io_work;	/* xfsdatad work queue */
	struct xfs_trans	*io_append_trans;/* xact. for size update */
	struct kiocb		*io_iocb;
	int			io_result;
   #+end_src

** 总结
   - xfs_ioend关联kio? 在释放xfs_ioend时唤醒它的kiocb等待的任务.
   - 使用buffer_head实现IO,使用buffer_head的状态管理hole/delalloc/prealloc等.

