* xfs_dinode.h

** di_flags
   #+begin_src 
#define XFS_DIFLAG_REALTIME_BIT  0	/* file's blocks come from rt area */
#define XFS_DIFLAG_PREALLOC_BIT  1	/* file space has been preallocated */
#define XFS_DIFLAG_NEWRTBM_BIT   2	/* for rtbitmap inode, new format */
#define XFS_DIFLAG_IMMUTABLE_BIT 3	/* inode is immutable */
#define XFS_DIFLAG_APPEND_BIT    4	/* inode is append-only */
#define XFS_DIFLAG_SYNC_BIT      5	/* inode is written synchronously */
#define XFS_DIFLAG_NOATIME_BIT   6	/* do not update atime */
#define XFS_DIFLAG_NODUMP_BIT    7	/* do not dump */
#define XFS_DIFLAG_RTINHERIT_BIT 8	/* create with realtime bit set */
#define XFS_DIFLAG_PROJINHERIT_BIT   9	/* create with parents projid */
#define XFS_DIFLAG_NOSYMLINKS_BIT   10	/* disallow symlink creation */
#define XFS_DIFLAG_EXTSIZE_BIT      11	/* inode extent size allocator hint */
#define XFS_DIFLAG_EXTSZINHERIT_BIT 12	/* inherit inode extent size */
#define XFS_DIFLAG_NODEFRAG_BIT     13	/* do not reorganize/defragment */
#define XFS_DIFLAG_FILESTREAM_BIT   14  /* use filestream allocator */
   
   #+end_src

** xfs_dinode
   #+begin_src 
	__be16		di_magic;	/* inode magic # = XFS_DINODE_MAGIC */
	__be16		di_mode;	/* mode and type of file */
	__u8		di_version;	/* inode version */
	__u8		di_format;	/* format of di_c data */
	__be16		di_onlink;	/* old number of links to file */
	__be32		di_uid;		/* owner's user id */
	__be32		di_gid;		/* owner's group id */
	__be32		di_nlink;	/* number of links to file */
	__be16		di_projid_lo;	/* lower part of owner's project id */
	__be16		di_projid_hi;	/* higher part owner's project id */
	__u8		di_pad[6];	/* unused, zeroed space */
	__be16		di_flushiter;	/* incremented on flush */
	xfs_timestamp_t	di_atime;	/* time last accessed */
	xfs_timestamp_t	di_mtime;	/* time last modified */
	xfs_timestamp_t	di_ctime;	/* time created/inode modified */
	__be64		di_size;	/* number of bytes in file */
	__be64		di_nblocks;	/* # of direct & btree blocks used */
	__be32		di_extsize;	/* basic/minimum extent size for file */
	__be32		di_nextents;	/* number of extents in data fork */
	__be16		di_anextents;	/* number of extents in attribute fork*/
	__u8		di_forkoff;	/* attr fork offs, <<3 for 64b align */
	__s8		di_aformat;	/* format of attr fork's data */
	__be32		di_dmevmask;	/* DMIG event mask */
	__be16		di_dmstate;	/* DMIG state info */
	__be16		di_flags;	/* random flags, XFS_DIFLAG_... */
	__be32		di_gen;		/* generation number */

	/* di_next_unlinked is the only non-core field in the old dinode */
	__be32		di_next_unlinked;/* agi unlinked list ptr */

	/* start of the extended dinode, writable fields */
	__le32		di_crc;		/* CRC of the inode */
	__be64		di_changecount;	/* number of attribute changes */
	__be64		di_lsn;		/* flush sequence */
	__be64		di_flags2;	/* more random flags */
	__u8		di_pad2[16];	/* more padding for future expansion */

	/* fields only written to during inode creation */
	xfs_timestamp_t	di_crtime;	/* time created */
	__be64		di_ino;		/* inode number */
	uuid_t		di_uuid;	/* UUID of the filesystem */

	/* structure must be padded to 64 bit alignment */
   #+end_src
   -在磁盘中,inode后面还有2块数据di_u, di_a, 他们的内容根据di_format/di_aformat而定.

** di_format 
   #+BEGIN_SRC 
	XFS_DINODE_FMT_DEV,		/* xfs_dev_t */
	XFS_DINODE_FMT_LOCAL,		/* bulk data */
	XFS_DINODE_FMT_EXTENTS,		/* struct xfs_bmbt_rec */
	XFS_DINODE_FMT_BTREE,		/* struct xfs_bmdr_block */
	XFS_DINODE_FMT_UUID		/* uuid_t */   
   #+END_SRC

** di_flag
   #+BEGIN_SRC 
 */
#define XFS_DIFLAG_REALTIME_BIT  0	/* file's blocks come from rt area */
#define XFS_DIFLAG_PREALLOC_BIT  1	/* file space has been preallocated */
#define XFS_DIFLAG_NEWRTBM_BIT   2	/* for rtbitmap inode, new format */
#define XFS_DIFLAG_IMMUTABLE_BIT 3	/* inode is immutable */
#define XFS_DIFLAG_APPEND_BIT    4	/* inode is append-only */
#define XFS_DIFLAG_SYNC_BIT      5	/* inode is written synchronously */
#define XFS_DIFLAG_NOATIME_BIT   6	/* do not update atime */
#define XFS_DIFLAG_NODUMP_BIT    7	/* do not dump */
#define XFS_DIFLAG_RTINHERIT_BIT 8	/* create with realtime bit set */
#define XFS_DIFLAG_PROJINHERIT_BIT   9	/* create with parents projid */
#define XFS_DIFLAG_NOSYMLINKS_BIT   10	/* disallow symlink creation */
#define XFS_DIFLAG_EXTSIZE_BIT      11	/* inode extent size allocator hint */
#define XFS_DIFLAG_EXTSZINHERIT_BIT 12	/* inherit inode extent size */
#define XFS_DIFLAG_NODEFRAG_BIT     13	/* do not reorganize/defragment */   
   #+END_SRC

** xfs_icdinode
   - inode在磁盘上的格式
   #+begin_src 
	__uint16_t	di_magic;	/* inode magic # = XFS_DINODE_MAGIC */
	__uint16_t	di_mode;	/* mode and type of file */
	__int8_t	di_version;	/* inode version */

	__int8_t	di_format;	/* format of di_c data */  //对于不同的文件类型(di_mode),解析不一样, 表示inode后面数据的内容
	__uint16_t	di_onlink;	/* old number of links to file */
	__uint32_t	di_uid;		/* owner's user id */
	__uint32_t	di_gid;		/* owner's group id */
	__uint32_t	di_nlink;	/* number of links to file */
	__uint16_t	di_projid_lo;	/* lower part of owner's project id */
	__uint16_t	di_projid_hi;	/* higher part of owner's project id */
	__uint8_t	di_pad[6];	/* unused, zeroed space */
	__uint16_t	di_flushiter;	/* incremented on flush */
	xfs_ictimestamp_t di_atime;	/* time last accessed */
	xfs_ictimestamp_t di_mtime;	/* time last modified */
	xfs_ictimestamp_t di_ctime;	/* time created/inode modified */
	xfs_fsize_t	di_size;	/* number of bytes in file */  //eof
	xfs_drfsbno_t	di_nblocks;	/* # of direct & btree blocks used */
	xfs_extlen_t	di_extsize;	/* basic/minimum extent size for file */  //extent应该不受限制,这是最小限制?? 或者最小的磁盘分配空间
	xfs_extnum_t	di_nextents;	/* number of extents in data fork */
	xfs_aextnum_t	di_anextents;	/* number of extents in attribute fork*/  //为什么属性也需要exetnt?
	__uint8_t	di_forkoff;	/* attr fork offs, <<3 for 64b align */
	__int8_t	di_aformat;	/* format of attr fork's data */ //和di_format一样
	__uint32_t	di_dmevmask;	/* DMIG event mask */
	__uint16_t	di_dmstate;	/* DMIG state info */
	__uint16_t	di_flags;	/* random flags, XFS_DIFLAG_... */
	__uint32_t	di_gen;		/* generation number */

	/* di_next_unlinked is the only non-core field in the old dinode */
	xfs_agino_t	di_next_unlinked;/* agi unlinked list ptr */

        //di_aformat表示extent data attribute数据的位置,偏移相对于di_crc开始, 好像是0x64
	/* start of the extended dinode, writable fields */
	__uint32_t	di_crc;		/* CRC of the inode */
	__uint64_t	di_changecount;	/* number of attribute changes */
	xfs_lsn_t	di_lsn;		/* flush sequence */
	__uint64_t	di_flags2;	/* more random flags */
	__uint8_t	di_pad2[16];	/* more padding for future expansion */

	/* fields only written to during inode creation */
	xfs_ictimestamp_t di_crtime;	/* time created */
	xfs_ino_t	di_ino;		/* inode number */
	uuid_t		di_uuid;	/* UUID of the filesystem */

	/* structure must be padded to 64 bit alignment */
   #+end_src
   - data fork是inode后面的数据,对于不同的mode/format, 内容不一样
   - 如果是reg文件,data fork是表示数据磁盘空间的extent数据, 有2种extent:XFS_DINODE_FMT_EXTENTS和XFS_DINODE_FMT_BTREE
   - 对于XFS_DINODE_FMT_EXTENTS, 这里存储的是xfs_bmbt_rec_t数组
   - 对于XFS_DINODE_FMT_BTRFF, 这里存储的是btree根结点xfs_bmdr_block_t
   - 如果是dir文件,data fork是direcotry entries, 有3种表示
   - 对于XFS_DINODE_FMT_LOCAL, directory entries完全存在这里面,使用xfs_dir2_sf_t数组表示
   - 对于XFS_DINODE_FMT_EXTENTS, 使用专门的extent表示. 注意这里不是使用一个fsb,而是一个extent, 所以这里是xfs_bmbt_rec_t数组. extent的数组怎么定?
   - 对于XFS_DINODE_FMT_BTREE, 使用btree的叶子节点存储extent, btree操作应该复杂一些? 这里存储的是xfs_bmdr_block_t
   - 如果是symlink, 有2中, XFS_DINODE_FMT_LOCAL/XFS_DINODE_FMT_EXTENTS
   - 如果是block/chr文件,format应该是FXS_DINODE_FMT_DEV, 里面存储xfs_dev_t

** xfs_inode 
   #+begin_src 
	/* Inode linking and identification information. */
	struct xfs_mount	*i_mount;	/* fs mount struct ptr */
	struct xfs_dquot	*i_udquot;	/* user dquot */
	struct xfs_dquot	*i_gdquot;	/* group dquot */

	/* Inode location stuff */
	xfs_ino_t		i_ino;		/* inode number (agno/agino)*/
	struct xfs_imap		i_imap;		/* location for xfs_imap() */

	/* Extent information. */
	xfs_ifork_t		*i_afp;		/* attribute fork pointer */
	xfs_ifork_t		i_df;		/* data fork */

	/* Transaction and locking information. */
	struct xfs_inode_log_item *i_itemp;	/* logging information */
	mrlock_t		i_lock;		/* inode lock */
	mrlock_t		i_iolock;	/* inode IO lock */
	atomic_t		i_pincount;	/* inode pin count */
	spinlock_t		i_flags_lock;	/* inode i_flags lock */
	/* Miscellaneous state. */
	unsigned long		i_flags;	/* see defined flags below */
	unsigned int		i_delayed_blks;	/* count of delay alloc blks */

	xfs_icdinode_t		i_d;		/* most of ondisk inode */

	/* VFS inode */
	struct inode		i_vnode;	/* embedded VFS inode */
   #+end_src

   - xfs_inode包装inode/xfs_icdinode, 其他的结构和文件系统其他功能关联. mount/dquot/extent/log等.

** xfs_imap
   #+begin_src 
	xfs_daddr_t	im_blkno;	/* starting BB of inode chunk */
	ushort		im_len;		/* length in BBs of inode chunk */
	ushort		im_boffset;	/* inode offset in block in bytes */
   #+end_src
   - 保存inode的磁盘位置信息
   - 为何这里不使用fsb, 而使用bb??

** xfs_bmbt_rec_host
   #+BEGIN_SRC 
	__uint64_t		l0, l1;   
   #+END_SRC

** xfs_ext_irec_t
   - XFS_IFEXTIREC, indirection array of extent blocks
   #+BEGIN_SRC 
	xfs_bmbt_rec_host *er_extbuf;	/* block of extent records */ //这里是数组, 每项已经有了文件偏移?为何外面还有?
	xfs_extnum_t	er_extoff;	/* extent offset in file */
	xfs_extnum_t	er_extcount;	/* number of extents in page/block */   
   #+END_SRC

** xfs_ifork 
   - 这个数据结构应该表示data fork, 或者extent attribute data
   - 可以是local, extents, btree等形式
   #+begin_src 
	int			if_bytes;	/* bytes in if_u1 */
	int			if_real_bytes;	/* bytes allocated in if_u1 */
	struct xfs_btree_block	*if_broot;	/* file's incore btree root */
	short			if_broot_bytes;	/* bytes allocated for root */
	unsigned char		if_flags;	/* per-fork flags */
	union {
		xfs_bmbt_rec_host_t *if_extents;/* linear map file exts */
		xfs_ext_irec_t	*if_ext_irec;	/* irec map file exts */
		char		*if_data;	/* inline file data */
	} if_u1;
	union {
		xfs_bmbt_rec_host_t if_inline_ext[XFS_INLINE_EXTS];
						/* very small file extents */
		char		if_inline_data[XFS_INLINE_DATA];
						/* very small file data */
		xfs_dev_t	if_rdev;	/* dev number if special */
		uuid_t		if_uuid;	/* mount point value */
	} if_u2;
        //if_u1和if_u2的用途不同,如果需要的空间很小, if_u1可直接使用if_u2的. 否则需要重新分配空间
   #+end_src

** xfs_dinode_fmt
   #+begin_src 
typedef enum xfs_dinode_fmt {
	XFS_DINODE_FMT_DEV,		/* xfs_dev_t */
	XFS_DINODE_FMT_LOCAL,		/* bulk data */
	XFS_DINODE_FMT_EXTENTS,		/* struct xfs_bmbt_rec */ 
	XFS_DINODE_FMT_BTREE,		/* struct xfs_bmdr_block */
	XFS_DINODE_FMT_UUID		/* uuid_t */
} xfs_dinode_fmt_t;
   #+end_src
   - 对于regular
   - XFS_DINODE_FMT_EXTENTS: extents队列在di_a中
   - XFS_DINODE_FMT_BTREE: extents使用btree保存,root在di_a中
   - 对于directory 
   - XFS_DINODE_LOCAL: di_a中是xfs_dir2_sf
   - XFS_DINODE_EXTENTS: directory item在extent中保存,extent队列在di_a中.
   - XFS_DINODE_BTREE: directory item在btree的叶子中保存,root在di_a中.

** xfs_bmdr_block
   #+begin_src 
	__be16		bb_level;	/* 0 is a leaf */
	__be16		bb_numrecs;	/* current # of data records */
   #+end_src

** xfs_btree_block
   #+begin_src 
	__be32		bb_magic;	/* magic number for block type */
	__be16		bb_level;	/* 0 is a leaf */
	__be16		bb_numrecs;	/* current # of data records */
	union {
		struct {
			__be32		bb_leftsib;
			__be32		bb_rightsib;

			__be64		bb_blkno;
			__be64		bb_lsn;
			uuid_t		bb_uuid;
			__be32		bb_owner;
			__le32		bb_crc;
		} s;			/* short form pointers */
		struct	{
			__be64		bb_leftsib;
			__be64		bb_rightsib;

			__be64		bb_blkno;
			__be64		bb_lsn;
			uuid_t		bb_uuid;
			__be64		bb_owner;
			__le32		bb_crc;
			__be32		bb_pad; /* padding for alignment */
		} l;			/* long form pointers */
	} bb_u;				/* rest */
   #+end_src

** xfs_exntst_t 
   #+begin_src 
	XFS_EXT_NORM, XFS_EXT_UNWRITTEN,
	XFS_EXT_DMAPI_OFFLINE, XFS_EXT_INVALID
	// extent state??
   #+end_src
   
** xfs_bmbt_irec
   - extent信息的内存表示
   #+begin_src 
	xfs_fileoff_t	br_startoff;	/* starting file offset */
	xfs_fsblock_t	br_startblock;	/* starting block number */
	xfs_filblks_t	br_blockcount;	/* number of blocks */
	xfs_exntst_t	br_state;	/* extent state */
   #+end_src

** xfs_exntfmt 
   #+begin_src 
	XFS_EXTFMT_NOSTATE = 0,
	XFS_EXTFMT_HASSTATE
   #+end_src

**

** 总结
   - 读取inode的metadata数据,很2部分, 一个是普通元数据,比如目录项或extents,还有一种是extent attr.
   - 对于XFS_DATA_FORK, 也就是普通metadaa, xfs_inode->xfs_ifork,把数据保存到xfs_inode->i_df (xfs_ifork)
   - XFS_DINODE_FMT_LOCAL,  把数据直接放到xfs_ifork->if_u1->if_data中
   - XFS_DINODE_FMT_EXTENTS, 数据是xfs_bmbt_rec数组,长度是xfs_dinode->nextents. 把数据放到xfs_ifork->if_u1->if_extents中.
   - XFS_DINODE_FMT_BTREE, 数据是xfs_bmdr_block, 大小根据它计算. 把数据给xfs_ifork->if_broot, 这是xfs_btree_block
   - 对于XFS_XATTR_FORK, 把数据给xfs_inode->i_afp. 具体的也很3种情况,和上面一样.
   - 打开inode时的顺序是,根据ino找到xfs_imap, 得到具体的FSB地址和内部偏移, 然后读回对应的数据到xfs_buf, 验证xfs_dinode数据, 然后读回inode的数据给xfs_icdinode; 然后是xfs_ifork.
   - 在分配inode时,先创建xfs_dinode, 然后使用vfs结构创建inode,然后把参数设置xfs_inode

* xfs_inode.c
  - 这里管理xfs_ifork的数据. 

** xfs_get_extsz_hint(xfs_inode)
   - 获取inode的extent的默认大小, 没看出来哪里使用??
   - 只有inode使用XFS_DIFLAG_EXTSIZE时,返回xfs_inode->xfs_dinode->di_extsize

** xfs_ilock_map_shared(xfs_inode)
   - 如果inode的data fork里面的数据是btree, 需要先把他们读进来
   - 但读操作需要互斥
   - xfs_dinode->di_format是XFS_DINODE_FMT_BTREE
   - 而且xfs_inode->if_flags有XFS_IFEXTENTS!=0, 表示总的extent数量>0?
   - 如果需要读这些数据,使用XFS_ILOCK_EXCL锁
   - 否则使用XFS_ILOCK_SHARED锁 
   > xfs_ilock(xfs_inode, lock_mode)

** xfs_iunlock_map_shared(xfs_inode, lock_mode) 
   > xfs_iunlock(xfs_inode, lock_mode)

** xfs_ilock(xfs_inode, lock_flags)
   - xfs inode使用2个锁: i_iolock, i_lock, 而且2个锁都是读写锁
   - lock_flags可能包含2个锁
     #+BEGIN_SRC 
#define	XFS_IOLOCK_EXCL		(1<<0)
#define	XFS_IOLOCK_SHARED	(1<<1)
#define	XFS_ILOCK_EXCL		(1<<2)
#define	XFS_ILOCK_SHARED	(1<<3)
     #+END_SRC
   - 首先操作i_iolock, 然后是i_lock锁
   - 对于互斥锁
   > mrupdate_nested(xfs_inode->i_iolock, XFS_IOLOCK_DEP(lock_flags))
   - 对于共享锁 
   > mraccess_nested(xfs_inode->i_iolock, XFS_IOLOCK_DEP(lock_flags)

** xfs_ilock_nowait(xfs_inode, lock_flags)
   - 和上面一样
   - 不过锁操作不会等待,如果无法获取直接返回.
   - 如果获取了i_iolock, 但无法获取i_lock, 就释放i_iolock

** xfs_iunlock(xfs_inode, lock_flags)
   - 接锁, 顺序没有关系
   > trace_xfs_iunlock(xfs_inode, lock_flags, _RET_IP_)
   
** xfs_ilock_demote(xfs_inode, lock_flags)
   - 释放互斥锁, 或者写锁
   - lock_flags同样包括i_iolock和i_lock 
   > mrdemote(xfs_inode->i_lock)
   - 原来这些函数都是xfs包装的

   - 上面的锁使用rw_semaphore, 操作是
   > up_read()
   > up_write()
   > down_read_nested()
   > down_write_nested()

** xfs_isilocked(xfs_inode, lock_flags)
   > rwsem_is_locked(xfs_inode->i_lock->mr_lock

** __xfs_iflock(xfs_inode)
   - inode的flush操作时使用的锁
   - 等待xfs_inode->i_flags的__XFS_IFLOCK_BIT
   > prepare_to_wait_exclusive(wait_queue_head_t, wait_queue, TASK_UNINTERRUPTIBLE)
   - 检查上面的标志
   > xfs_isiflocked(xfs_inode)
   - 循环等待的条件时 
   > xfs_iflock_nowait(xfs_inode)
   - 也就是它结束等待后,也会锁住这个标志
   - xfs_inode->i_flags使用xfs_inode->i_flags_lock

** xfs_exntfmt
   #+BEGIN_SRC 
	XFS_EXTFMT_NOSTATE = 0,
	XFS_EXTFMT_HASSTATE   
   #+END_SRC
   - 为何extent还有2种格式

** xfs_exntfmt_t
   - 这里应该表示内存中extent的状态
   #+BEGIN_SRC 
	XFS_EXT_NORM, 
	XFS_EXT_UNWRITTEN,  
	XFS_EXT_DMAPI_OFFLINE, 
	XFS_EXT_INVALID   
   #+END_SRC

** xfs_bmbt_rec 
   #+BEGIN_SRC 
	__be64			l0, l1;   
/*
 *  l0:63 is an extent flag (value 1 indicates non-normal).
 *  l0:9-62 are startoff.                file offset 
 *  l0:0-8 and l1:21-63 are startblock.  disk offset
 *  l1:0-20 are blockcount.       
 */
   #+END_SRC

** xfs_bmbt_irec
   #+BEGIN_SRC 
	xfs_fileoff_t	br_startoff;	/* starting file offset */
	xfs_fsblock_t	br_startblock;	/* starting block number */
	xfs_filblks_t	br_blockcount;	/* number of blocks */
	xfs_exntst_t	br_state;	/* extent state */   
   #+END_SRC
   - xfs_fsblock_t怎么使用?  和 xfs_dfsbno_t 一样吗?

** xfs_validate_extents(xfs_ifork, nrecs, xfs_exntfmt_t)
   - xfs_ifork储存的是xfs_bmbt_irec数组, 长度是nrecs
   - 检查xfs_bmbt_irec->br_bstate 和 xfs_exntfmt_t一致
   - 如果xfs_exntfmt_t是XFS_EXT_NOSTATE, bt_bstate必须是XFS_EXT_NORM
   - 这里xfs_bmbt_irec和xfs_bmbt_rec_host一致
   - 遍历所有的xfs_bmbt_rec_host 
   > xfs_iext_get_ext(xfs_ifork, i)
   - 解析成xfs_bmbt_irec 
   > xfs_bmbt_get_all(xfs_bmbt_rec_host, xfs_bmbt_irec)
   - 检查xfs_bmbt_irec->br_state
   - 解析时, br_state只有2种情况, 一种是XFS_EXT_NOR, 另一种是XFS_EXT_UNWRITTEN

** xfs_inobp_check(xfs_mount, xfs_buf)
   - xfs_buf中的inode的next不是0, 那应该是什么???
   - xfs_buf是一个保存inode的extent? 大小是xfs_mount->m_inode_cluster_size?
   - 计算一个cluster中inode的大小?  一个cluster是一个extent? 多大?? 
   - xfs_mount->m_inode_cluster_size >> xfs_mount->xfs_sb->sb_inodelog
   - 遍历xfs_buf中的xfs_dinode 
   > xfs_buf_offset(xfs_buf, i*xfs_mount->xfs_sb->sb_inodesize)
   - 如果xfs_dinode->di_next_unlinked是0,报错

** xfs_inode_buf_verify(xfs_buf)
   - 检查xfs_buf中的xfs_dinode的内容
   - 这里计算xfs_buf的xfs_dinode的方法和上面不一样
   - 首先转化xfs_buf的大小为fsb单位,然后获取每个fsb的inode的数量
   > XFS_BB_TO_FSB(xfs_mount, xfs_buf->b_length) * xfs_mount->xfs_sb->sb_inopblock
   - 遍历xfs_buf的xfs_dinode
   > xfs_buf_offset(xfs_buf, i<<xfs_mount->xfs_sb->sb_inodelog)
   - xfs_dinode->di_magic是XFS_DINODE_MAGIC  'IN'
   - xfs_dinode->di_version是[1,3]
   - 检查所有xfs_dinode的xfs_ifork? 已经在内存中??
   > xfs_inobp_check(xfs_mount, xfs_buf)
     
** xfs_inode_buf_read_verify(xfs_buf)
   > xfs_inode_buf_verify(xfs_buf)

** xfs_inode_buf_write_verify(xfs_buf)
   > xfs_inode_buf_verify(xfs_buf)

** xfs_buf_ops xfs_inode_buf_ops
   - 原来这里还是为了xfs_buf服务

** xfs_imap_to_bp(xfs_mount, xfs_trans, xfs_imap, xfs_dinode dipp, xfs_buf bpp, buf_flags, iget_flags)
   - 把一个inode读到内存中, 获取对应的xfs_dinode/xfs_buf指针
   - 设置buf_flags的XBF_UNMAPPED??
   - 使用transaction包装的函数读xfs_buf
   > xfs_trans_read_buf(xfs_mount, xfs_trans, xfs_mount->m_ddev_targp, xfs_imap->im_blkno, xfs_imap->im_len, buf_flags, xfs_buf, xfs_inode_buf_ops)
   - xfs_dinode的指针在xfs_buf上 
   > xfs_buf_offset(xfs_buf, xfs_imap->im_boffset)

** xfs_attr_shortform
   #+BEGIN_SRC 
	struct xfs_attr_sf_hdr {	/* constant-structure header block */
		__be16	totsize;	/* total bytes in shortform list */
		__u8	count;	/* count of active entries */
	} hdr;
	struct xfs_attr_sf_entry {
		__uint8_t namelen;	/* actual length of name (no NULL) */
		__uint8_t valuelen;	/* actual length of value (no NULL) */
		__uint8_t flags;	/* flags bits (see xfs_attr_leaf.h) */
		__uint8_t nameval[1];	/* name & value bytes concatenated */
	} list[1];			/* variable sized array */   
   #+END_SRC

** xfs_iformat(xfs_inode, xfs_dinode)
   - 把xfs_dinode的数据给xfs_inode
   - 对于特殊文件, fifo,chr,blk,sock, 只需要rdev数据
   - 放到xfs_inode->xfs_ifork->if_u2->if_rdev中, 数据是xfs_dev_t
   > xfs_dinode_get_rdev(xfs_inode)
   - 对于dir,link,reg文件, 根据xfs_dinode->di_format处理
   - 如果XFS_DINODE_FMT_LOCAL, 数据在data fork中, 但xfs_dinode->di_mode不能是REG
   - 看来普通文件数据不可能和inode放一块
   - data fork数据大小是xfs_dinode->di_forkoff << 3, 如果它是0, 特殊一些??
   > XFS_DFORK_DSIZE(xfs_dinode, xfs_mount)
   - 但这是xfs_dinode->di_size不能超过上面data fork数据量
   - 建立xfs_ifork??
   > xfs_iformat_local(xfs_inode, xfs_dinode, XFS_DATA_FORK, xfs_dinode->di_size)
   - 如果是XFS_DINODE_FMT_EXTENTS 
   > xfs_iformat_extents(xfs_inode, xfs_dinode, XFS_DATA_FORK)
   - 如果是XFS_DINODE_FMT_BTREE
   > xfs_iformat_btree(xfs_inode, xfs_dinode, XFS_DATA_FORK)
   - 然后处理attribute fork, 其他的metadata
   - 如果xfs_dinode->di_forkoff ==0, 没有attribute fork??
   - 首先准备xfs_inode->i_afp, 使用xfs_ifork_zone分配
   - 根据xfs_dinode->di_aformat解析数据
   - 数据位置是XFS_DFORK_APTR(xfs_dinode)
   - 如果是XFS_DINODE_FMT_LOCAL, 里面是xfs_attr_shortform
   > xfs_iformat_local(xfs_inode, xfs_dinode, XFS_ATTR_FORK, xfs_attr_shortform->xfs_attr_sf_hdr->totsize
   - 如果是XFS_DINODE_FMT_EXTENTS
   > xfs_iformat_extents(xfs_dinode, xfs_inode, XFS_ATTR_FORK)
   - 如果是XFS_DINODE_FMT_BTREE 
   > xfs_iformat_btree(xfs_inode, xfs_dinode, XFS_ATTR_FORK)
   
** xfs_iformat_local(xfs_inode, xfs_dinode, whichfork, size)
   - whichfork区分普通的data fork和attribute fork
   - 把数据全部放到xfs_ifork->if_u1->if_data中
   - 所以xfs_ifork只是保存数据,具体的解析还需要根据数据的意义
   - 如果size ==0, 设置xfs_ifork->if_u1->fi_data = NULL
   - 如果size < sizeof(xfs_ifork->if_u2->if_inline_data), 把if_data指向if_inline_data
   - 否则重新分配一块内存
   - 设置xfs_ifork->if_bytes = size, xfs_ifork->if_real_bytes = roundup(size, 4)
   - 设置xfs_ifork->if_flags的XFS_IFINLINE

** xfs_iformat_extents(xfs_inode, xfs_dinode, whichfork)
   - xfs_bmbt_rec不仅包含磁盘位置,还有文件位置, directory entries数据也需要??
   - 首先计算extent的数量nex, xfs_dinode->di_nextents, xfs_dinode->di_anextents
   > XFS_DFORK_NEXTENTS(xfs_dinode, whichfork)
   - 如果nex ==0, 设置xfs_ifork->if_u1->if_extents = NULL
   - 如果nex < XFS_INLINE_EXTS, 它是xfs_ifork->if_u2->if_inline_ext的长度
   - 设置xfs_ifor->if_u1->if_extents = if_inline_ext
   - 否则创建新的
   > xfs_iext_add(xfs_ifork, 0, nex)
   - 把xfs_dinode的data fork复制进来
   - 先验证xfs_bmbt_rec, 检查xfs版本
   > xfs_validate_extents(xfs_ifork, nex, XFS_EXTFMT_INODE(xfs_inode))
   - 放到内存中的是经过大小端转化的
   > xfs_iext_get_ext(xfs_ifork, i)
   - 最后设置xfs_inode->if_flags的XFS_IFEXTENTS
   - xfs_ifork->if_bytes表示实际的数据量, 这个数组扩展性就很差了
   - 如果超过inline,每次变化都需要分配和释放内存

** xfs_iformat_btree(xfs_inode, xfs_dinode, whichfork)
   - data fork中是xfs_bmdr_block数据
   - 计算btree使用的空间?? xfs_ifork->if_broot_bytes
   > XFS_BMAP_BROOT_SPACE(xfs_mount, xfs_bmdr_block)
   - 分配一块完整的内存给xfs_ifork->if_broot
   - 搬运数据 
   > xfs_bmdr_to_bmbt(xfs_inode, xfs_bmdr_block, XFS_DFORK_SIZE(xfs_inode, xfs_mount, whichfork), xfs_bmdr_block->if_broot, size)
   - 设置xfs_ifork->if_flags的XFS_IFBROOT
   - 上面只把btree的root节点复制到内存中, 而且XFS_IFEXTENTS,也只是把xfs_bmbt_rec复制到内存

** xfs_dinode_from_disk(xfs_idcinode, xfs_dinode)
   - xfs_idcinode是xfs_dinode内存中的表示形式, 两者只有数据类型不一样
   - xfs_dinode的数据类型全是大端的
   - 把xfs_dinode数据给xfs_icdinode
   - xfs_icdinode在xfs_inode中

** xfs_dinode_to_disk(xfs_dinode, xfs_idcinode)
   - 上面的逆操作

** _xfs_dic2xflags(di_flags)
   - xfs_icdinode和xfs_dinode->di_flag还是完全相同的, 
   - 它是XFS_DIFLAG_*, 转化为XFS_XFLAG_*

** xfs_ip2xflags(xfs_inode)
   - 获取xfs_inode->xfs_icdinode->di_flags
   > _xfs_dic2xflags(di_flags) 
   - 如果xfs_inode有attr数据,还要有XFS_XFLAG_HASATTR

** xfs_dic2flags(xfs_dinode)
   > _xfs_dic2xflags(be16_to_cpu(xfs_dinode->di_flags)) | XFS_XFLAG_HASATTR

** xfs_dinode_verify(xfs_mount, xfs_inode, xfs_dinode)
   - 验证xfs_dinode数据
   - xfs_dinode->di_magic是cpu_to_be16(XFS_DINODE_MAGIC)
   - xfs_dinode->di_version >= 3, 这个域是char, 不需要大小端
   - 如果支持crc验证,计算checksum
   > xfs_sb_version_hasrcr(xfs_mount->xfs_sb)
   > xfs_verify_cksum(xfs_dinode, xfs_sb->sb_inodesize, offsetof(xfs_dinode, di_crc))
   - 比较xfs_dinode->di_ino = xfs_inode->i_ino
   - uuid比较, xfs_dinode->di_uuid

** xfs_dinode_calc_crc(xfs_mount, xfs_dinode)
   - 计算的对象是xfs_dinode->di_crc前面的数据, 结果给xfs_dinode->di_crc
   > xfs_start_cksum(xfs_dinode, xfs_mount->xfs_sb->sb_inodesize, offsetof(xfs_dinode, di_crc))

** iget_flags
   #+BEGIN_SRC 
#define XFS_IGET_CREATE		0x1
#define XFS_IGET_UNTRUSTED	0x2
#define XFS_IGET_DONTCACHE	0x4   
   #+END_SRC

** xfs_iread(xfs_mount, xfs_trans, xfs_inode, iget_flags)
   - 计算xfs_imap信息, inode的磁盘位置
   > xfs_imap(xfs_mount, xfs_trans, xfs_inode->i_ino, xfs_inode->i_imap, iget_flags)
   - 如果iget_flags包含XFS_IGET_CREATE, 这里要创建inode?
   - 初始化xfs_inode->xfs_icdinode
   - 设置di_magic, di_gen = prandom_u32()
   - 查找包含xfs_dinode的xfs_buf
   > xfs_imap_to_bp(xfs_mount, xfs_trans, xfs_inode->xfs_imap, xfs_dinode, xfs_buf, 0, iget_flags)
   - 验证xfs_dinode数据
   > xfs_dinode_verify(xfs_mount, xfs_inode, xfs_dinode)
   - 如果xfs_inode->di_mode !=0, 表示它已经存在
   > xfs_dinode_from_disk(xfs_inode->xfs_icdinode, xfs_dinode)
   > xfs_iformat(xfs_inode, xfs_dinode)
   - 否则它是空的?? 先初始化xfs_icdinode
   - 设置magic, version, gen, flushiter?
   - 设置xfs_buf的XFS_INO_REF, 让他在内存中缓存一段时间 
   > xfs_buf_set_ref(xfs_buf, XFS_INO_REF)
   - xfs_buf读操作使用xfs_trans, 释放对应的资源?? 
   > xfs_trans_brelse(xfs_trans, xfs_buf)

** xfs_iread_extents(xfs_trans, xfs_inode, whichfork)
   - 读取btree_format的inode的data fork
   - xfs_ifork必须是XFS_DINODE_FMT_BTREE
   > XFS_IFORK_FORMAT(xfs_inode, whichfork)
   - 在内存中, data fork完全使用XFS_IFEXTENTS存储?? 不会使用btree?
   - 获取extent的数量nextents 
   > XFS_IFORK_NEXTENTS(xfs_inode, whichfork)
   - 创建extent数组
   > xfs_bmap_read_extents(xfs_trans, xfs_inode, whichfork)
   - 把btree中的leaf的内容都读取extent中?? 
   > xfs_bmap_read_extents(xfs_trans, xfs_inode, whichfork)
   - 验证这些extent数据, xfs_bmbt_rec
   > xfs_validate_extents(xfs_ifork, nextents, XFS_EXTFMT_INODE(xfs_inode))

** xfs_ialloc(xfs_trans, xfs_inode, mode, xfs_nlink_t, xfs_dev_t, prid_t, okalloc, xfs_buf, xfs_inode)
   - 后面2个参数返回结果
   - 第2个参数xfs_inode是父目录的inode
   - 首先分配磁盘空间,储存xfs_dinode 
   > xfs_dialloc(xfs_trans, xfs_inode->i_ino, mode, okalloc, xfs_buf, xfs_ino_t)
   - 创建xfs_inode? 使用inode cache管理inode
   > xfs_iget(xfs_mount, xfs_trans, xfs_ino, XFS_IGET_CREATE, XFS_ILOCK_EXCL, xfs_inode)
   - 设置xfs_inode->xfs_icdinode, mode, di_onlink, di_nlink, uid, gid, projid
   - 还有各种time, 基本的xfs_ifork
   - 对于reg/dir文件,继承父目录的属性
   - 但这里的继承处理收xfs_params影响,估计mount时设定??
   - 同时初始化xfs_inode->xfs_ifork
   - 设置xfs_inode->xfs_icdinode->di_format是XFS_DINODE_FMT_EXTENTS
   - xfs_ifork->if_flags是XFS_IFEXTENTS
   - 设置if_bytes = 0, 没有data fork
   - 处理trans? 
   > xfs_trans_ijoin(xfs_trans, xfs_inode, XFS_ILOCK_EXCL)
   > xfs_trans_log_inode(xfs_trans, xfs_inode, flags)
   - 初始化xfs_inode 
   > xfs_setup_inode(xfs_inode)
   - 最后是filestream??
   > xfs_filestream_associate(xfs_inode, xfs_inode)
   - 设置xfs_inode->i_flags的XFS_IFILESTREAM 
   > xfs_iflags_set(xfs_inode, XFS_IFILESTREAM)

** xfs_itruncate_extents(xfs_trans, xfs_inode, whichfork, xfs_fsize_t new_size)
   - 释放文件的磁盘空间, 处理data fork和attribute data fork?
   - 文件大小改为new_size, 转化为fsb, first_unmap_block
   - 计算文件的最大值 last_block
   > XFS_B_TO_FSB(xfs_mount, xfs_mount->super_block->s_maxbytes)
   - 这里要释放的范围是(first_unmap_block, last_block)
   - 循环处理磁盘空间
   - 首先初始化xfs_bmap_free 
   > xfs_bmap_init(xfs_bmap_free, xfs_fsblock_t)
   - 调用底层的函数?? 
   > xfs_bunmapi(xfs_trans, xfs_inode, first_unmap_block, unmap_len, xfs_bmapi_aflag(whichfork), XFS_ITRUNC_MAX_EXTENTS, first_block, xfs_bmap_free, done)
   - 结束bmap? 
   > xfs_bmap_finish(xfs_trans, xfs_bmap_free
   - 提交xfs_trans? 
   > xfs_trans_ijoin(xfs_trans, xfs_inode, 0)
   - 如果committed !=0, 设置inode的脏标志?? 
   > xfs_trans_log_inode(xfs_trans, xfs_inode, XFS_ILOG_CORE)
   - 完全忘记xfs部分
   > xfs_trans_dup(xfs_trans)
   - 提交刚才的操作 
   > xfs_trans_commit(xfs_trans, 0)
   > xfs_trans_ijoin(xfs_trans, xfs_inode, 0)
   - 重新reserve空间,释放磁盘空间 
   > xfs_trans_reserve(xfs_trans, 0, XFS_ITRUNCATE_LOG_RES(xfs_mount), 0, XFS_TRANS_PERM_LOG_RES, XFS_ITRUNCATE_LOG_COUNT)
   - 最后还要提交xfs_inode?? 
   > xfs_trans_log_inode(xfs_trans, xfs_inode, XFS_ILOG_CORE)
   
** xfs_iunlink(xfs_trans, xfs_inode)
   - 当inode->i_nlink变为0时使用
   - 获取xfs_agi?
   > xfs_read_agi(xfs_mount, xfs_trans, XFS_INO_TO_AGNO(xfs_mount, xfs_inode->i_ino), xfs_buf)
   - 难道在buf中直接使用??
   > XFS_BUF_TO_AGI(xfs_buf)
   - xfs_agi->agi_unlinked是一个hash表,里面记录要删除的inode
   - 这里的操作要把xfs_inode使用的xfs_dinode放到hash队列中
   - 根据xfs_ino中的AGINO计算hash值
   > XFS_INO_TO_AGINO(xfs_mount, xfs_inode->i_ino)
   - ino包含3部分
   - block内部偏移 xfs_sb->sb_inopblog
   - ag内部偏移    xfs_sb->agblklog
   - ag索引        xfs_sb->m_agno_log, 它根据所有ag的数量决定
   - xfs_mount->m_agino_log, agi包含了ag内部偏移和block内部偏移
   - 如果xfs_agi->agi_unlinked[bucket_index]不是NULLAGINO, 把他放到表头
   - 修改当前inode对应的xfs_dinode 
   > xfs_imap_to_bp(xfs_mount, xfs_trans, xfs_inode->xfs_imap, xfs_dinode, xfs_buf, 0, 0)
   - 设置xfs_dinode->di_next_unlinked = xfs_agi->agi_unlinked[bucket_index]
   - 重新计算crc 
   > xfs_dinode_calc_crc(xfs_mount, xfs_dinode)
   - 把上面的修改记录到log中 
   > xfs_trans_inode_buf(xfs_trans, xfs_buf)
   - 这里记录修改的域
   > xfs_trans_log_buf(xfs_trans, xfs_buf, offset, offset + sizeof(xfs_agino_t) -1 )
   - 遍历xfs_buf中的xfs_dinode, 检查每个xfs_dinode->di_next_unlinked, 不能为0
   - 默认的是什么?? NULLAGINO
   > xfs_inobp_check(xfs_mount, xfs_buf)
   - 然后把当前的agino放到xfs_agi->agi_unlinked[bucket_index], 这里为何不使用agno??
   - 把对xfs_agi的修改放到log中 
   > xfs_trans_log_buf(xfs_trans, xfs_buf, offset, offset+sizeof(xfs_agino_t)-1)

** xfs_iunlink_remove(xfs_trans, xfs_inode)
   - 从unlink链表中释放inode?
   - 获取xfs_agi
   > xfs_read_agi(xfs_mount, xfs_trans, XFS_INO_TO_AGNO(xfs_mount, xfs_inode->i_ino), xfs_buf)
   > XFS_BUF_TO_AGI(xfs_buf)
   - 这里对xfs_agi的使用要注意大小端,因为在磁盘上直接读出来使用
   - 不过xfs_agi的定义也是使用大端的类型
   - 计算xfs_inode的agino
   > XFS_INO_TO_AGINO(xfs_mount, xfs_inode->i_ino)
   - 如果agino是xfs_agi->agi_unlinked[bucket_index], 可以仅仅修改xfs_agi 
   > xfs_imap_to_bp(xfs_mount, xfs_trans, xfs_inode->xfs_imap, xfs_buf, xfs_inode, 0, 0)
   - 获取下一个agino xfs_dinode->di_next_unlinked
   - 如果下一个不是NULLAGINO, 修改当前的xfs_dinode->di_next_unlinked = NULLAGINO
   - 把这些修改记录到log中 
   > xfs_dinode_calc_crc(xfs_mount, xfs_dinode)
   > xfs_trans_inode_buf(xfs_trans, xfs_buf)
   > xfs_trans_log_buf(xfs_trans, xfs_buf, offset, offset+sizeof(xfs_agino_t)-1)
   > xfs_inobp_check(xfs_mount, xfs_buf)
   - 否则不用修改,直接释放xfs_buf的使用?? 
   > xfs_trans_brelse(xfs_trans, xfs_buf)
   - 修改xfs_agi, xfs_agi->agi_unlinked[bucket_index] = next_agi
   - 把这些修改记录到log中
   - offset = offset(xfs_agino_t, agi_unlinked) + sizeof(xfs_agino_t*) * bucket_index
   > xfs_trans_log_buf(xfs_trans, xfs_buf, offset, offset+sizeof(xfs_agino_t)-1)
   - 如果agino不是hash链表的第一个xfs_dinode, 需要遍历查找对应的xfs_dinode
   - 使用xfs_imap查找xfs_dinode
   - 根据agino构造ino
   > XFS_AGINO_TO_INO(xfs_mount, agno, next_agino)
   - 获取对应的xfs_imap
   > xfs_imap(xfs_mount, xfs_trans, next_ino, xfs_imap, 0)
   - 读取xfs_dinode所在的xfs_buf 
   > xfs_imap_to_bp(xfs_mount, xfs_trans, xfs_imap, xfs_buf, xfs_dinode, 0, 0)
   - 检查xfs_dinode->di_next_unlinked, 如果和上面的agino相同,查找循环结束
   - 查找当前的xfs_dinode
   > xfs_imap_to_bp(xfs_mount, xfs_trans, xfs_inode->i_imap, xfs_buf, xfs_dinode, 0, 0)
   - 处理当前的xfs_dinode->di_next_unlinked, 如果下一个不是NULLAGINO, 需要设置为NULLAGINO
   - 操作和上面类似,把改动放到log中
   - 设置上一个xfs_dinode, 把更新放到log中

** xfs_ifree_cluster(xfs_inode, xfs_trans, xfs_ino_t)
   - 获取xfs_perag
   > xfs_perag_get(xfs_mount, XFS_INO_TO_AGNO(xfs_mount, xfs_ino_t))
   - xfs_dinode的存储管理单位是xfs_mount->m_inode_cluster_size(8192),也就是cluster. 但buf缓存这些存储的单位是xfs_mount->m_ialloc_blks
   - 这里需要操作的数据量是xfs_mount->m_ialloc_blks * fsb
   - 如果cluster比fsb小, 每次使用的xfs_buf操作的一个fsb, 包含多个cuslter
   - 否则每次使用的xfs_buf操作多个fsb, 包含一个cluster
   - 获取cluster的大小 xfs_mount->m_inode_cluster_size, fsb大小是super_block->sb_blocksize
   > XFS_INODE_CLUSTER_SIZE(xfs_mount)
   - nbufs表示操作xfs_buf的循环数,它由ialloc的缓存单位决定
   > XFS_IALLOC_BLOCKS(xfs_mount)
   - 如果xfs_sb->sb_blocksize比fsb大, 每次xfs_buf包含多个cluster, blks_per_cluster是1, 表示它使用一个fsb, nbufs是xfs_mount->m_ialloc_blks, 
   - 否则使用的xfs_buf大小是cluster的数据量, blks_per_cluster是xfs_mount->m_inode_cluster_size / fsb, nbufs是xfs_mount->m_ialloc_blks / blks_per_cluster
   - 遍历对应的磁盘空间,使用xfs_buf
   - 根据xfs_ino_t构造xfs_daddr_t 
   > XFS_AGB_TO_DADDR(xfs_mount, XFS_INO_TO_AGNO(xfs_mount, inum), XFS_INO_TO_AGBNO(xfs_mount, inum))
   - xfs_trans_get_buf(xfs_trans, xfs_mount->m_ddev_targp, blkno, xfs_mount->m_bsize * blks_per_cluster, XBF_UNMAPPED)
   - 上面的磁盘空间为何不用super_block->sb_blocksize?
   - 设置xfs_buf->b_ops = xfs_inode_buf_ops
   - 遍历xfs_buf的xfs_inode, 使用xfs_inode_log_item遍历?
   > xfs_trans_ail_copy_lsn(xfs_mount->xfs_ail, xfs_inode_log_item->ili_flush_lsn, xfs_inode_log_item->xfs_log_item->li_lsn)
   - 设置xfs_inode的XFS_ISTALE标志?? 
   > xfs_iflags_set(xfs_inode_log_item->xfs_inode, XFS_ISTALE)
   - 遍历里面的xfs_dinode, 个数是blks_per_cluster * xfs_sb->sb_inopblog
   - 根据agino获取缓存的xfs_inode? 和上面什么区别?
   - radix_tree_lookup(xfs_perag->pag_ici_root, XFS_INO_TO_AGINO(xfs_mount, inum))
   - 锁住xfs_inode, XFS_ILOCK_EXCL, 还有flush锁 
   > xfs_ilock_nowait(xfs_inode, XFS_ILOCK_EXCL) 
   > xfs_iflock(xfs_inode)
   - 设置xfs_inode的XFS_ISTALE标志 
   > xfs_iflags_set(xfs_node, XFS_ISTALE)
   - 设置xfs_inode->xfs_inode_log_item, 如果不存在不再处理
   - 设置xfs_inode_log_item->ili_last_fields = xfs_inode_log_item->ili_fields, ili_fields = 0, ili_logged = 1
   - 把xfs_inode_log_item放到xfs_ail中 
   > xfs_trans_ail_copy_lsn(xfs_mount->xfs_ail, xfs_inode_log_item->ili_flush_lsn, xfs_inode_log_item->xfs_log_item->li_lsn)
   - 注册回调函数?? 
   > xfs_buf_attach_iodone(xfs_buf, xfs_istale_done, xfs_inode_log_item->xfs_log_item)
   - 然后设置xfs_buf的标志?? 什么意思??
   > xfs_trans_stale_inode_buf(xfs_trans, xfs_buf)
   - 无效这个xfs_buf
   > xfs_trans_binval(xfs_trans, xfs_buf)

** xfs_ifree(xfs_trans, xfs_inode, xfs_bmap_free)
   - 释放xfs_inode的磁盘空间?
   - 现在xfs_dinode已经在unlink列表中
   - 检查xfs_inode->xfs_icdinode的状态
   - xfs_icdinode->di_nlink是0, nextents是0, anextents也是0, di_size是0, di_nblocks是0, 它的所有数据都已经删除
   - 在哪里删除的??
   - 从unlink链表中释放inode 
   > xfs_iunlink_remove(xfs_trans, xfs_inode)
   - 释放磁盘空间? 
   > xfs_difree(xfs_trans, xfs_inode->i_ino, xfs_bmap_free, delete, first_ino)
   - 这里还返回first ino??
   - 重置xfs_icdinode的变量, di_mode = 0
   - 把它放到trans中? 
   > xfs_trans_log_inode(xfs_trans, xfs_inode, XFS_ILOG_CORE) 
   - 如果上面的delete返回1,释放cluster的磁盘空间??
   - 这里传递的是cluster的第一个ino??
   > xfs_ifree_cluster(xfs_inode, xfs_trans, first_ino)

** xfs_iroot_realloc(xfs_inode, rec_diff, whichfork)
   - xfs_ifork的数据是btree时,修改根结点大小? 
   - xfs_ifork的数据在内存中的格式是什么?? 和磁盘完全一致?
   - whichfork表示要操作的xfs_ifork 
   > XFS_IFORK_PTR(xfs_inode, whichfork)
   - 如果rec_diff>0, 而且xfs_ifork->if_broot_bytes = 0
   - 这是创建xfs_btree_block
   - 计算根结点大小?  new_size
   > XFS_BMAP_BTREE_SPACE_CALC(xfs_mount, rec_diff)
   - 直接使用kmalloc分配内存, 设置xfs_ifork->if_broot_bytes = new_size
   - 如果xfs_ifork->if_broot_bytes > 0, 表示增长空间
   - 计算原来的大小? 
   > xfs_bmbt_maxrecs(xfs_mount, blocklen, 0)
   - 重新分配内存, 然后需要移动节点中的vallue, key不用移动
   > XFS_BMAP_BROOT_PTR_ADDR(xfs_mount, xfs_btree_block, 1, xfs_ifork->if_broot_bytes)
   - 如果是减小空间? rec_diff < 0
   - 如果减为0, 直接释放xfs_btree_block
   - 否则重新分配内存,并移动数据??包括record，pointer??
   - 如果减为0 去掉xfs_ifork->if_flags的XFS_IFBROOT

** xfs_idata_realloc(xfs_inode, bytes_diff, whichfork)
   - 这是xfs_ifork在使用local方式保存数据??
   - bytes_diff表示xfs_ifork需要改变的空间?? 
   - 也就是xfs_ifork->if_bytes的空间
   - 获取操作的xfs_ifork 
   > XFS_IFORK_PTR(xfs_inode, whichfork)
   - 如果空间减为0, 直接释放xfs_ifork->if_u1->if_data
   - 如果它不是xfs_ifork->if_u2->if_inline_data, 直接释放空间
   - 如果新的空间不超过if_inline_data的长度,检查原来的空间量
   - 如果原来使用分配的动态内存,需要搬运数据,并释放空间
   - 如果原来是0, 直接修改内存指针
   - 否则变为使用动态内存, 使用xfs_ifork->if_real_bytes表示内存大小, 同样需要考虑原来的情况,可能是NULL,可能是inlien,可能是动态内存

** xfs_idestroy_fork(xfs_inode, whichfork)
   - 释放xfs_ifork?
   - 释放xfs_ifork->xfs_btree_block,并没有考虑XFS_IFBROOT??
   - 如果xfs_inode的磁盘格式是XFS_DINODE_FMT_LOCAL
   - 没有extent资源, 只需要释放xfs_ifork->if_u1->if_data
   - 如果它没有使用inline空间,需要释放内存
   - 如果使用extent的格式??
   - 如果xfs_ifork->if_flags有XFS_IFEXTENTS,而且
   - xfs_ifork->if_flags有XFS_IFEXTIREC或者xfs_ifork->if_u1->if_extents使用动态内存, 释放extent数据?? 
   > xfs_iext_destroy(xfs_ifork)
   - 如果是attribute的xfs_ifork, 直接释放它 
   > kmem_zone_free(xfs_ifork_zone, xfs_inode->i_afp)

** xfs_iunpin(xfs_inode)
   - 在cil中使用??
   - xfs_log_force_lsn(xfs_inode->xfs_mount, xfs_inode->xfs_inode_log_item->ili_last_lsn, 0)
   - 刷新log??

** __xfs_iunpin_wait(xfs_inode)
   - 等待xfs_inode->i_flags的__XFS_IPINNED_BIT
   - 但等待结束的条件是xfs_inode->i_pincount == 0
   - 这里使用公共的等待队列

** xfs_iunpin_wait(xfs_inode)
   - 先检查xfs_inode->i_pincount 
   > xfs_ipincount(xfs_inode)
   - 如果不是0去等待
   > __xfs_iunpin_wait(xfs_inode)

** xfs_iextents_copy(xfs_inode, xfs_bmbt_rec_t, whichfork
   - 把xfs_ifork的extents信息放到xfs_bmbt_rec数组中
   - 总的数据量是xfs_ifork->if_bytes
   - 在xfs_ifork中的格式没有大小端信息, 放到xfs_bmbt_rec中转化到be
   - 从xfs_ifork中取出xfs_bmbt_rec_host
   > xfs_iext_get_ext(xfs_ifork, i)
   - 检查磁盘位置, 如果是null, 直接返回
   > xfs_bmbt_get_startblock(xfs_bmbt_rec_host)
   - 然后把数据放到xfs_bmbt_rec中
   - 最后还要检查xfs_dinode中的数据有效性
   > xfs_validate_extents(xfs_ifork, copied, XFS_EXTFMT_INODE(xfs_inode))

** xfs_iflush_fork(xfs_inode, xfs_dinode, xfs_inode_log_item, whichfork, xfs_buf)
   - 把xfs_ifork的数据给磁盘??
   - 操作的xfs_ifork是 
   > XFS_IFORK_PTR(xfs_inode, whichfork)
   - 计算对应的buf空间 
   > XFS_DFORK_PTR(xfs_dinode, whichfork)
   - 检查xfs_dinode的格式
   - 如果是XFS_DINODE_FMT_LOCAL, 需要备份xfs_ifork->if_u1->if_data数据
   - 检查xfs_inode_log_item->ili_fields包含XFS_ILOG_DDATA/XFS_ILOG_ADATA, 需要把数据复制到xfs_buf中
   - 如果是XFS_DINODE_FMT_EXTENTS, 需要备份什么数据?
   - 只有xfs_inode_log_item->ili_fields包含XFS_ILOG_DEXT/XFS_ILOG_AEXT才备份 
   > xfs_iextents_copy(xfs_inode, xfs_bmbt_rec, whichfork)
   - 如果是XFS_DINODE_FMT_BTREE, 备份btree的数据?
   - xfs_inode_log_item->ili_fields包含XFS_ILOG_DBROOT/XFS_ILOG_ABROOT 
   > xfs_bmbt_to_bmdr(xfs_mount, xfs_ifork->if_broot, xfs_ifork->if_broot_bytes, xfs_bmdr_block_t, XFS_DFORK_SIZE(xfs_inode, xfs_mount, whichfork))
   - 如果是XFS_DINODE_FMT_DEV, 而且xfs_inode_log_item->ili_fields包含XFS_ILOG_DEV
   - 把xfs_ifork的dev_t复制到xfs_dinode中 
   > xfs_dinode_put_rdev(xfs_dinode, xfs_ifork->i_df->if_u2->if_rdev)
   - 如果是XFS_DINODE_FMT_UUID,对应XFS_ILOG_UUID
   - 这里就是把xfs_ifork的数据往回写给xfs_dinode
   - log的标志决定写那些数据

** xfs_iflush_cluster(xfs_inode, xfs_buf)
   - flush一些xfs_inode?
   - 根据xfs_inode->i_ino找到xfs_perag 
   > xfs_perag_get(xfs_mount, XFS_INO_TO_AGNO(xfs_mount, xfs_inode->i_ino))
   - 准备当前cluster所有的xfs_inode, 个数是 inodes_per_cluster
   > XFS_INODE_CLUSTER_SIZE(xfs_mount) >> xfs_sb->sb_inodelog 
   - 上面cluster的单位是什么??
   - 查找radix, 找到第一个ino
   > XFS_INO_TO_AGINO(xfs_mount, xfs_inode->i_ino)
   > radix_tree_gang_lookup(xfs_perag->pag_ici_root, ilist, first_index, inodes_per_cluster)
   - 遍历这些xfs_inode
   - 检查是否需要flush?
   - 如果xfs_inode没有关联xfs_inode_log_item??
   > xfs_inode_clean(xfs_inode) 
   - 或者没有pin?
   > xfs_ipincount(xfs_inode)
   - 锁住xfs_inode, 为何使用shared锁?
   > xfs_ilock_nowait(xfs_inode, XFS_ILOCK_SHARED)
   - 锁住flush操作? 和当前的flush是一回事么?
   - 如果pincount > 0， 不能flush??
   - 如果xfs_inode不是clean 
   > xfs_iflush_int(xfs_inode, xfs_buf)

** xfs_iflush(xfs_inode, xfs_buf)
   - 把metadata数据写回磁盘
   - 首先等待pin操作? 或者log操作? 
   > xfs_iunpin_wait(xfs_inode) 
   - 如果xfs_inode无效? 直接返回  
   > xfs_iflags_test(xfs_inode, XFS_ISTALE)
   - 找到对应的xfs_buf, 包含对应的xfs_dinode 
   > xfs_imap_to_bp(xfs_mount, NULL, xfs_inode->xfs_imap, xfs_dinode, xfs_buf, XBF_TRYLOCK, 0)
   - flush 
   > xfs_iflush_int(xfs_inode, xfs_buf)
   - 如果xfs_inode在log中 ?? 
   > xfs_buf_ispinned(xfs_buf)
   - 启动log? 
   > xfs_log_force(xfs_mount, 0)
   - flush cluster
   > xfs_iflush_cluster(xfs_inode, xfs_buf)

** xfs_iflush_int(xfs_inode, xfs_buf)
   - 找到对应的xfs_dinode 
   > xfs_buf_offset(xfs_buf, xfs_inode->xfs_imap->im_boffset)
   - 检查数据有效性
   - xfs_dinode->di_magic, xfs_inode->xfs_icdinode->di_magic
   - xfs_dinode->di_mode, xfs_dinode->di_format
   - 把xfs_inode->xfs_icdinode的数据写回xfs_dinode
   - 整个写回..
   > xfs_dinode_to_disk(xfs_dinode, xfs_inode->xfs_icdinode)
   - 写回xfs_ifork, 需要根据xfs_inode_log_item的标志写回
   > xfs_iflush_fork(xfs_inode, xfs_dinode, xfs_inode_log_item, XFS_DATA_FORK, xfs_buf)
   > xfs_iflush_fork(xfs_inode, xfs_dinode, xfs_inode_log_item, XFS_ATTR_FORK, xfs_buf)
   - 检查xfs_dinode 
   > xfs_inobp_check(xfs_mount, xfs_buf)
   - 上面使用xfs_inode_log_item->ili_fields表示metadata的修改, 所以在log写回之前,是不能再修改inode
   - 根据注释,这里把log使用的保存到xfs_inode_log_item->ili_last_fields 
   - 提交ail数据??
   > xfs_trans_ail_copy_lsn(xfs_mount->xfs_ail, xfs_inode_log_item->ili_flush_lsn, xfs_inode_log_item->xfs_log_item->li_lsn)
   - 注册ail回调函数? 
   > xfs_buf_attach_iodone(xfs_buf, xfs_iflush_done, xfs_inode_log_item->xfs_log_item)
   - 构造xfs_dinode的crc? 
   > xfs_dinode_calc_crc(xfs_mount, xfs_dinode)

** xfs_iext_get_ext(xfs_ifork, xfs_extnum_t idx)
   - 查找xfs_ifork中的xfs_bmbt_rec_host? 
   - 对于文件数据,应该是xfs_extnum_t索引的extent信息
   - 如果使用XFS_IFEXTIREC, 而且idx=0
   - 快捷操作, 第一个xfs_ext_irec的第一个xfs_bmbt_rec_host
   > xfs_ifork->if_u1->xfs_ext_irec->xfs_bmb_rec_host
   - 如果idx != 0, 先找到对应的xfs_ext_irec 
   > xfs_iext_idx_to_irec(xfs_ifork, xfs_extnum_t page_idx, idx, 0)
   - 返回xfs_ext_irec->xfs_bmbt_rec_host[page_idx)
   - 如果不使用XFS_IFEXTIREC, ext信息保存在xfs_ifork->if_u1->if_extents中 

** xfs_iext_insert(xfs_inode, xfs_extnum_t idx, xfs_extnum_t count, xfs_bmbt_irec_t, state)
   - 插入extent数据
   - 首先扩展xfs_ifork 
   > xfs_iext_add(xfs_ifork, idx, count) 
   - 然后遍历idx, 把xfs_bmbt_irec数据转化为xfs_bmbt_rec_host
   > xfs_bmbt_set_all(xfs_iext_get_ext(xfs_ifork, i), xfs_bmbt_irec)

** xfs_iext_add(xfs_ifork, xfs_extnum_t idx, ext_diff)
   - 改版xfs_ifork的保存extent的内存大小
   - xfs_ifork->if_bytes表示extent使用的内存量
   - 改变之前的extent数量是
   - xfs_ifork->if_bytes / sizeof(xfs_bmbt_rec)
   - xfs_bmbt_rec和xfs_bmbt_rec_host一样大??
   - 如果增大后的extent的数量不超过XFS_INLINE_EXTS (2)
   - 使用xfs_ifork->if_u2->if_inline_ext
   - 如果idx和目前的extent重合,需要搬运数据
   - 设置xfs_ifork->if_real_bytes = 0
   - 如果不超过XFS_LINEAR_EXTS
   - 分配内存保存这些xfs_bmbt_rec
   > xfs_iext_realloc_direct(xfs_ifork, new_size)
   - 需要释放原来的xfs_ifork->if_u1->if_extents, 而且搬运数据
   - 否则使用xfs_ext_irec数组保存xfs_bmbt_rec_host
   - 如果原来不是XFS_IFEXTIREC, 需要初始化xfs_ext_irec 
   > xfs_iext_irec_init(xfs_ifork)
   - 否则找到对应的xfs_ext_irec 
   > xfs_iext_idx_to_irec(xfs_ifork, page_idx, ext_idx, 1)
   - 如果xfs_ext_irec还有包含xfs_bmbt_rec_host, 也就是xfs_ext_irec->er_extcount + ext_diff < XFS_LINEAR_EXTS
   - 更新这个xfs_ext_irec, 搬运数据
   - 设置xfs_ext_irec->er_extcount
   - 更新后面的xfs_ext_irec->er_extoff
   - 这个数表示当前的xfs_ext_irec的第一个ext的索引
   > xfs_iext_irec_update_extoffs(xfs_ifork, xfs_extnum_t, ext_diff)
   - 否则添加新的xfs_ext_irec数组，这样就复杂了,可能把当前的xfs_ext_irec拆分??
   > xfs_iext_add_indirect_multi(xfs_ifork, erp_idx, page_idx, ext_diff)
   - 如果之前没有xfs_ext_irec, 创建新的, 不用搬运数据
   > xfs_iext_irec_new(xfs_ifork, erp_idx) 
   - 创建后设定xfs_ext_irec的er_extcount, er_idx, 虽然里面还没有有效的xfs_bmbmt_rec_host

** xfs_iext_add_indirect_multi(xfs_ifork, erp_idx, xfs_extnum_t, count)
   - 增加xfs_ext_irec中xfs_bmbt_rec_host的数量
   - erp_idx索引xfs_ext_irec, xfs_extnum_t索引里面的xfs_bmbt_rec_host
   - 当然xfs_ext_irec不够用的
   - 如果xfs_extnum_t索引xfs_ext_irec的中间,后一部分的数据需要搬运, 先保存到一个临时地方
   - 首先把erp_idx填满, 这个xfs_ext_irec->er_extcount已经减去需要搬运的xfs_bmbt_rec_host
   - count -= (XFS_LINEAR_EXTS - xfs_ext_irec->er_extcount)
   - 然后添加新的xfs_ext_irec 
   > xfs_iext_irec_new(ifork, erp_idx)
   - 上面每次修改,都回更新其他xfs_ext_irec->er_extoffs
   - 然后把临时保存起来的xfs_bmbt_rec_host数组填充进来
   - 首先考虑新的xfs_ext_irec, 如果它的空间足够, 就直接放进来
   - 如果不够,检查下一个xfs_ext_irec, 否则创建新的
   - 但就是不会分裂？？
   > xfs_iext_irec_new(xfs_ifork, erp_idx)
  
** xfs_iext_remove(xfs_inode, xfs_extnum_t, ext_diff, state)
   - xfs_ifork保存in core xfs_bmbt_rec_host的内存减小
   - 首先计算减小后的空间
   - xfs_ifork->if_bytes / sizeof(xfs_bmbt_rec) - ext_diff
   - 如果减为0, 直接释放所有的ext数据
   > xfs_iext_destroy(xfs_ifork)
   - 如果现在使用XFS_IFEXTIREC, 减小xfs_ext_irec数组 
   > xfs_iext_remove_indirect(xfs_ifork, idx, ext_diff)
   - 如果不使用XFS_IFEXTIREC, 而且之前使用动态内存
   - xfs_ifork->if_real_bytes > 0, 减小动态内存,可能回转为使用inline内存 
   > xfs_iext_remove_direct(xfs_ifork, idx, ext_diff)
   - 否则直接修改inline的使用量 
   > xfs_iext_remove_inline(xfs_ifork, idx, ext_diff)
   - 最后更新xfs_ifork->if_bytes = new_size

** xfs_iext_remove_inline(xfs_ifork, xfs_extnum_t, ext_diff)
   - 现在xfs_ifork使用inline保存xfs_bmbt_rec_host数组
   - 检查xfs_ifork->if_flags没有XFS_IFEXTIREC
   - idx和修改后的ext数据量都不超过XFS_INLINE_EXTS
   - 如果需要删除的不再最后,需要搬运数据
   - 而且清空释放的内存

** xfs_iext_remove_direct(xfs_ifork, xfs_extnum_t, ext_diff)
   - 现在xfs_ifork使用动态内存保存xfs_bmbt_rec_host数据
   - xfs_ifork->if_flags没有XFS_IFEXTIREC
   - 首先删除的部分是否在最后, 不用移动数据
   - 否则先移动数据, 而且清空??
   - 调整使用的内存,如果太少,转为使用inline内存 
   > xfs_iext_realloc_direct(xfs_ifork, new_size)
   - 设置xfs_ifork->if_bytes = new_size

** xfs_iext_remove_indirect(xfs_ifork, xfs_extnum_t, count)
   - 现在xfs_ifork使用xfs_ext_irec存储xfs_bmbt_rec_host
   - 遍历参数覆盖的xfs_ext_irec
   - 第一个和最后一个应该是减小长度，可能回搬运数据
   - 中间的直接删除xfs_ext_irec
   - 首先第一个xfs_ext_irec的索引,和它内部的xfs_bmbt_rec_host的索引
   > xfs_iext_idx_to_irec(xfs_ifork, page_idx, erp_idx, 0)
   - 对于需要删除整个xfs_ext_irec的 
   > xfs_iext_irec_remove(xfs_ifork, erp_idx)
   - 它不仅释放xfs_ext_irec, 也会更新xfs_ifork->if_u1->if_ext_irec
   - 对于删除一部分的, 只需要搬运后一部分
   - 更新当前xfs_ext_irec, er_extcount
   - 更新后面的xfs_ext_irec的ex_extoffs
   > xfs_iext_irec_update_extoffs(xfs_ifork, idx, -ext_diff)
   - 最后更新xfs_ifork->if_bytes -= count * sizeof(xfs_bmbt_rec), 它表示xfs_bmbt_rec的数据量
   - 如果xfs_bmbt_rec太少,可切换为linear或inline的存储方式 
   > xfs_iext_irec_compact(xfs_ifork)

** xfs_iext_realloc_direct(xfs_ifork, new_size)
   - 更新使用linear方式存储的xfs_ifork
   - 现在它必须是linear(direct)释放存储
   - xfs_ifork->if_flags没有XFS_IFEXTIREC
   - 如果new_size == 0, 释放释放 
   > xfs_iext_destroy(xfs_ifork)
   - 如果xfs_ifork->if_real_bytes > 0, 原来使用动态内存
   - 如果new_size <= XFS_INLINE_EXTS * sizeof(xfs_bmbt_rec), 改为使用inline方式
   > xfs_iext_direct_to_inline(xfs_ifork, new_size / sizeof(xfs_bmbt_rec))
   - 否则更新原来的动态内存, 但这里分配的内存是2的幂次方对齐
   - 如果原来没有使用分配的动态内存,也就是inline存储 
   > xfs_iext_inline_to_direct(xfs_ifork, rnew_size)
   - 更新xfs_ifork->if_real_bytes = rnew
   - xfs_ifork->if_bytes = new_size

** xfs_iext_direct_to_inline(xfs_ifork, xfs_extnum_t)
   - 现在使用动态内存存储,转为使用inline内存
   - 直接把xfs_ifork->if_u1->if_extents中的数据复制给xfs_ifork->if_u2->if_inline_ext
   - 设置xfs_ifork->if_real_bytes = 0

** xfs_iext_inline_to_direct(xfs_ifork, new_size)
   - 现在是inline方式,转为动态内存方式
   - 分配内存, 搬运数据
   - 设置xfs_ifork->if_real_bytes = new_size

** xfs_iext_realloc_indirect(xfs_ifork, new_size)
   - 现在xfs_ifork使用indirect方式存储
   - xfs_ifork->if_flags必须有XFS_IFEXTIREC
   - new_size表示xfs_ifork->if_u1->if_ext_irec数组的新的长度, 改变它的长度
   - xfs_ifork->if_real_bytes表示它, 但需要计算
   - xfs_ifork->if_real_bytes / XFS_IEXT_BUFSZ * sizeof(xfs_ext_irec)
   - if_real_bytes表示能容纳的xfs_bmbt_rec的数量
   - if_bytes表示使用保存的xfs_bmbt_rec的数量

** xfs_iext_indirect_to_direct(xfs_ifork)
   - 从indirection方式变为linear/direct方式
   - 现在xfs_ifork->if_flags包含XFS_IFEXTIREC
   - 而且xfs_ifork中的xfs_bmbt_rec的数量 <= XFS_INLINE_EXTS
   - xfs_ifork->if_bytes / sizeof(xfs_bmbt_rec)
   - 首先压缩xfs_ext_irec?
   > xfs_iext_irec_compact_pages(xfs_ifork)
   - 而且是压缩成一个 xfs_ifork->if_real_bytes = XFS_IEXT_BUFSZ
   - 然后直接利用xfs_ext_irec->xfs_bmbm_rec的内存
   - xfs_ifork->if_u1->if_ext_irec = xfs_ifork->if_u1->if_ext_irec->er_extbuf
   - 释放xfs_ext_irec数组
   - 如果xfs_bmbt_ext数量太少,更新它的长度 
   > xfs_iext_realloc_direct(xfs_ifork, size)

** xfs_iext_destroy(xfs_ifork)
   - 释放extent数据,包括
   - indirect模式下的xfs_ext_irec数组
   > xfs_iext_irec_remove(xfs_ifork, idx)
   - direct模式下的xfs_ifork->if_u1->if_extents数组
   - inline模式下只会重写xfs_ifork->if_u2->if_inline_ext
   - 最后设置if_real_bytes, if_bytes

** xfs_iext_bno_to_ext(xfs_ifork, xfs_fileoff_t bno, xfs_extnum_t)
   - 查找bno对应的xfs_bmbt_rec_host??
   - 这里没有把结果考出来,而是找到对应的索引,可以向前遍历
   - 对于indirection模式, 找到对应的xfs_ext_irec 
   - 然后在xfs_ext_irec->er_extbuf中遍历
   > xfs_iext_bno_to_irec(xfs_ifork, bno, erp_idx)
   - 对于其他的,从xfs_ifork->if_u1->if_extents开始遍历
   - 使用2分查找
   - 对于xfs_bmbt_rec_host, 需要计算文件偏移和长度
   > xfs_bmbt_get_startoff(xfs_bmbt_rec_host)
   > xfs_bmbt_get_blockcount(xfs_bmbt_rec_host)
   - 最好找到的xfs_bmbt_rec_host,要不覆盖bno, 要不就在bno的后面
   - xfs_extnum_t返回这个xfs_bmbt_rec_host的索引

** xfs_iext_bno_to_irec(xfs_ifork, xfs_fileoff_t bno, erp_idx)
   - 查找xfs_ext_irec, 它的xfs_bmbt_rec_host覆盖bno
   - 同样使用2分查找方式
   - 比较xfs_ext_irec的第一个xfs_bmbt_rec_host的文件偏移

** xfs_iext_idx_to_irec(xfs_ifork, xfs_extnum_t, erp_idx, realloc)
   - 采用2分查找方式
   - 这里需要处理realloc
   - 如果realloc == 0, 表示要查找对应的xfs_bmbt_rec, 必须精确
   - 如果realloc !=0, 表示要改变空间? 如果对应的xfs_bmbt_rec前面的xfs_ext_irec有空闲,就返回空闲的xfs_bmbt_rec的索引

** xfs_iext_irec_init(xfs_ifork)
   - 初始化xfs_ifork->if_u1->xfs_ext_irec数组
   - 数组长度为1,里面有XFS_IEXT_BUFSZ的xfs_bmbt_rec
   - 这是不确定xfs_ifork使用什么模式保存xfs_bmbt_rec
   - 如果还没有, 直接创建xfs_ext_irec->er_extbuf数组, 但它创建了给xfs_ifork->if_u1->if_extents
   - 如果原来是inline模式, 先变为inline模式 
   > xfs_iext_inline_to_direct(xfs_ifork, XFS_IEXT_BUFSZ)
   - 如果原来是linear模式,改变xfs_bmbt_rec长度
   > xfs_iext_realloc_direct(xfs_ifork, XFS_IEXT_BUFSZ)
   - 上面这些操作都是为了准备好xfs_ifork->if_u1->if_extents, 让第一个xfs_ext_irec->er_extbuf使用它
   - 设置xfs_ifork->if_flags的XFS_IFEXTIREC
   - if_real_bytes = XFS_IEXT_BUFSZ
   - if_bytes = nextents * sizeof(xfs_bmbt_rec_t)

** xfs_iext_irec_new(xfs_ifork, erp_idx)
   - 在xfs_ifork->if_u1->xfs_ext_irec数组中erp_idx处添加一个新的
   - 首先增加xfs_ext_irec数组的大小 
   > xfs_iext_realloc_indirect(xfs_ifork, nlists * sizeof(xfs_ext_irec))
   - 移动数组后半部分的数据
   - 初始化当前的xfs_ext_irec 
   - 创建xfs_bmbt_irec数组, er_extcount = 0, er_extoff根据前一个xfs_ext_irec计算

** xfs_iext_irec_remove(xfs_ifork, erp_idx)
   - 删除erp_idx索引的xfs_ext_irec
   - 首先如果xfs_ext_irec->er_extcount > 0, 修改它后面的xfs_ext_irec的索引 
   > xfs_iext_irec_update_extoffs(xfs_ifork, idx, - xfs_ext_irec->er_extcount)
   - 移动xfs_ext_irec数组内容
   - 修改数组长度 
   > xfs_iext_realloc_indirect(xfs_ifork, nlists * sizeof(xfs_ext_irec)
   - 更新xfs_ifork->if_real_bytes = nlist * XFS_IEXT_BUFSZ

** xfs_iext_irec_compact(xfs_ifork)
   - xfs_ifork当前使用indirect模式,而且它的extent比较少,检查是否变为其他模式
   - 它的xfs_bmbt_rec数量是 xfs_ifork->if_bytes / sizeof(xfs_bmbt_rec)
   - 如果为0, 释放释放 
   > xfs_iext_destroy(xfs_ifork)
   - 如果<= XFS_INLINE_EXTS
   - 首先变为direct模式, 这里没有制定nextents的数量, 因为回直接使用if_bytes
   > xfs_iext_indirect_to_direct(xfs_ifork)
   - 然后变为inline模式, 实际上这一步是多余的!!
   > xfs_iext_direct_to_inline(xfs_ifork, nextents)
   - 如果 <= XFS_LINEAR_EXTS, 变为direct
   > xfs_iext_indirect_to_direct(xfs_ifork)
   - 最后如果xfs_ext_irec使用率太低, 50%,压缩xfs_ext_irec 
   > xfs_iext_irec_compact_pages(xfs_ifork)

** xfs_iext_irec_compact_pages(xfs_ifork)
   - 这里的压缩之检查相邻的2个xfs_ext_irec
   - 如果一个xfs_ext_irec能合并下一个, 就释放下一个
   > xfs_iext_irec_remove(xfs_ifork, idx)
   - 而不会完全压缩

** xfs_iext_irec_update_extoffs(xfs_ifork, erp_idx, ext_diff)
   - 在indirect模式下,如果中间的一个xfs_ext_irec->er_extcount改变
   - 它后面的xfs_ext_irec->er_extoff必须相应的改变
   - 遍历这些xfs_ext_irec 
   > xfs_ifork->if_u1->if_ext_irec[i]->ex_extoff += ext_diff

** xfs_can_free_eofblocks(xfs_inode, force)
   - 是否需要释放多余的extent/block??
   - xfs_inode->xfs_ifork->if_flags的XFS_IFEXTENTS表示已经把extents信息复制到xfs_ifork中
   - 如果没有XFS_IFEXTENTS, 不需要释放?
   - 对于preallocation,或者append? 如果不是force或没有延时分配,也不需要??
   - xfs_inode->i_delayed_blks == 0
   
* xfs_trans_inode.c

** xfs_trans_ijoin(xfs_trans, xfs_inode, lock_flags)
   - 把xfs_inode加到xfs_trans中.
   - 如果xfs_inode->i_itemp无效,创建新的xfs_inode_log_item
   > xfs_inode_item_init(xfs_inode, xfs_mount)
   - 把xfs_inode_log_item放到xfs_trans中
   > xfs_trans_add_item(xfs_trans, xfs_inode_log_item->xfs_log_item)

** xfs_trans_ichgtime(xfs_trans, xfs_inode, flags)
   - 更新inode的时间?  和xfs_trans没关系??
   - 如果flags包含XFS_ICHGTIME_MOD, 更新mtime
   - xfs_inode->xfs_icdinode->di_mtime
   - 如果flags包含XFS_ICHGTIME_CHG, 更新ctime
   - xfs_inode->xfs_icdinode->di_ctime

** xfs_trans_log_inode(xfs_trans, xfs_inode, flags)
   - 设置xfs_trans->t_flags的XFS_TRANS_DIRTY, xfs_inode->xfs_inode_log_item->xfs_log_item->xfs_log_item_desc->lid_flags的XFS_LID_DIRTY
   - 把flags存储到xfs_inode->xfs_inode_log_item->ili_fields中. 包括xfs_inode->xfs_inode_log_item->ili_last_fields


