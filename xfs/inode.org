* xfs_dinode.h

** di_flags
   #+begin_src 
#define XFS_DIFLAG_REALTIME_BIT  0	/* file's blocks come from rt area */
#define XFS_DIFLAG_PREALLOC_BIT  1	/* file space has been preallocated */
#define XFS_DIFLAG_NEWRTBM_BIT   2	/* for rtbitmap inode, new format */
#define XFS_DIFLAG_IMMUTABLE_BIT 3	/* inode is immutable */
#define XFS_DIFLAG_APPEND_BIT    4	/* inode is append-only */
#define XFS_DIFLAG_SYNC_BIT      5	/* inode is written synchronously */
#define XFS_DIFLAG_NOATIME_BIT   6	/* do not update atime */
#define XFS_DIFLAG_NODUMP_BIT    7	/* do not dump */
#define XFS_DIFLAG_RTINHERIT_BIT 8	/* create with realtime bit set */
#define XFS_DIFLAG_PROJINHERIT_BIT   9	/* create with parents projid */
#define XFS_DIFLAG_NOSYMLINKS_BIT   10	/* disallow symlink creation */
#define XFS_DIFLAG_EXTSIZE_BIT      11	/* inode extent size allocator hint */
#define XFS_DIFLAG_EXTSZINHERIT_BIT 12	/* inherit inode extent size */
#define XFS_DIFLAG_NODEFRAG_BIT     13	/* do not reorganize/defragment */
#define XFS_DIFLAG_FILESTREAM_BIT   14  /* use filestream allocator */
   
   #+end_src

** xfs_dinode
   #+begin_src 
	__be16		di_magic;	/* inode magic # = XFS_DINODE_MAGIC */
	__be16		di_mode;	/* mode and type of file */
	__u8		di_version;	/* inode version */
	__u8		di_format;	/* format of di_c data */
	__be16		di_onlink;	/* old number of links to file */
	__be32		di_uid;		/* owner's user id */
	__be32		di_gid;		/* owner's group id */
	__be32		di_nlink;	/* number of links to file */
	__be16		di_projid_lo;	/* lower part of owner's project id */
	__be16		di_projid_hi;	/* higher part owner's project id */
	__u8		di_pad[6];	/* unused, zeroed space */
	__be16		di_flushiter;	/* incremented on flush */
	xfs_timestamp_t	di_atime;	/* time last accessed */
	xfs_timestamp_t	di_mtime;	/* time last modified */
	xfs_timestamp_t	di_ctime;	/* time created/inode modified */
	__be64		di_size;	/* number of bytes in file */
	__be64		di_nblocks;	/* # of direct & btree blocks used */
	__be32		di_extsize;	/* basic/minimum extent size for file */
	__be32		di_nextents;	/* number of extents in data fork */
	__be16		di_anextents;	/* number of extents in attribute fork*/
	__u8		di_forkoff;	/* attr fork offs, <<3 for 64b align */
	__s8		di_aformat;	/* format of attr fork's data */
	__be32		di_dmevmask;	/* DMIG event mask */
	__be16		di_dmstate;	/* DMIG state info */
	__be16		di_flags;	/* random flags, XFS_DIFLAG_... */
	__be32		di_gen;		/* generation number */

	/* di_next_unlinked is the only non-core field in the old dinode */
	__be32		di_next_unlinked;/* agi unlinked list ptr */

	/* start of the extended dinode, writable fields */
	__le32		di_crc;		/* CRC of the inode */
	__be64		di_changecount;	/* number of attribute changes */
	__be64		di_lsn;		/* flush sequence */
	__be64		di_flags2;	/* more random flags */
	__u8		di_pad2[16];	/* more padding for future expansion */

	/* fields only written to during inode creation */
	xfs_timestamp_t	di_crtime;	/* time created */
	__be64		di_ino;		/* inode number */
	uuid_t		di_uuid;	/* UUID of the filesystem */

	/* structure must be padded to 64 bit alignment */
   #+end_src
   -在磁盘中,inode后面还有2块数据di_u, di_a, 他们的内容根据di_format/di_aformat而定.

** di_format 
   #+BEGIN_SRC 
	XFS_DINODE_FMT_DEV,		/* xfs_dev_t */
	XFS_DINODE_FMT_LOCAL,		/* bulk data */
	XFS_DINODE_FMT_EXTENTS,		/* struct xfs_bmbt_rec */
	XFS_DINODE_FMT_BTREE,		/* struct xfs_bmdr_block */
	XFS_DINODE_FMT_UUID		/* uuid_t */   
   #+END_SRC

** di_flag
   #+BEGIN_SRC 
 */
#define XFS_DIFLAG_REALTIME_BIT  0	/* file's blocks come from rt area */
#define XFS_DIFLAG_PREALLOC_BIT  1	/* file space has been preallocated */
#define XFS_DIFLAG_NEWRTBM_BIT   2	/* for rtbitmap inode, new format */
#define XFS_DIFLAG_IMMUTABLE_BIT 3	/* inode is immutable */
#define XFS_DIFLAG_APPEND_BIT    4	/* inode is append-only */
#define XFS_DIFLAG_SYNC_BIT      5	/* inode is written synchronously */
#define XFS_DIFLAG_NOATIME_BIT   6	/* do not update atime */
#define XFS_DIFLAG_NODUMP_BIT    7	/* do not dump */
#define XFS_DIFLAG_RTINHERIT_BIT 8	/* create with realtime bit set */
#define XFS_DIFLAG_PROJINHERIT_BIT   9	/* create with parents projid */
#define XFS_DIFLAG_NOSYMLINKS_BIT   10	/* disallow symlink creation */
#define XFS_DIFLAG_EXTSIZE_BIT      11	/* inode extent size allocator hint */
#define XFS_DIFLAG_EXTSZINHERIT_BIT 12	/* inherit inode extent size */
#define XFS_DIFLAG_NODEFRAG_BIT     13	/* do not reorganize/defragment */   
   #+END_SRC

** xfs_icdinode
   - inode在磁盘上的格式
   #+begin_src 
	__uint16_t	di_magic;	/* inode magic # = XFS_DINODE_MAGIC */
	__uint16_t	di_mode;	/* mode and type of file */
	__int8_t	di_version;	/* inode version */

	__int8_t	di_format;	/* format of di_c data */  //对于不同的文件类型(di_mode),解析不一样, 表示inode后面数据的内容
	__uint16_t	di_onlink;	/* old number of links to file */
	__uint32_t	di_uid;		/* owner's user id */
	__uint32_t	di_gid;		/* owner's group id */
	__uint32_t	di_nlink;	/* number of links to file */
	__uint16_t	di_projid_lo;	/* lower part of owner's project id */
	__uint16_t	di_projid_hi;	/* higher part of owner's project id */
	__uint8_t	di_pad[6];	/* unused, zeroed space */
	__uint16_t	di_flushiter;	/* incremented on flush */
	xfs_ictimestamp_t di_atime;	/* time last accessed */
	xfs_ictimestamp_t di_mtime;	/* time last modified */
	xfs_ictimestamp_t di_ctime;	/* time created/inode modified */
	xfs_fsize_t	di_size;	/* number of bytes in file */  //eof
	xfs_drfsbno_t	di_nblocks;	/* # of direct & btree blocks used */
	xfs_extlen_t	di_extsize;	/* basic/minimum extent size for file */  //extent应该不受限制,这是最小限制?? 或者最小的磁盘分配空间
	xfs_extnum_t	di_nextents;	/* number of extents in data fork */
	xfs_aextnum_t	di_anextents;	/* number of extents in attribute fork*/  //为什么属性也需要exetnt?
	__uint8_t	di_forkoff;	/* attr fork offs, <<3 for 64b align */
	__int8_t	di_aformat;	/* format of attr fork's data */ //和di_format一样
	__uint32_t	di_dmevmask;	/* DMIG event mask */
	__uint16_t	di_dmstate;	/* DMIG state info */
	__uint16_t	di_flags;	/* random flags, XFS_DIFLAG_... */
	__uint32_t	di_gen;		/* generation number */

	/* di_next_unlinked is the only non-core field in the old dinode */
	xfs_agino_t	di_next_unlinked;/* agi unlinked list ptr */

        //di_aformat表示extent data attribute数据的位置,偏移相对于di_crc开始, 好像是0x64
	/* start of the extended dinode, writable fields */
	__uint32_t	di_crc;		/* CRC of the inode */
	__uint64_t	di_changecount;	/* number of attribute changes */
	xfs_lsn_t	di_lsn;		/* flush sequence */
	__uint64_t	di_flags2;	/* more random flags */
	__uint8_t	di_pad2[16];	/* more padding for future expansion */

	/* fields only written to during inode creation */
	xfs_ictimestamp_t di_crtime;	/* time created */
	xfs_ino_t	di_ino;		/* inode number */
	uuid_t		di_uuid;	/* UUID of the filesystem */

	/* structure must be padded to 64 bit alignment */
   #+end_src
   - data fork是inode后面的数据,对于不同的mode/format, 内容不一样
   - 如果是reg文件,data fork是表示数据磁盘空间的extent数据, 有2种extent:XFS_DINODE_FMT_EXTENTS和XFS_DINODE_FMT_BTREE
   - 对于XFS_DINODE_FMT_EXTENTS, 这里存储的是xfs_bmbt_rec_t数组
   - 对于XFS_DINODE_FMT_BTRFF, 这里存储的是btree根结点xfs_bmdr_block_t
   - 如果是dir文件,data fork是direcotry entries, 有3种表示
   - 对于XFS_DINODE_FMT_LOCAL, directory entries完全存在这里面,使用xfs_dir2_sf_t数组表示
   - 对于XFS_DINODE_FMT_EXTENTS, 使用专门的extent表示. 注意这里不是使用一个fsb,而是一个extent, 所以这里是xfs_bmbt_rec_t数组. extent的数组怎么定?
   - 对于XFS_DINODE_FMT_BTREE, 使用btree的叶子节点存储extent, btree操作应该复杂一些? 这里存储的是xfs_bmdr_block_t
   - 如果是symlink, 有2中, XFS_DINODE_FMT_LOCAL/XFS_DINODE_FMT_EXTENTS
   - 如果是block/chr文件,format应该是FXS_DINODE_FMT_DEV, 里面存储xfs_dev_t

** xfs_inode 
   #+begin_src 
	/* Inode linking and identification information. */
	struct xfs_mount	*i_mount;	/* fs mount struct ptr */
	struct xfs_dquot	*i_udquot;	/* user dquot */
	struct xfs_dquot	*i_gdquot;	/* group dquot */

	/* Inode location stuff */
	xfs_ino_t		i_ino;		/* inode number (agno/agino)*/
	struct xfs_imap		i_imap;		/* location for xfs_imap() */

	/* Extent information. */
	xfs_ifork_t		*i_afp;		/* attribute fork pointer */
	xfs_ifork_t		i_df;		/* data fork */

	/* Transaction and locking information. */
	struct xfs_inode_log_item *i_itemp;	/* logging information */
	mrlock_t		i_lock;		/* inode lock */
	mrlock_t		i_iolock;	/* inode IO lock */
	atomic_t		i_pincount;	/* inode pin count */
	spinlock_t		i_flags_lock;	/* inode i_flags lock */
	/* Miscellaneous state. */
	unsigned long		i_flags;	/* see defined flags below */
	unsigned int		i_delayed_blks;	/* count of delay alloc blks */

	xfs_icdinode_t		i_d;		/* most of ondisk inode */

	/* VFS inode */
	struct inode		i_vnode;	/* embedded VFS inode */
   #+end_src

   - xfs_inode包装inode/xfs_icdinode, 其他的结构和文件系统其他功能关联. mount/dquot/extent/log等.

** xfs_imap
   #+begin_src 
	xfs_daddr_t	im_blkno;	/* starting BB of inode chunk */
	ushort		im_len;		/* length in BBs of inode chunk */
	ushort		im_boffset;	/* inode offset in block in bytes */
   #+end_src
   - 保存inode的磁盘位置信息.

** xfs_ifork 
   #+begin_src 
	int			if_bytes;	/* bytes in if_u1 */
	int			if_real_bytes;	/* bytes allocated in if_u1 */
	struct xfs_btree_block	*if_broot;	/* file's incore btree root */
	short			if_broot_bytes;	/* bytes allocated for root */
	unsigned char		if_flags;	/* per-fork flags */
	union {
		xfs_bmbt_rec_host_t *if_extents;/* linear map file exts */
		xfs_ext_irec_t	*if_ext_irec;	/* irec map file exts */
		char		*if_data;	/* inline file data */
	} if_u1;
	union {
		xfs_bmbt_rec_host_t if_inline_ext[XFS_INLINE_EXTS];
						/* very small file extents */
		char		if_inline_data[XFS_INLINE_DATA];
						/* very small file data */
		xfs_dev_t	if_rdev;	/* dev number if special */
		uuid_t		if_uuid;	/* mount point value */
	} if_u2;
        //if_u1和if_u2的用途不同, if_u2给if_u1提供空间. 如果需要的空间很小, if_u1可直接使用if_u2的.
   #+end_src

** xfs_dinode_fmt
   #+begin_src 
typedef enum xfs_dinode_fmt {
	XFS_DINODE_FMT_DEV,		/* xfs_dev_t */
	XFS_DINODE_FMT_LOCAL,		/* bulk data */
	XFS_DINODE_FMT_EXTENTS,		/* struct xfs_bmbt_rec */ 
	XFS_DINODE_FMT_BTREE,		/* struct xfs_bmdr_block */
	XFS_DINODE_FMT_UUID		/* uuid_t */
} xfs_dinode_fmt_t;
   #+end_src
   - 对于regular
   - XFS_DINODE_FMT_EXTENTS: extents队列在di_a中
   - XFS_DINODE_FMT_BTREE: extents使用btree保存,root在di_a中
   - 对于directory 
   - XFS_DINODE_LOCAL: di_a中是xfs_dir2_sf
   - XFS_DINODE_EXTENTS: directory item在extent中保存,extent队列在di_a中.
   - XFS_DINODE_BTREE: directory item在btree的叶子中保存,root在di_a中.

** xfs_bmdr_block
   #+begin_src 
	__be16		bb_level;	/* 0 is a leaf */
	__be16		bb_numrecs;	/* current # of data records */
   #+end_src

** xfs_btree_block
   #+begin_src 
	__be32		bb_magic;	/* magic number for block type */
	__be16		bb_level;	/* 0 is a leaf */
	__be16		bb_numrecs;	/* current # of data records */
	union {
		struct {
			__be32		bb_leftsib;
			__be32		bb_rightsib;

			__be64		bb_blkno;
			__be64		bb_lsn;
			uuid_t		bb_uuid;
			__be32		bb_owner;
			__le32		bb_crc;
		} s;			/* short form pointers */
		struct	{
			__be64		bb_leftsib;
			__be64		bb_rightsib;

			__be64		bb_blkno;
			__be64		bb_lsn;
			uuid_t		bb_uuid;
			__be64		bb_owner;
			__le32		bb_crc;
			__be32		bb_pad; /* padding for alignment */
		} l;			/* long form pointers */
	} bb_u;				/* rest */
   #+end_src

** xfs_exntst_t 
   #+begin_src 
	XFS_EXT_NORM, XFS_EXT_UNWRITTEN,
	XFS_EXT_DMAPI_OFFLINE, XFS_EXT_INVALID
	// extent state??
   #+end_src
   
** xfs_bmbt_irec
   #+begin_src 
	xfs_fileoff_t	br_startoff;	/* starting file offset */
	xfs_fsblock_t	br_startblock;	/* starting block number */
	xfs_filblks_t	br_blockcount;	/* number of blocks */
	xfs_exntst_t	br_state;	/* extent state */
	//文件的extent数据
   #+end_src

** xfs_exntfmt 
   #+begin_src 
	XFS_EXTFMT_NOSTATE = 0,
	XFS_EXTFMT_HASSTATE
   #+end_src

**

** 总结
   - 读取inode的metadata数据,很2部分, 一个是普通元数据,比如目录项或extents,还有一种是extent attr.
   - 对于XFS_DATA_FORK, 也就是普通metadaa, xfs_inode->xfs_ifork,把数据保存到xfs_inode->i_df (xfs_ifork)
   - XFS_DINODE_FMT_LOCAL,  把数据直接放到xfs_ifork->if_u1->if_data中
   - XFS_DINODE_FMT_EXTENTS, 数据是xfs_bmbt_rec数组,长度是xfs_dinode->nextents. 把数据放到xfs_ifork->if_u1->if_extents中.
   - XFS_DINODE_FMT_BTREE, 数据是xfs_bmdr_block, 大小根据它计算. 把数据给xfs_ifork->if_broot, 这是xfs_btree_block
   - 对于XFS_XATTR_FORK, 把数据给xfs_inode->i_afp. 具体的也很3种情况,和上面一样.
   - 打开inode时的顺序是,根据ino找到xfs_imap, 得到具体的FSB地址和内部偏移, 然后读回对应的数据到xfs_buf, 验证xfs_dinode数据, 然后读回inode的数据给xfs_icdinode; 然后是xfs_ifork.
   - 在分配inode时,先创建xfs_dinode, 然后使用vfs结构创建inode,然后把参数设置xfs_inode

* xfs_inode.c
  - 这里管理xfs_ifork的数据. 

** xfs_get_extsz_hint(xfs_inode)
   - 获取inode的extent的默认大小, 没看出来哪里使用??
   - 只有inode使用XFS_DIFLAG_EXTSIZE时,返回xfs_inode->xfs_dinode->di_extsize

** xfs_ilock_map_shared(xfs_inode)
   - 如果inode的data fork里面的数据是btree, 需要先把他们读进来
   - 但读操作需要互斥
   - xfs_dinode->di_format是XFS_DINODE_FMT_BTREE
   - 而且xfs_inode->if_flags有XFS_IFEXTENTS!=0, 表示总的extent数量>0?
   - 如果需要读这些数据,使用XFS_ILOCK_EXCL锁
   - 否则使用XFS_ILOCK_SHARED锁 
   > xfs_ilock(xfs_inode, lock_mode)

** xfs_iunlock_map_shared(xfs_inode, lock_mode) 
   > xfs_iunlock(xfs_inode, lock_mode)

** xfs_ilock(xfs_inode, lock_flags)
   - xfs inode使用2个锁: i_iolock, i_lock, 而且2个锁都是读写锁
   - lock_flags可能包含2个锁
     #+BEGIN_SRC 
#define	XFS_IOLOCK_EXCL		(1<<0)
#define	XFS_IOLOCK_SHARED	(1<<1)
#define	XFS_ILOCK_EXCL		(1<<2)
#define	XFS_ILOCK_SHARED	(1<<3)
     #+END_SRC
   - 首先操作i_iolock, 然后是i_lock锁
   - 对于互斥锁
   > mrupdate_nested(xfs_inode->i_iolock, XFS_IOLOCK_DEP(lock_flags))
   - 对于共享锁 
   > mraccess_nested(xfs_inode->i_iolock, XFS_IOLOCK_DEP(lock_flags)

** xfs_ilock_nowait(xfs_inode, lock_flags)
   - 和上面一样
   - 不过锁操作不会等待,如果无法获取直接返回.
   - 如果获取了i_iolock, 但无法获取i_lock, 就释放i_iolock

** xfs_iunlock(xfs_inode, lock_flags)
   - 接锁, 顺序没有关系
   > trace_xfs_iunlock(xfs_inode, lock_flags, _RET_IP_)
   
** xfs_ilock_demote(xfs_inode, lock_flags)
   - 释放互斥锁, 或者写锁
   - lock_flags同样包括i_iolock和i_lock 
   > mrdemote(xfs_inode->i_lock)
   - 原来这些函数都是xfs包装的

   - 上面的锁使用rw_semaphore, 操作是
   > up_read()
   > up_write()
   > down_read_nested()
   > down_write_nested()

** xfs_isilocked(xfs_inode, lock_flags)
   > rwsem_is_locked(xfs_inode->i_lock->mr_lock

** __xfs_iflock(xfs_inode)
   - inode的flush操作时使用的锁
   - 等待xfs_inode->i_flags的__XFS_IFLOCK_BIT
   > prepare_to_wait_exclusive(wait_queue_head_t, wait_queue, TASK_UNINTERRUPTIBLE)
   - 检查上面的标志
   > xfs_isiflocked(xfs_inode)
   - 循环等待的条件时 
   > xfs_iflock_nowait(xfs_inode)
   - 也就是它结束等待后,也会锁住这个标志
   - xfs_inode->i_flags使用xfs_inode->i_flags_lock

** xfs_exntfmt
   #+BEGIN_SRC 
	XFS_EXTFMT_NOSTATE = 0,
	XFS_EXTFMT_HASSTATE   
   #+END_SRC

** xfs_validate_extents(xfs_ifork, nrecs, xfs_exntfmt)



* xfs_trans_inode.c

** xfs_trans_ijoin(xfs_trans, xfs_inode, lock_flags)
   - 把xfs_inode加到xfs_trans中.
   - 如果xfs_inode->i_itemp无效,创建新的xfs_inode_log_item
   > xfs_inode_item_init(xfs_inode, xfs_mount)
   - 把xfs_inode_log_item放到xfs_trans中
   > xfs_trans_add_item(xfs_trans, xfs_inode_log_item->xfs_log_item)

** xfs_trans_ichgtime(xfs_trans, xfs_inode, flags)
   - 更新inode的时间?  和xfs_trans没关系??
   - 如果flags包含XFS_ICHGTIME_MOD, 更新mtime
   - xfs_inode->xfs_icdinode->di_mtime
   - 如果flags包含XFS_ICHGTIME_CHG, 更新ctime
   - xfs_inode->xfs_icdinode->di_ctime

** xfs_trans_log_inode(xfs_trans, xfs_inode, flags)
   - 设置xfs_trans->t_flags的XFS_TRANS_DIRTY, xfs_inode->xfs_inode_log_item->xfs_log_item->xfs_log_item_desc->lid_flags的XFS_LID_DIRTY
   - 把flags存储到xfs_inode->xfs_inode_log_item->ili_fields中. 包括xfs_inode->xfs_inode_log_item->ili_last_fields


