* xfs_btree.c 

** xfs_btree_cur 
   #+BEGIN_SRC 
	struct xfs_trans	*bc_tp;	/* transaction we're in, if any */
	struct xfs_mount	*bc_mp;	/* file system mount struct */
	const struct xfs_btree_ops *bc_ops;
	uint			bc_flags; /* btree features - below */
	union {
		xfs_alloc_rec_incore_t	a;
		xfs_bmbt_irec_t		b;
		xfs_inobt_rec_incore_t	i;
	}		bc_rec;		/* current insert/search record value */
	struct xfs_buf	*bc_bufs[XFS_BTREE_MAXLEVELS];	/* buf ptr per level */
	int		bc_ptrs[XFS_BTREE_MAXLEVELS];	/* key/record # */
	__uint8_t	bc_ra[XFS_BTREE_MAXLEVELS];	/* readahead bits */
#define	XFS_BTCUR_LEFTRA	1	/* left sibling has been read-ahead */
#define	XFS_BTCUR_RIGHTRA	2	/* right sibling has been read-ahead */
	__uint8_t	bc_nlevels;	/* number of levels in the tree */
	__uint8_t	bc_blocklog;	/* log2(blocksize) of btree blocks */
	xfs_btnum_t	bc_btnum;	/* identifies which btree type */
	union {
		struct {			/* needed for BNO, CNT, INO */
			struct xfs_buf	*agbp;	/* agf/agi buffer pointer */
			xfs_agnumber_t	agno;	/* ag number */
		} a;
		struct {			/* needed for BMAP */
			struct xfs_inode *ip;	/* pointer to our inode */
			struct xfs_bmap_free *flist;	/* list to free after */
			xfs_fsblock_t	firstblock;	/* 1st blk allocated */
			int		allocated;	/* count of alloced */
			short		forksize;	/* fork's inode space */
			char		whichfork;	/* data or attr fork */
			char		flags;		/* flags */
#define	XFS_BTCUR_BPRV_WASDEL	1			/* was delayed */
		} b;
	}		bc_private;	/* per-btree type data */   
   #+END_SRC

** xfs_btree_block 
   - 这里的数据类型是大端的，所以应该是磁盘中的数据格式,使用时先转化
   #+BEGIN_SRC 
	__be32		bb_magic;	/* magic number for block type */
	__be16		bb_level;	/* 0 is a leaf */
	__be16		bb_numrecs;	/* current # of data records */
	union {
		struct {
			__be32		bb_leftsib;
			__be32		bb_rightsib;

			__be64		bb_blkno;
			__be64		bb_lsn;
			uuid_t		bb_uuid;
			__be32		bb_owner;
			__le32		bb_crc;
		} s;			/* short form pointers */
		struct	{
			__be64		bb_leftsib;
			__be64		bb_rightsib;

			__be64		bb_blkno;
			__be64		bb_lsn;
			uuid_t		bb_uuid;
			__be64		bb_owner;
			__le32		bb_crc;
			__be32		bb_pad; /* padding for alignment */
		} l;			/* long form pointers */
	} bb_u;				/* rest */   
   #+END_SRC

** xfs_magics
   - 各种magic
   #+BEGIN_SRC 
#define	XFS_ABTB_MAGIC		0x41425442	/* 'ABTB' for bno tree */
#define	XFS_ABTB_CRC_MAGIC	0x41423342	/* 'AB3B' */
#define	XFS_ABTC_MAGIC		0x41425443	/* 'ABTC' for cnt tree */
#define	XFS_ABTC_CRC_MAGIC	0x41423343	/* 'AB3C' */     
#define XFS_BMAP_MAGIC		0x424d4150	/* 'BMAP' */  //extentmap btree结点的头
#define XFS_BMAP_CRC_MAGIC	0x424d4133	/* 'BMA3' */
#define	XFS_IBT_MAGIC		0x49414254	/* 'IABT' */  //inode map btree结点的头
#define	XFS_IBT_CRC_MAGIC	0x49414233	/* 'IAB3' */
   #+END_SRC

** xfs_btnum_t 
   #+BEGIN_SRC 
	XFS_BTNUM_BNOi,   //对应XFS_ABTB_MAGIC
	XFS_BTNUM_CNTi,   //对应XFS_ABTC_MAGIC
	XFS_BTNUM_BMAPi,  //对应XFS_BMAP_MAGIC
	XFS_BTNUM_INOi,   //对应XFS_IBT_MAGIC
	XFS_BTNUM_MAX   
   #+END_SRC


** xfs_btree_check_lblock(xfs_btree_cur cur, xfs_btree_block block, level, xfs_buf)
   - 比较xfs_btree_block->bb_u->l->bb_uuid 和 xfs_sb->sb_uuid
   - 比较xfs_btree_block->bb_u->l->bb_blkno 和 xfs_buf->b_bn, 磁盘位置??
   - 比较magic, 根据xfs_btree_cur->bc_btnum计算使用的magic 
   > xfs_btree_magic(xfs_btree_cur)
   - 检查xfs_btree_block->level 和参数level
   - 检查xfs_btree_block->bb_numrecs, 不能超过上线
   > xfs_btree_cur->bc_ops->get_maxrecs(xfs_btree_cur, level)

** xfs_btree_check_sblock(xfs_btree_cur, xfs_btree_block, level, xfs_buf)
   - 这个和上面有什么区别??

** xfs_btree_check_block(xfs_btree_cur, xfs_btree_block, level, xfs_buf)
   - xfs_btree_cur->bc_flags的XFS_BTREE_LONG_PTRS表示什么?? 磁盘的指针?? 
   - 影响xfs_btree_block->bb_u->s的rightsib/leftsib
   > xfs_btree_check_lblock(xfs_btree_cur, xfs_btree_block, level, xfs_buf)
   > xfs_btree_check_sblock(xfs_btree_cur, xfs_btree_block, level, xfs_buf)

** xfs_btree_check_lptr(xfs_btree_cur, xfs_dfsbno_t bno, level)
   - 如果level>0, bno直线子结点??
   - 检查磁盘位置,包括agno, agbno 

** xfs_btree_check_sptr(xfs_btree_cur, xfs_agblock_t bno, level)
   - bno是ag内部偏移 
   > bno > xfs_btree_cur->xfs_mount->xfs_sb->sb_agblocks

** xfs_btree_check_ptr(xfs_btree_cur, xfs_btree_ptr, index, level)
   - xfs_btree_ptr是btree内部结点的value数组?? 指向子分支 
   - 如果xfs_btree_cur->bc_flags有XFS_BTREE_LONG_PTR
   - 检查对应的磁盘指针是否有意义
   > xfs_btree_check_ptr(xfs_btree_cur, xfs_btree_ptr->l[index], level)

** xfs_btree_lblock_calc_crc(xfs_buf)
   - 如果xfs版本表示不使用crc,直接退出 
   > xfs_sb_version_hascrc(xfs_buf->xfs_buftarg->xfs_mount->xfs_sb)
   - 如果buf有xfs_log_item? 更新xfs_btree_block 
   - xfs_btree_block->bb_u->l->ll_lsn = xfs_buf_log_item->xfs_log_item->li_lsn 
   - 计算crc, 只计算头部
   > xfs_update_cksum(xfs_buf->b_addr, BBTOB(xfs_buf->b_length), XFS_BTREE_LBLOCK_CRC_OFF)

** xfs_btree_lblock_verify_crc(xfs_buf)
   - 首先判断xfs版本,支持crc 
   > xfs_sb_version_hascrc(xfs_buf->xfs_buftarg->xfs_mount->xfs_sb)
   > xfs_verify_cksum(xfs_buf->b_addr, BBTOB(xfs_buf->b_length), XFS_BTREE_LBLOCK_CRC_OFF)

** xfs_btree_sblock_calc_crc(xfs_buf)
   - 上面的指针是64位,这里是32位 

** xfs_btree_sblock_verify_crc(xfs_buf)
   - 上面的指针是64位,这里是32位 

** xfs_btree_del_cursor(xfs_btree_cur, error)
   - 释放xfs_btree_cur遍历时使用的xfs_buf 
   > xfs_trans_brelse(xfs_btree_cur->xfs_trans, xfs_btree_cur->bc_bufs[i])
   - 如果btree是XFS_BTNUM_BMAP, 映射extent? xfs_btree_cur->bc_private->b->allocated === 0
   - 最后释放自己

** xfs_btree_dup_cursor(xfs_btree_cur, cur, xfs_btree_cur ncur)
   - 复制一个xfs_btree_cur, 需要增加哪些资源?? 
   > xfs_btree_cur->bc_ops-dup_cursor(xfs_btree_cur)
   - 复制xfs_btree_cur中的数据 xfs_btree_cur->bc_rec
   - 这些不是指针,而是btree中的具体记录, xfs_bmbt_irec/xfs_alloc_rec_incore等都已经把磁盘格式转化为内存格式
   - 遍历xfs_btree_cur使用的结点指针 xfs_btree_cur->bc_nlevels 
   - 重新读取数据??
   > xfs_trans_read_buf(xfs_mount, xfs_trans, xfs_mount->xfs_buftarg, XFS_BUF_ADDR(xfs_buf), xfs_mount->m_bsize, 0, xfs_buf, xfs_btree_cur->bc_ops->buf_ops)

** xfs_btree_block_len(xfs_btree_cur)
   - 计算btree结点的xfs_btree_block头的大小??
   - 如果xfs_btree_cur->bc_flags有XFS_BTREE_LONG_PTR, 而且是crc, XFS_BTREE_CRC_BLOCKS, 返回XFS_BTREE_LBLOCK_CRC_LEN
   - 如果没有crc, 使用XFS_BTREE_LBLOCK_LEN
   - 如果没有XFS_BTREE_LONG_PTR, 但有XFS_BTREE_CRC_BLOCKS, 使用XFS_BTREE_SBLOCK_CRC_LEN
   - 否则使用XFS_BTREE_SBLOCK_LEN

** xfs_btree_ptr_len(xfs_btree_cur)
   - 分支指针的大小, sizeof(__be64), 或者sizeof(__be32)

** xfs_btree_rec_offset(xfs_btree_cur, n)
   - 计算叶子结点第n个记录的位置?? 
   - xfs_btree_block_len(xfs_btree_cur) + (n-1) * xfs_btree_cur->bc_ops->rec_len

** xfs_btree_key_offset(xfs_btree_cur, n)
   - 计算内部结点第n个key的位置 
   > xfs_btree_block_len(xfs_btree_cur) + (n-1) * xfs_btree_cur->bc_ops->key_len

** xfs_btree_ptr_offset(xfs_btree_cur, n, level)
   - 内部结点value的位置, 包括3部分偏移
   - xfs_btree_block头的偏移
   > xfs_btree_block_len(xfs_btree_cur) 
   - key的偏移
   - xfs_btree_cur->bc_ops->get_maxrecs(xfs_btree_cur, level) * xfs_btree_cur->bc_ops->key_len 
   - 然后是value的偏移 
   - (n-1) * xfs_btree_ptr_len(xfs_btree_cur)

** xfs_btree_rec 
   #+BEGIN_SRC 
	xfs_bmbt_rec_t		bmbt;
	xfs_bmdr_rec_t		bmbr;	/* bmbt root block */
	xfs_alloc_rec_t		alloc;
	xfs_inobt_rec_t		inobt;   
   #+END_SRC

** xfs_btree_rec_addr(xfs_btree_cur, n, xfs_btree_block)
   - 访问xfs_btree_block中的第n个结点 
   > xfs_btree_rec_offset(xfs_btree_cur, n)
   - xfs_btree_block应该指向内存中一个xfs_buf的数据, 返回的xfs_btree_rec,数据类新是磁盘格式的

** xfs_btree_key
   #+BEGIN_SRC 
	xfs_bmbt_key_t		bmbt;
	xfs_bmdr_key_t		bmbr;	/* bmbt root block */
	xfs_alloc_key_t		alloc;
	xfs_inobt_key_t		inobt;   
   #+END_SRC

** xfs_btree_key_addr(xfs_btree_cur, n, xfs_btree_block)
   - 和上面一样

** xfs_btree_ptr_addr(xfs_btree_cur, n, xfs_btree_block)
   - 这里需要xfs_btree_block指向结点的level 
   > xfs_btree_get_level(xfs_btree_block)
   > xfs_btree_ptr_offset(xfs_btree_cur, n, level)

** xfs_btree_get_iroot(xfs_btree_cur)
   - 获取btree的根结点, 还是xfs_btree_block指针, 数据类型的磁盘使用的
   - 首先找到对应的xfs_ifork 
   > XFS_IFORK_PTR(xfs_btree_cur->bc_private->b->xfs_inode, xfs_btree_cur->bc_private->b->whichfork)
   - 然后返回xfs_ifork->if_broot

** xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   - 获取xfs_btree_cur中level对应的结点的xfs_buf和xfs_btree_block
   - 如果xfs_btree_cur->bc_flags有XFS_BTREE_ROOT_IN_INODE, 而且level == xfs_btree_cur->bc_nlevels-1, 表示跟结点在xfs_ifork中??
   - 对于block/inode等待,就使用ag的专门的block 
   > xfs_btree_get_iroot(xfs_btree_cur)
   - 否则直接使用xfs_btree_cur->bc_bufs[level]
   > XFS_BUF_TO_BLOCK(xfs_buf)

** xfs_btree_get_bufl(xfs_mount, xfs_trans, xfs_fsblock_t, lock)
   - 创建xfs_fsblock_t对应的xfs_buf
   - 先转化磁盘地址
   > XFS_FSB_TO_DADDR(xfs_mount, xfs_fsblock_t)
   - 这里有读操作?
   > xfs_trans_get_buf(xfs_trans, xfs_mount->xfs_buftarg, d, xfs_mount->m_bsize, lock)

** xfs_btree_get_bufs(xfs_mount, xfs_trans, xfs_agnumber_t agno, xfs_agblock_t agbno, lock)
   - 磁盘地址是(agno, agbno)
   > XFS_AGB_TO_DADDR(xfs_mount, agno, agbno)
   > xfs_trans_get_buf(xfs_trans, xfs_mount->xfs_buftarg, d, xfs_mount->m_bsize, lock)

** xfs_btree_islastblock(xfs_btree_cur, level)
   - 首先获取xfs_btree_cur对应level的结点 
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   - 检查它的有效性 
   > xfs_btree_check_block(xfs_btree_cur, xfs_btree_block, level, xfs_buf)
   - 检查他的rightsib, 是否为空, 表示他是level层的最后一个结点
   - 如果使用64为磁盘指针,比较NULLDFSBNO, 32位使用NULLAGBLOCK (-1)

** xfs_btree_firstrec(xfs_btree_cur, level)
   - 获取level对应的xfs_btree_block 
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   > xfs_btree_check_block(xfs_btree_cur, xfs_btree_block, level, xfs_buf)
   - 如果他没有子结点?? xfs_btree_block->bb_numrecs ==0, 返回0
   - 否则设置xfs_btree_cur->bc_ptrs[level] ==1
   - 这里xfs_btree_ptr->bc_bufs[level]已经取出来, 只是修改bc_ptrs[level], 它决定下一层分支

** xfs_btree_lastrec(xfs_btree_cur, level)
   - 和上面相反,这里设置xfs_btree_cur->bc_ptrs[level] = xfs_btree_block->bb_numrecs
   - 这个指针是从1开始的.. 

** xfs_btree_offset(fields, offset, nbits, first, last)
   - fields对应offset的内存, 检查(0,nbits)中置位的范围, 给(first,last)
   - 只需要检查开头和结尾 

** xfs_btree_read_bufl(xfs_mount, xfs_trans, xfs_fsblock_t fsbno, lock, xfs_buf, refval, xfs_buf_ops)
   - 读取btree结点,磁盘地址是xfs_fsblock_t, 先转化为绝对地址  
   > XFS_FSB_TO_DADDR(xfs_mount, xfs_fsblock_t)
   - 读取xfs_buf 
   > xfs_trans_read_buf(xfs_mount, xfs_trans, xfs_mount->xfs_buftarg, d, xfs_mount->m_bsize, lock, xfs_buf, xfs_buf_ops)
   - 这里结点大小是xfs_mount->m_bsize

** xfs_btree_read_bufl(xfs_mount, xfs_fsblock_t fsbno, xfs_extlen_tcount, xfs_buf_ops)
   - 预读磁盘数据,转化磁盘地址 
   > XFS_FSB_TO_DADDR(xfs_mount,xfs_fsblock_t)
   > xfs_buf_readahead(xfs_mount->xfs_buftarg, d, xfs_mount->m_bsize *count, xfs_buf_ops)

** xfs_btree_reada_bufs(xfs_mount, xfs_agnumber_t agno, xfs_agblock_t agbno, xfs_extlen_t count, xfs_buf_ops ops)
   - 读取磁盘数据,地址由(agno,agbno)决定 
   > XFS_AGB_TO_DADDR(xfs_mount,agno,agbno)
   > xfs_buf_readahead(xfs_mount->xfs_buftarg,d, xfs_mount->m_bsize * count, xfs_buf_ops)

** xfs_btree_readahead_lblock(xfs_btree_cur, lr,xfs_btree_block)
   - 读取xfs_btree_block的兄弟结点 
   - 从xfs_btree_block->bb_u->l->bb_leftsib/bb_rightsib获取指针
   - 如果lr有XFS_BTCUR_LEFTRA, 读取左边的结点
   > xfs_btree_reada_bufl(xfs_btree_cur->xfs_mount, left, 1, xfs_btree_cur->bc_ops->buf_ops)
   - lr的XFS_BTCUR_RIGHTRA对应右边结点 

** xfs_btree_readahead_sblock(xfs_btree_cur, lr, xfs_btree_block)
   - 上面的xfs_btree_block使用指针是fsb,这里是agbno
   - 使用xfs_btree_cur->bc_private->a->agno计算磁盘地址 
   > xfs_btree_reada_bufs(xfs_btree_cur->xfs_mount, xfs_btree_cur->bc_private->a->agno, left, 1, xfs_btree_cur->xfs_btree_ops->xfs_buf_ops)

** xfs_btree_readahead(xfs_btree_cur, level, lr)
   - 如果level指向根结点,而且根结点在xfs_ifork中, 直接返回
   - xfs_btree_cur->bc_flags有XFS_BTREE_ROOT_IN_INODE, level == xfs_btree_cur->bc_nlevels - 1
   - 如果xfs_btree_cur->bc_ra[level]中已经有lr的标志,直接返回, 表示readahead已经完成
   - 否则设置xfs_btree_cur->bc_ra[level] 
   - 获取对应的xfs_btree_block 
   > XFS_BUF_TO_BLOCK(xfs_btree_cur->bc_bufs[level]
   - 如果xfs_btree_cur->bc_flags有XFS_BTREE_LONG_PTR, 使用xfs_fsblock_t预读
   > xfs_btree_readahead_lblock(xfs_btree_cur, lr, xfs_block_btree)
   > xfs_btree_readahead_sblock(xfs_btree_cur, lr, xfs_block_btree)

** xfs_btree_setbuf(xfs_btree_cur, level, xfs_buf)
   - 把xfs_buf给xfs_btree_cur->bc_bufs[level], 释放原来的
   > xfs_trans_brelse(xfs_btree_cur->xfs_trans, xfs_btree_cur->bc_bufs[level])
   - 重新计算xfs_btree_cur->bc_ra[level]
   - 如果xfs_buf中的xfs_btree_block的兄弟结点指针是NULLDFSBNO, 设置相关的XFS_BTCUR_RIGHTRA, XFS_BTCUR_LEFTRA, 以后不需要readahead 

** xfs_btree_ptr_is_null(xfs_btree_cur cur, xfs_btree_ptr ptr)
   - xfs_btree_ptr是分支指针
   - 比较xfs_btree_ptr->l/s和NULLDFSBNO/NULLAGBLOCK

** xfs_btree_set_ptr_null(xfs_btree_cur cur, xfs_btree_ptr ptr)
   - 设置为空指针, xfs_btree_ptr使用大端的数据类型, 需要转化

** xfs_btree_get_sibling(xfs_btree_cur, xfs_btree_block, xfs_btree_ptr, lr)
   - 获取xfs_btree_block的兄弟结点, lr决定right/left
   - 如果xfs_btree_cur->bc_flags有XFS_BTREE_LONG_PTR, 使用fsb 
   - 如果lr有XFS_BB_RIGHTSIB,设置xfs_btree_ptr为xfs_btree_block->bb_u->l->bb_rightsib
   - 否则使用bb_leftsib

** xfs_btree_set_sibling(xfs_btree_cur, xfs_btree_block, xfs_btree_ptr, lr)
   - 设置兄弟结点指针

** xfs_btree_init_block_init(xfs_mount, xfs_btree_block, xfs_daddr_t, magic, level, numrec, owner, flags)
   - 初始化xfs_btree_block, 它的数据类型是大端的
   - 先设置magic, level, numrecs
   - 下面根据XFS_BTREE_LONG_PTR而定
   - 兄弟结点设为NULL, 
   - 如果flags有XFS_BTREE_CRC_BLOCK, 设置bno, uuid, owner

** xfs_btree_init_block(xfs_mount, xfs_buf, magic, level, numrecs, owner, flags)
   - 初始化xfs_btree_block, 首先获取对应的xfs_btree_block
   > xfs_btree_init_block_int(xfs_mount, XFS_BUF_TO_BLOCK(xfs_buf), xfs_buf->b_bn, magic, level, numrecs, owner, flags)

** xfs_btree_init_block_cur(xfs_btree_cur, xfs_buf, level, numrecs)
   - 初始化xfs_buf中的xfs_btree_block
   - 如果xfs_btree_cur->bc_flags有XFS_BTREE_LONG_PTRS, owner就是ino?? 这个btree就是xfs_ifork的?? 
   - 否则设为xfs_btree_cur->bc_private->a->agno? btree中使用的指针限于ag内部?
   > xfs_btree_init_block_init(xfs_btree_cur->xfs_mount, XFS_BUF_TO_BLOCK(xfs_buf), xfs_buf->b_bn, xfs_btree_magic(xfs_btree_cur), level, numrecs, owner, xfs_btree_cur->bc_flags)

** xfs_btree_is_lastrec(xfs_btree_cur, xfs_btree_block, level)
   - 检查xfs_btree_block是否为btree的最后一个叶子结点??
   - 如果level >0, 返回0. 最后一个结点应该是叶子结点
   - 如果xfs_btree_cur->bc_flags也没有XFS_BTREE_LASTREC_UPDATE?? 返回0?
   - 获取xfs_btree_block的右兄弟 
   > xfs_btree_et_sibling(xfs_btree_cur, xfs_btree_block, xfs_btree_ptr, XFS_BB_RIGHTSIB)
   - 检查指针是否为null 
   > xfs_btree_ptr_is_null(xfs_btree_cur, xfs_btree_ptr)

** xfs_btree_buf_to_ptr(xfs_btree_cur, xfs_buf, xfs_btree_ptr)
   - 把xfs_buf的地址给xfs_btree_ptr
   - 如果xfs_btree_cur->bc_flags有XFS_BTREE_LONG_PTR, 需要xfs_fsblock_t格式
   > XFS_DADDR_TO_FSB(xfs_btree_cur->xfs_mount, XFS_BUF_ADDR(xfs_buf))
   - 否则使用agbno 
   > xfs_daddr_to_agbno(xfs_mount, XFS_BUF_ADDR(xfs_buf))

** xfs_btree_ptr_to_daddr(xfs_btree_ptr, xfs_btree_ptr ptr)
   - 把xfs_btree_ptr的指针转化为xfs_daddr_t格式 
   - 如果xfs_btree_cur->bc_flags有XFS_BTREE_LONG_PTRS, 使用xfs_fsblock_t 
   > XFS_FSB_TO_DADDR(xfs_btree_block->xfs_mount, be64_to_cpu(xfs_btree_ptr->l))
   - 否则使用agno/agbno

** xfs_btree_set_refs(xfs_btree_cur, xfs_buf)
   - 根据xfs_btree_cur->bc_btnum, 设置xfs_buf->b_lru_ref中的标志
   > xfs_buf_set_ref(xfs_buf, lru_ref)
   - 对于不同的btree, 设置不同的标志, XFS_ALLOC_BTREE_REF/XFS_INO_BTREE_REF/XFS_BMAP_BTREE_REF

** xfs_btree_get_buf_block(xfs_btree_cur, xfs_btree_ptr, flags, xfs_btree_block block, xfs_buf)
   - 获取xfs_btree_ptr指向的xfs_buf, 以及对应的xfs_btree_block 
   > xfs_btree_ptr_to_daddr(xfs_btree_cur, xfs_btree_ptr)
   > xfs_trans_get_buf(xfs_btree_cur->xfs_trans, xfs_mount->xfs_buftarg, d, xfs_mount->m_bsize, flags)
   - 设置xfs_buf->xfs_buf_ops = xfs_btree_cur->xfs_btree_ops->xfs_buf_ops
   > XFS_BUF_TO_BLOCK(xfs_buf)

** xfs_btree_read_buf_block(xfs_btree_cur, xfs_btree_ptr, level, flags, xfs_btree_block, xfs_buf)
   - 读取xfs_btree_ptr对应的xfs_buf, xfs_btree_block 
   > xfs_btree_ptr_to_daddr(xfs_btree_cur, xfs_btree_ptr)
   > xfs_trans_read_buf(xfs_mount, xfs_btree_cur->xfs_trans, xfs_mount->xfs_buftarg, d, xfs_mount->m_bsize, flags, xfs_buf, xfs_btree_cur->xfs_btree_ops->xfs_buf_ops)
   - 为何这里设置refs?
   > xfs_btree_set_refs(xfs_btree_cur, xfs_buf)
   > XFS_BUF_TO_BLOCK(xfs_buf)

** xfs_btree_copy_keys(xfs_btree_cur, xfs_btree_key dst, xfs_btree_key src, numkeys)
   - 复制xfs_btree_key数组, 数组单元长度是xfs_btree_cur->xfs_btree_ops->key_len

** xfs_btree_copy_recs(xfs_btree_cur, xfs_btree_rec dst, xfs_btree_rec src, numrecs)
   - 复制xfs_btree_rec数组, 直接使用memcpy
   - 数组单位长度是xfs_btree_cur->xfs_btree_ops->rec_len

** xfs_btree_copy_ptrs(xfs_btree_cur, xfs_btree_ptr dst, src, numptrs)
   - 复制xfs_btree_ptr数组, 单位是指针长度
   > xfs_btree_ptr_len(xfs_btree_cur)

** xfs_btree_shift_keys(xfs_btree_cur, xfs_btree_key, dir, numkeys)
   - dir表示向前还是向后移动

** xfs_btree_shift_recs(xfs_btree_cur, xfs_btree_rec, dir, numrecs)

** xfs_btree_shift_ptrs(xfs_btree_cur, xfs_btree_ptr, dir, numptrs)

** xfs_btree_log_keys(xfs_btree_cur, xfs_buf, first, last)
   - log xfs_buf中的修改?
   - 如果xfs_buf不是NULL, 记录(first, last)范围内的xfs_btree_key 
   > xfs_trans_buf_set_type(xfs_btree_cur->xfs_trans, xfs_buf, XFS_BLFT_BTREE_BUF)
   > xfs_trans_log_buf(xfs_btree_cur->xfs_trans, xfs_buf, xfs_btree_key_offset(xfs_btree_cur, first), xfs_btree_key_offset(xfs_btree_cur, last+1) -1 )
   - 如果xfs_buf, 要log根结点,而且在xfs_ifork中
   - log把整个根结点
   > xfs_trans_log_inode(xfs_btree_cur->xfs_trans, xfs_btree_cur->bc_private->b->xfs_inode, xfs_ilog_fbroot(whichfork))

** xfs_btree_log_recs(xfs_btree_cur, xfs_buf, first, last)
   - xfs_buf是叶子结点,不可能是根结点 
   - 只是log (first, last)范围内的xfs_btree_rec数组 

** xfs_btree_log_ptrs(xfs_btree_cur, xfs_buf, first, last)
   - 和上面处理xfs_btree_key一样

** xfs_btree_log_block(xfs_btree_cur, xfs_buf, fields)
   - log xfs_btree_block, 根据field计算范围
   - 这里有XFS_BB_MAGIC/LEVEL/NUMRECS/LEFTSIB/RIGHTSIB/BLKNO
   - 如果xfs_btree_cur->bc_flags有XFS_BTREE_CRC_BLOCKS, 而且fields是XFS_BB_ALL_BITS, 需要包括XFS_BB_ALL_BITS_CRC, 只有在全部log时,crc的log才有意义
   - 计算xfs_buf中的数据范围
   > xfs_btree_offset(fields, loffset/soffset, nbits, first, last)
   > xfs_trans_buf_set_type(xfs_btree_cur->xfs_trans, xfs_buf, XFS_BLFL_BTREE_BUF)
   > xfs_trans_log_buf(xfs_trans, xfs_buf, first, last)
   - 如果xfs_buf == NULL, 要log xfs_ifork中的数据 
   > xfs_trans_log_inode(xfs_btree_cur->xfs_trans, xfs_btree_cur->bc_private->b->xfs_inode, xfs_ilog_fbroot(whichfork))

** xfs_btree_increment(xfs_btree_cur, level, state)
   - 修改level层的指针, 指向下一个结点 
   - 预读level结点的右边兄弟结点, 可能会用到, 但不一定
   > xfs_btree_readahead(xfs_btree_cur, level, XFS_BTCUR_RIGHTRA)
   - 获取level对应的xfs_btree_block 
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   > xfs_btree_check_block(xfs_btree_cur, xfs_btree_block, level, xfs_buf)
   - 如果当前分支指针不是指向最后一个, 直接修改xfs_btree_cur->bc_ptrs[level], 然后可以结束
   - xfs_btree_get_numrecs(xfs_btree_block)
   - 如果当前是最后一个分支,需要使用对应的兄弟结点
   - 获取兄弟结点的磁盘位置
   > xfs_btree_get_sibling(xfs_btree_cur, xfs_btree_block, ptr, XFS_BB_RIGHTSIB)
   - 如果指针为空,直接退出
   > xfs_btree_ptr_is_null(xfs_btree_cur, xfs_btree_ptr)
   - 这里不用回朔就能判断level层是否有下一个结点
   - 但要修改xfs_btree_cur->bc_ptrs/bc_bufs, 还是得回朔
   - 向根结点方向回朔,找到不是最有一个分支的结点 
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   - 移动指针xfs_btree_cur->bc_ptrs[level], 指向下一个分支
   - 如果超过xfs_btree_block的分支数, 继续回朔
   > xfs_btree_get_numrecs(xfs_btree_block)
   - 如果需要继续,预读右边的兄弟结点 
   > xfs_btree_readahead(xfs_btree_cur, level, XFS_BTCUR_RIGHTRA)
   - 然后向level遍历,获取对应的xfs_buf指针,同时修改分支指针为1
   - 获取子结点磁盘位置
   > xfs_btree_ptr_add(xfs_btree_cur, xfs_btree_cur->bc_ptrs[level], xfs_btree_block)
   - 读取对应的xfs_buf
   > xfs_btree_read_buf_block(xfs_btree_cur, xfs_btree_ptr, level, 0, xfs_btree_block, xfs_buf)
   - 设置xfs_btree_cur->bc_bufs[level]
   > xfs_btree_setbuf(xfs_btree_cur, level, xfs_buf)
   - 设置xfs_btree_cur->bc_ptrs[level] ==1

** xfs_btree_decrement(xfs_btree_cur, level, stata)
   - 首先读取对应的左兄弟结点 
   > xfs_btree_readahead(xfs_btree_cur, leve, XFS_BTCUR_LEFTRA)
   - 首先修改分支指针 xfs_btree_cur->bc_ptrs[level] --
   - 如果修改后>0, 说明不用切换结点,直接退出
   - 否则需要切换多个结点, 检查是否有左边的兄弟结点 
   > xfs_btree_get_sibling(xfs_btree_cur, xfs_btree_block, xfs_btree_ptr, XFS_BB_LEFTSIB)
   > xfs_btree_ptr_is_null(xfs_btree_cur, xfs_btree_ptr)
   - 否则向上回朔, 找到有左边分支的父结点 
   - 只要减小 --xfs_btree_cur->bc_ptrs[level]
   - 而且减小后>0, 也就是有效的, 可以回朔
   > xfs_btree_readahead(xfs_btree_cur, level, XFS_BTCUR_LEFTRA)
   - 然后向level遍历, 更新xfs_btree_cur->bc_ptrs/bc_bufs
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   - 获取对应的子结点地址, 读取对应的xfs_buf
   > xfs_btree_ptr_addr(xfs_btree_cur, xfs_btree_cur->bc_ptrs[level], xfs_btree_block)
   > xfs_btree_read_buf_block(xfs_btree_cur, xfs_btree_ptr, level, 0, xfs_btree_block, xfs_buf)
   - 设置xfs_btree_cur->bc_bufs
   > xfs_btree_setbuf(xfs_btree_cur, level, xfs_buf)
   - 设置子分支的索引,指向最后一个结点 
   > xfs_btree_get_numrecs(xfs_btree_block)

** xfs_btree_lookup_get_block(xfs_btree_cur, level, xfs_btree_ptr, xfs_btree_block blkp)
   - 获取xfs_btree_cur中level对应的结点?? 
   - 如果level是最高层,而且btree在xfs_ifork中 
   - xfs_btree_cur->bc_flags有XFS_BTREE_ROOT_IN_INODE
   - level == xfs_btree_cur->bc_nlevels -1 
   - 直接去xfs_ifork中查找 
   > xfs_btree_get_iroot(xfs_btree_cur)
   - 否则获取level对应的xfs_buf, 检查它的地址和参数xfs_btree_ptr是否一致
   > XFS_BUF_ADDR(xfs_btree_cur->bc_bufs[level])
   > xfs_btree_ptr_to_daddr(xfs_btree_cur, xfs_btree_ptr)
   - 如果一致,可以使用对应的xfs_buf的xfs_btree_block 
   > XFS_BUF_TO_BLOCK(xfs_buf)
   - 如果不一致,需要读取参数xfs_btree_ptr指向的xfs_buf 
   > xfs_btree_read_buf_block(xfs_btree_cur, xfs_btree_ptr, level, 0, xfs_block_btree, xfs_buf)
   - 然后设置xfs_btree_cur->bc_bufs 
   > xfs_btree_setbuf(xfs_btree_cur, level, xfs_buf)

** xfs_lookup_get_search_key(xfs_btree_cur, level, keyno, xfs_btree_block, xfs_btree_key)
   - 计算当前查找的xfs_btree_key? 也就是keyno对应的分支的key?
   - 对于叶子结点,根据第keyno对应的xfs_btree_rec构造一个?? 
   > xfs_btree_cur->xfs_btree_ops->init_key_from_rec(xfs_btree_key, xfs_btree_rec_addr(xfs_btree_cur, keyno, xfs_btree_block))
   - 否则返回xfs_btree_block中keyno对应的xfs_btree_key 
   > xfs_btree_key_addr(xfs_btree_cur, keyno, xfs_btree_block)

** xfs_btnum_t
   #+BEGIN_SRC 
	XFS_LOOKUP_EQi, XFS_LOOKUP_LEi, XFS_LOOKUP_GEi   
   #+END_SRC

** xfs_btree_lookup(xfs_btree_cur, xfs_lookup_t, state)
   - 查找的是什么, xfs_btree_cur->bc_rec?
   - 初始化xfs_btree_ptr? 
   > xfs_btree_cur->xfs_btree_ops->init_ptr_from_cur(xfs_btree_cur, xfs_btree_ptr)
   - 开始向叶子结点遍历
   - 对于一个结点,使用2分查找 
   - 先获取结点的分支数 
   > xfs_btree_get_numrecs(xfs_btree_block) 
   - 如果结点分支数为0, 它必须是叶子结点,没有任何记录
   - 查找对应的xfs_btree_key 
   > xfs_lookup_get_search_key(xfs_btree_key, level, keyno, xfs_btree_block, key)
   - 然后比较什么?? 
   > xfs_btree_cur->xfs_btree_ops->key_diff(xfs_btree_cur, xfs_btree_key)
   - 查找介绍后根据level设置子结点指针 
   > xfs_btree_ptr_addr(xfs_btree_cur, keyno, xfs_btree_block)
   > xfs_btree_check_ptr(xfs_btree_cur, xfs_btree_ptr, 0, level)
   - 设置xfs_btree_cur->bc_ptrs[level] = keyno
   - 如果参数dir不是XFS_LOOKUP_LE?? 而且diff < 0,需要向前移动指针 
   - 直接增加keyno, 也就是分支指针, 如果查找XFS_LOOKUP_EQ, 反正找不到,所以keyno没有意义也可以接受
   > xfs_btree_get_sibling(xfs_btree_cur, xfs_btree_block, xfs_btree_ptr, XFS_BB_RIGHTSIB)
   - 如果dir是XFS_LOOKUP_GE, 既然找不到,也需要指向有意义的结点 
   - 如果keyno超过分指数,需要指向下一个结点
   > xfs_btree_increment(xfs_btree_cur, 0, i)
   - 最后根据keyno设置查找结果

** xfs_btree_updkey(xfs_btree_cur, xfs_btree_key, leven)
   - 更新xfs_btree_key路径上的结点的xfs_btree_key? 
   - 设置为参数xfs_btree_key
   - 从level=1向上, 直到xfs_btree_cur->bc_nlevels 
   - 但是只有子分支是第一个子结点时,才继续回朔
   - 找到level对应的xfs_buf, 也就是父结点
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   - 结点中针对下层的分支指针是xfs_btree_cur->bc_ptrs[level] 
   - 就直接修改这个子分支的xfs_btree_key 
   > xfs_btree_key_addr(xfs_btree_cur, xfs_btree_ptr, xfs_btree_block)
   - 从参数复制数据
   > xfs_btree_copy_keys(xfs_btree_cur, xfs_btree_key, xfs_btree_key, 1)
   > xfs_btree_log_keys(xfs_btree_cur, xfs_buf, xfs_btree_ptr, xfs_btree_ptr)
   - 这里更新结点的xfs_btree_key, 只能在父结点里更新

** xfs_btree_update(xfs_btree_cur, xfs_btree_cur)
   - 更新xfs_btree_cur查找的结果
   - 获取叶子结点  
   > xfs_btree_get_block(xfs_btree_cur, 0, xfs_buf)
   - 根据xfs_btree_cur->bc_ptrs[0], 找到对应的xfs_btree_rec 
   > xfs_btree_rec_addr(xfs_btree_cur, ptr, xfs_btree_block)
   - 复制参数 
   > xfs_btree_copy_recs(xfs_btree_cur, xfs_btree_rec, xfs_btree_cur, 1)
   > xfs_btree_log_recs(xfs_btree_cur, xfs_buf, ptr, ptr)
   - 如果这个结点是最后一个, 需要更新什么?? 
   > xfs_btree_cur->xfs_btree_ops->update_lastrec(xfs_btree_cur, xfs_btree_block, xfs_btree_rec, ptr, LASTREC_UPDATE)
   - 如果上面分支指针是1, 这个叶子结点的key需要更新 
   - 首先构造一个xfs_btree_key
   > xfs_btree_cur->xfs_btree_ops->init_key_from_rec(xfs_btree_key, xfs_btree_rec)
   - 更新到父结点中
   > xfs_btree_updkey(xfs_btree_cur, xfs_btree_key, 1)

** xfs_btree_lshift(xfs_btree_cur, level, state)
   - 如果更新根结点,而且根结点在xfs_ifork中,不允许修改??
   - 找到level层的结点 xfs_buf/xfs_btree_block
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   - 获取左边的叶子结点 
   > xfs_btree_get_sibling(xfs_btree, xfs_btree_block, xfs_btree_ptr, XFS_BB_LEFTSIB)
   - 如果不存在,直接返回 
   > xfs_btree_ptr_is_null(xfs_btree_cur, xfs_btree_ptr)
   - 移动的子分支是第一个分支, 如果当前路径在使用这个分支,不再移动
   - 因为太复杂???
   - xfs_btree_cur->bc_ptrs[level] <= 1
   - 获取左边的叶子结点xfs_buf, xfs_btree_block 
   > xfs_btree_read_buf_block(xfs_btree_cur, xfs_btree_ptr, level, 0, xfs_btree_block, xfs_buf)
   - 检查左边的结点是否满了?? 
   > xfs_btree_cur->xfs_btree_ops->get_maxrecs(xfs_btree_cur, level)
   > xfs_btree_get_numrecs(xfs_btree_block)
   - 要从当前的结点,向左边的兄弟结点中移动一个子分支
   - 如果不是叶子结点, level > 0
   - 先找到xfs_btree_key/xfs_btree_ptr的位置
   > xfs_btree_key_addr(xfs_btree_cur, lrecs, left)
   > xfs_btree_key_addr(xfs_btree_cur, 1, right)
   > xfs_btree_ptr_addr(xfs_btree_cur, lrecs, left)
   > xfs_btree_ptr_addr(xfs_btree_cur, 1, left)
   - 复制xfs_btree_key/xfs_btree_ptr 
   > xfs_btree_copy_keys(xfs_btree_cur, xfs_btree_key, xfs_btree_key, 1)
   > xfs_btree_copy_ptrs(xfs_btree_cur, xfs_btree_ptrs, xfs_btree_ptrs, 1) 
   - 然后log左边的结点??
   > xfs_btree_log_keys(xfs_btree_cur, left, lrecs, lrecs)
   > xfs_btree_log_ptrs(xfs_btree_cur, left, lrecs, lrecs)
   - 如果是叶子结点, level ==0
   - 找到xfs_btree_rec位置 
   > xfs_btree_rec_addr(xfs_btree_cur, lrecs, left)
   > xfs_btree_rec_addr(xfs_btree_cur, 1, right)
   > xfs_btree_copy_recs(xfs_btree_cur, l, r, 1)
   - 然后log左边的结点
   > xfs_btree_log_recs(xfs_btree_cur, xfs_buf, lrecs, lrecs)
   - 最后设置2个xfs_btree_block->numrecs
   > xfs_btree_set_numrecs(left, lrecs)
   > xfs_btree_log_block(xfs_btree_cur, xfs_buf, XFS_BB_NUMRECS)
   - 然后是右边结点 
   > xfs_btree_set_numrecs(right, rrecs)
   > xfs_btree_log_block(xfs_btree_cur, xfs_buf, XFS_BB_NUMRECS)
   - 然后删除右边结点的第一个分支
   - 如果不是叶子结点, level >0 
   - 从第2个key/ptr开始移动,向左移动
   > xfs_btree_shift_keys(xfs_btree_cur, xfs_btree_key_addr(xfs_btree_cur, 2, right), -1, rrecs)
   > xfs_btree_shift_ptrs(xfs_btree_cur, xfs_btree_ptr_addr(xfs_btree_cur, 2, right), -1, rrecs)
   - 然后log右边的结点, 把整个key/ptr都log下来
   - 为何不和上面一块, 把整个结点都log下来??
   > xfs_btree_log_keys(xfs_btree_cur, xfs_buf, 1, rrecs)
   > xfs_btree_log_ptrs(xfs_btree_cur, xfs_buf, 1, rrecs)
   - 如果是叶子结点, level=0
   > xfs_btree_shift_recs(xfs_btree_cur, xfs_btree_rec_addr(xfs_btree_cur, 2, right), -1, rrecs)
   > xfs_btree_log_recs(xfs_btree_cur, xfs_buf, 1, rrecs)
   - 然后更新right结点的父结点的xfs_btree_key 
   > xfs_btree_cur->xfs_btree_ops->init_key_from_rec(xfs_btree_key, xfs_btree_rec_addr(xfs_btree_cur, 1, right))
   > xfs_btree_updkey(xfs_btree_cur, xfs_btree_key, level+1)
   - 同样修改路径的指针, 只需要修改当前移动的level的子分支 
   - xfs_btree_cur->bc_ptrs[level] --

** xfs_btree_rshift(xfs_btree_cur, level, state)
   - 首先判断根结点, 如果在xfs_ifork中不做修改?? 
   - 但是对于其他的btree就能修改?? 也只有一个根结点??
   - 获取2个结点, xfs_buf/xfs_btree_block 
   - left就是xfs_btree_cur中level指向的
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   - 然后获取右边兄弟指针
   > xfs_btree_get_sibling(xfs_btree_cur, xfs_btree_block, xfs_btree_ptr, XFS_BB_RIGHTSIB)
   - 如果不存在,直接返回 
   > xfs_btree_ptr_is_null(xfs_btree_cur, xfs_btree_ptr)
   - 检查需要移动的子结点,也就是最后一个子分支,是否在路径中正常使用  xfs_btree_block->bc_ptrs[level]
   > xfs_btree_get_numrecs(xfs_btree_block)
   - 如果是，不再移动,太复杂!!
   - 否则获取对应的xfs_buf/xfs_btree_block 
   - 下面的参数level没有使用!!
   > xfs_btree_read_buf_block(xfs_btree_cur, xfs_btree_ptr, level, 0, xfs_buf, xfs_btree_block)
   - 检查right是否满了 
   > xfs_btree_cur->xfs_btree_ops->get_maxrecs(xfs_btree_cur, level)
   - 如果不是叶子结点, level >0
   - 移动对应的xfs_btree_key/xfs_btree_ptr
   - 找到对应的位置 
   > xfs_btree_key_addr(..)
   > xfs_btree_ptr_addr(..)
   - 需要先从right结点中空出来位置 
   > xfs_btree_shift_keys(xfs_btree_cur, xfs_buf, 1, rrecs)
   > xfs_btree_shift_ptrs(xfs_btree_cur, xfs_buf, 1, rrecs)
   > xfs_btree_copy_keys(..)
   > xfs_btree_copy_ptrs(..)
   - 然后log右边的结点
   > xfs_btree_log_keys(..)
   > xfs_btree_log_ptrs(..)
   - 如果是叶子结点, level==0 
   - 找到对应的位置 
   > xfs_btree_rec_addr(..)
   - right结点准备 
   > xfs_btree_shift_recs(..)
   > xfs_btree_copy_recs(..)
   > xfs_btree_log_recs(..)
   - 最有左边结点,只需要修改xfs_btree_block->numrecs 
   > xfs_btree_set_numrecs(left, --lrecs)
   > xfs_btree_log_block(xfs_btree_cur, xfs_buf, XFS_BB_NUMRECS)
   - 使用临时的xfs_btree_cur? 修改右边结点的父结点的xfs_btree_key?
   > xfs_btree_dup_cursor(xfs_btree_cur, xfs_btree_cur)
   - 原来的xfs_btree_cur指针不需要任何移动
   - 如果这里移动了,需要完全复原,还得需要一个临时变量保存
   - 所以不如直接使用一个临时的xfs_btree_cur
   - 首先移动指针?? 
   > xfs_btee_increment(xfs_btree_cur, level, i)
   > xfs_btree_updkey(xfs_btree_cur, xfs_btree_key, level+1)
   
** xfs_btree_split(xfs_btree_cur, level, xfs_btree_ptr ptr, xfs_btree_key key, xfs_btree_cur, state)
   - 把xfs_btree_cur中level对应的结点分裂开??  
   - 获取xfs_buf/xfs_btree_block 
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   > xfs_btree_check_block(xfs_btree_cur, xfs_btree_block, level, xfs_buf)
   - 获取结点磁盘位置,为何还是用xfs_btree_ptr
   > xfs_btree_buf_to_ptr(xfs_btree_cur, xfs_buf, xfs_btre_ptr)
   - 分配新的结点,使用上面的地址做提示信息?? 
   > xfs_btree_cur->xfs_btree_ops->alloc_block(xfs_btree_cur, xfs_btree_ptr, xfs_btree_ptr rptr, 1, stat)
   - 获取对应的xfs_btree_block 
   > xfs_btree_get_buf_block(xfs_btree_cur, xfs_btree_ptr, 0, xfs_btree_block, xfs_buf)
   - 初始化新的xfs_btree_block, 放到原来的xfs_btree_block的后面 
   > xfs_btree_init_block_cur(xfs_btree_cur, xfs_buf, xfs_btree_get_level(xfs_btree_block), 0)
   - 移动xfs_btree_key/xfs_btree_ptr, 或者xfs_btree_rec
   > xfs_btree_get_numrecs(xfs_btree_block)
   - 如果level >0 
   - 复制一半的xfs_btree_key/xfs_btree_ptr 
   > xfs_btree_key_addr(xfs_btree_cur, src_idx, xfs_btree_block)
   > xfs_btree_ptr_addr(..)
   > xfs_btree_copy_keys(..)
   > xfs_btree_copy_ptrs(..)
   - log右边的结点 
   > xfs_btree_log_keys(..)
   > xfs_btree_log_ptrs(..)
   - 这里还有记录第一个xfs_btree_key, 作为新结点的xfs_btree_key
   - 如果level ==0, 复制xfs_btree_rec数组 
   > xfs_btree_rec_addr(xfs_btree_cur, src_idx, xfs_btree_block)
   > xfs_btree_rec_addr(xfs_btree_cur, 1, xfs_btree_block)
   > xfs_btree_copy_recs(xfs_btree_cur, ..)
   > xfs_btree_log_recs(xfs_btree_cur, ..)
   - 使用回调函数构造新结点的xfs_btree_key 
   > xfs_btree_cur->xfs_btree_ops->init_key_from_rec(xfs_btree_key, xfs_btree_cur_addr(xfs_btree_rec, 1, xfs_btree_block))
   - 设置兄弟结点
   > xfs_btree_get_sibling(xfs_btee_cur, xfs_btree_block, xfs_btree_ptr, XFS_BB_RIGHTSIB)
   - 设置原来结点的右兄弟结点为新的
   > xfs_btree_set_sibling(xfs_btree_cur, ...)
   - 设置新的结点的兄弟结点
   - 设置2个结点的numrecs, 并且log 
   > xfs_btree_set_numrecs(xfs_btree_block, lrecs)
   - 对于新的结点,整个xfs_btree_block都log
   > xfs_btree_log_block(xfs_btree_cur, xfs_buf, XFS_BB_ALL_BITS)
   - 对于原来的结点,只有右兄弟结点和numrecs 
   > xfs_btree_log_block(xfs_btree_cur, xfs_buf, XFS_BB_NUMRECS | XFS_BB_RIGHTSIB)
   - 还有结点原来的右兄弟结点,需要设置它的做兄弟结点,指向新的结点 
   > xfs_btree_read_buf_block(xfs_btree_cur, xfs_btree_ptr, level, 0, xfs_btree_block, xfs_buf)
   > xfs_btree_set_sibling(xfs_btree_cur, xfs_btree_block, xfs_btree_ptr, XFS_BB_LEFTSIB)
   > xfs_btree_log_block(xfs_btree_cur, xfs_btree_ptr, XFS_BB_LEFTSIB)
   - 如果xfs_btree_cur中的路径使用的分支被复制到新的xfs_btree_block,修改对应的xfs_btree_cur->bc_bufs/bc_ptrs 
   > xfs_btree_setbuf(xfs_btree_cur, level, xfs_buf)
   - 如果level不是指向根, 就创建一个新的xfs_btree_cur?
   - 这里通过参数返回xfs_btree_key / xfs_btree_cur

** xfs_btree_new_iroot(xfs_btree_cur, logflags, stat)
   - btree的根结点必须在xfs_ifork中? 
   - xfs_btree_cur->bc_flags有XFS_BTREE_ROOT_IN_INODE
   - 添加一个新结点代替原有的根结点, 分支全部复制到新的结点 
   - 新结点作为原来根结点的分支, 相当于btree高度增加一层
   - 获取现在xfs_btree_cur指向的根结点 
   > xfs_btree_get_iroot(xfs_btree_cur)
   - 获取第一个分支指针?? 
   > xfs_btree_ptr_addr(xfs_btree_cur, 1, xfs_btree_block)
   - 创建新的结点 
   > xfs_btree_cur->xfs_btree_ops->alloc_block(xfs_btree_cur, xfs_btree_ptr, new_ptr, 1, stat)
   - 这里是get, 不是read??
   > xfs_btree_get_buf_block(xfs_btree_cur, new_ptr, 0, xfs_btree_block, xfs_buf)
   - 把原来的根结点复制到新的根结点上, memcpy
   - 但要重新设置xfs_btree_block->bb_u->l->bb_bklno = xfs_buf->b_bn
   - 设置xfs_btree_block->bb_level = 1, numrecs 
   - 增加xfs_btree_cur->bc_nlevels ?? 
   - 复制xfs_btree_key/xfs_btree_ptr 
   - 把原来根结点的数据给新结点
   - 然后把新结点的xfs_btree_ptr给原来根结点, 不是修改xfs_btree_key,和原来一样
   - 重新设置xfs_ifork中的根结点的长度
   > xfs_iroot_realloc(xfs_btree_cur->bc_private->b->xfs_inode, 1-xfs_btree_get_numrecs(xfs_btree_cur), xfs_btree_cur->bc_private->b->whichfork)
   - 新创建的结点怎么添加到新的根结点中??
   - 最后log新的结点
   - XFS_BB_ALL_BITS, xfs_btree_key, xfs_btree_ptr数组
     
** xfs_btree_new_root(xfs_btree_cur, stat)
   - 直接初始化xfs_btree_ptr? 还需要初始化? rptr
   > xfs_btree_cur->xfs_btree_ops->init_ptr_from_cur(xfs_btree_cur, xfs_btree_ptr)
   - 分配block, 下面有2个指针? 
   - 第一个是上面的,应该是分配时提示位置??
   > xfs_btree_cur->xfs_btree_ops->alloc_block(xfs_btree_cur, xfs_btree_ptr rptr, xfs_btree_ptr lptr, 1, stat)
   - 获取分配的xfs_buf/xfs_btree_block 
   > xfs_btree_get_buf_block(xfs_btree_cur, xfs_btree_ptr, 0, xfs_btree_block, xfs_buf)
   - 把这个新的xfs_btree_block设为根结点?? 
   > xfs_btree_cur->xfs_btree_ops->set_root(xfs_btree_cur, xfs_btree_ptr, 1)
   - 读取xfs_btree_cur中bc_nlevels-1对应的xfs_btree_block?
   - 这一层刚执行过分裂?? 或者根结点刚才分裂过??
   > xfs_btree_get_block(xfs_btree_cur, xfs_btree_cur->bc_nlevels -1 , xfs_buf)
   - 同时获取它的兄弟结点, 可能是左兄弟,可能是右兄弟
   > xfs_btree_get_sibling(xfs_btree_cur, xfs_btree_block, xfs_btree_ptr, XFS_BB_RIGHTSIB)
   - 如果右兄弟存在, 也就是上面的xfs_btree_ptr, rptr
   > xfs_btree_ptr_is_null(xfs_btree_cur, xfs_btree_ptr)
   - 读取对应的xfsfub_/xfs_btree_block 
   > xfs_btree_read_buf_block(xfs_btree_cur, rptr, xfs_btree_cur->bc_nlevels-1, 0, xfs_btree_block, xfs_buf)
   - 还得计算上面的xfs_buf对应的xfs_btree_ptr, lptr 
   > xfs_btree_buf_to_ptr(xfs_btree_cur, xfs_btree_block, lptr)
   - 如果右兄弟不存在,上面获取的是右兄弟, 需要查找左兄弟 
   - 根据xfs_btree_block计算xfs_btree_ptr
   > xfs_btree_buf_to_ptr(xfs_btree_cur, xfs_buf, xfs_btree_ptr)
   - 获取对应的xfs_btree_ptr/xfs_btree_block/xfs_buf
   > xfs_btree_get_sibling(xfs_btree_cur, xfs_btree_block, xfs_buf, XFS_BB_LEFTSIB)
   > xfs_btree_read_buf_block(xfs_btree_cur, xfs_btree_ptr lptr, xfs_btree_cur->bc_nlevels - 1, 0, xfs_btree_block, xfs_buf)
   - 填充新的根结点? 
   - 初始化xfs_btree_block
   > xfs_btree_init_block_cur(xfs_btree_cur, xfs_buf, xfs_btree_cur->bc_nlevels, 2)
   - log这些?? 
   > xfs_btree_log_block(xfs_btree_cur, xfs_buf, XFS_BB_ALL_BITS)
   - 如果子结点(left/right)的level >0, 他们是内部结点,可以直接使用第一个xfs_btree_key  
   - left复制到根结点的第一个xfs_btree_key, right复制到第二个
   > xfs_btree_copy_keys(xfs_btree_cur, xfs_btree_key_addr(xfs_btree_cur, 1, new), xfs_btree_key_addr(xfs_btree_cur, 1, right))
   - 否则需要使用回调函数,计算叶子结点的xfs_btree_key
   > xfs_btree_cur->xfs_btree_ops->init_key_from_rec(xfs_btree_key_addr(xfs_btree_cur, 2, 1, xfs_buf), xfs_btree_cur_addr(xfs_btree_cur, 1, xfs_buf))
   - 然后log2个xfs_btree_key 
   > xfs_btree_log_keys(xfs_btree_cur, xfs_buf, 1, 2)
   - 然后填充xfs_btree_ptr, lptr, rptr 
   > xfs_btree_copy_ptrs(xfs_btree_cur, xfs_btree_ptr_addr(xfs_btree_cur, 1, xfs_buf), lptr, 1)
   > xfs_btree_log_ptrs(xfs_btree_cur, xfs_buf, 1, 2)
   - 把新的结点给xfs_buf->bc_bufs 
   > xfs_btree_setbuf(xfs_btree_cur, xfs_btree_cur->bc_nlevels, xfs_buf)
   - 对于xfs_btree_cur->bc_ptrs, 根据上面兄弟结点的选择
   - 如果开始从xfs_btree_cur中取出来的结点是右兄弟,设置为2,否则设置1
  
** xfs_btree_make_block_unfull(xfs_btree_cur, level, numrecs, oindex, index, xfs_btree_ptr, xfs_btree_cur, xfs_btree_rec, stat)
   - 分裂结点?? 
   - 如果level指向根结点,而且根结点在xfs_ifork中, 直接在xfs_dinode修改
   > xfs_btree_cur->bc_flags有XFS_BTREE_ROOT_IN_INODE, level == xfs_btree_cur->bc_nlevels -1 
   - 检查根结点是否能扩大, 计算最大值
   > xfs_btree_cur->xfs_btree_ops->get_dmaxrecs(xfs_btree_cur, level)
   - 直接修改xfs_dinode中的大小 
   > xfs_iroot_realloc(xfs_inode, 1, xfs_btree_cur->bc_private->b->whichfork)
   - 否则创建新的结点 
   > xfs_btree_new_iroot(xfs_btree_cur, logflags, stat)
   - 然后log对xfs_dinode的修改
   > xfs_trans_log_inode(xfs_trans, xfs_inode, logflags)
   - 如果不是xfs_ifork中的根结点
   - 首先向兄弟结点中移动??
   > xfs_btree_rshift(xfs_btree_cur, level, stat)
   > xfs_btree_lshift(xfs_btree_cur, level, stat)
   - 上面不一定能移动,会受到xfs_btree_cur的影响
   - 如果可以移动,直接返回
   - 设置oindex = index = xfs_btree->bc_ptrs[level]?
   - 否则需要分裂结点 
   > xfs_btree_split(xfs_btree_cur, level, xfs_btree_ptr, xfs_btree_key, xfs_btree_cur, stat)
   - 这个返回3个参数, 新的xfs_btree_ptr/xfs_btree_key/xfs_btree_cur?? 已经合并到原来的btree中?? 
   - 这里需要备份index = xfs_btree_cur->bc_ptrs[level]
   - 初始化新的xfs_btree_ptr?? 
   > xfs_btree_cur->xfs_btree_ops->init_rec_from_key(xfs_btree_key, xfs_btree_ptr)

** xfs_btree_insrec(xfs_btree_cur, level, xfs_btree_ptr, xfs_btree_rec, xfs_btree_cur, stat)
   - 向level中对应的结点插入新的xfs_btree_rec
   - 如果分裂,需要返回新的值,给btree的上层结点使用??
   - 如果是根结点,而且根在专有的block中
   - 怎么可能是根结点?? 根结点怎么成了叶子结点??
   - xfs_btree_cur->bc_flags没有XFS_BTREE_ROOT_IN_INODE, 而且level >= xfs_btree_cur->bc_nlevels 
   - 直接创建新的root, 它的原来的root已经分裂?? 
   > xfs_btree_new_root(xfs_btree_cur, stat)
   - 然后设置返回参数为NULL, 停止回朔操作??
   > xfs_btree_set_ptr_null(xfs_btree_cur, xfs_btree_ptr)
   - 然后退出
   - 首先根据xfs_btree_rec计算xfs_btree_key 
   > xfs_btree_cur->xfs_btree_ops->init_key_from_rec(xfs_btree_key, xfs_btree_rec)
   - 获取level对应的xfs_btree_block / xfs_buf
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   - 检查它是否满了??
   > xfs_btree_get_numrecs(xfs_btree_block)
   > xfs_btree_cur->xfs_btree_ops->get_maxrecs(xfs_btree_cur, level)
   - 如果满了,分裂或移动分支 
   > xfs_btree_make_block_unfull(xfs_btree_cur, level, numrecs, optr, ptr, xfs_btree_ptr nptr, xfs_btree_cur, xfs_btree_rec nrec, stat)
   - 上面为何计算新的xfs_btree_rec? 分裂后产生新的xfs_btree_ptr/xfs_btree_key还算正常??
   - 重新获取xfs_btree_cur中level对应的结点, 上面可能回修改btree 
   > xfs_btree_get_block(xfs_btree_cur, levle, xfs_buf)
   > xfs_btree_get_numrecs(xfs_btree_block)
   - 如果level > 0, 插入的结点是内部结点?? 
   - 找到ptr对应的xfs_btree_key/xfs_btree_ptr的位置
   - 然后移动xfs_btree_key/xfs_btree_ptr,为插入准备 
   > xfs_btree_shift_keys(xfs_btree_cur, xfs_btree_key, 1 numrecs-ptr+1)
   > xfs_btree_shift_keys(xfs_btree_cur, xfs_btree_ptr, 1, numrecs-ptr+1)
   - 插入新的xfs_btree_key/xfs_btree_ptr
   - key是根据xfs_btree_rec计算的,但xfs_btree_ptr是参数传进来的?
   - 然后log这些修改, 增加xfs_btree_block->numrecs
   - 如果level==0, 直接把参数xfs_btree_rec插入到ptr位置处
   > xfs_btree_rec_addr(xfs_btree_cur, ptr, xfs_btree_block)
   > xfs_btree_shift_recs(xfs_btree_cur, xfs_btree_rec, 1, numrecs - ptr + 1)
   > xfs_btree_copy_recs(xfs_btree_cur, xfs_btree_rec, recp, 1)
   - 然后log这些修改, 增加xfs_btree_block->numrecs
   - 如果插入的位置是第一个分支/记录, 需要更新父结点的key 
   > xfs_btree_updkey(xfs_btree_key, level+1)
   - 如果是最后一个结点?? 同样更新什么?? 
   > xfs_btree_is_lastrec(xfs_btree_cur, xfs_btree_block, level)
   > xfs_btree_cur->xfs_btree_ops->update_lastrec(xfs_btree_cur, xfs_btrree_block, xfs_btree_rec, xfs_btree_ptr, LASTREC_UPDATE)
   - 然后返回这里使用的参数, 从分裂中返回的参数,这里全部返回

** xfs_btree_insert(xfs_btree_cur, stat) 
   - 向btree中插入xfs_btree_rec
   - 首先准备xfs_btree_ptr 
   > xfs_btree_set_ptr_null(xfs_btree_cur, xfs_btree_ptr)
   - 从xfs_btree_cur中取出来对应的xfs_btree_rec
   - 它的数据结构是大端的 
   > xfs_btree_cur->xfs_btree_ops->init_rec_from_cur(xfs_btree_cur, xfs_btree_rec)
   - 循环处理,从叶子结点开始插入 
   > xfs_btree_insrec(xfs_btree_cur, level, xfs_btree_ptr, xfs_btree_rec, xfs_btree_cur, i) 
   - 如果上面返回的xfs_btree_cur和传入的不一样,说明有分裂?? 
   - 更新原始的xfs_btree_cur 
   > xfs_btree_cur->xfs_btree_ops->update_cursor(xfs_btree_cur, xfs_btree_cur)
   - 更新xfs_btree_cur->bc_nlevels, 删除就的xfs_btree_cur 
   > xfs_btree_del_cursor(xfs_btree_cur, XFS_BTREE_NOERROR)
   - 如果上面返回的xfs_btree_ptr不是NULL, 继续操作
   - 估计全部的参数都在分裂的地方使用

** xfs_btree_kill_iroot(xfs_btree_cur)
   - 使用一个内部结点代替xfs_ifork中的根结点
   - 降低btree的高度
   - xfs_btree_cur->bc_flags必须有XFS_BTREE_ROOT_IN_INODE, 而且高度必须>1
   - 如果是level==2, 不继续操作, 不会用叶子结点代替根结点
   - 获取xfs_btree_block, 它的分支必须为1
   > xfs_btree_get_iroot(xfs_btree_cur)
   > xfs_btree_get_numrecs(xfs_btree_block)
   - 获取这个唯一的子结点 
   > xfs_btree_get_block(xfs_btree_block, level-1, xfs_buf)
   > xfs_btree_get_numrecs(xfs_btree_block)
   - 检查是否超过根结点的限制
   > xfs_btree_cur->xfs_btree_ops->get_dmaxrecs(xfs_btree_cur, level)
   - 如果超过,直接退出
   - 否则需要重新分配xfs_ifork中的空间  
   > xfs_iroot_realloc(xfs_btree_cur->bc_private->b->xfs_inode, index, whichfork)
   - 开始更新根结点, 设置numrecs, level减1
   - 复制xfs_btree_key / xfs_btree_ptr
   - 把原来的子结点释放 
   > xfs_btree_cur->xfs_btree_ops->free_block(xfs_btree_cur, xfs_buf)
   - 然后更新xfs_btree_cur, bc_nlevels -1
   - 然后log修改的xfs_dinode 
   > xfs_trans_log_inode(xfs_btree_cur->xfs_trans, xfs_inode, XFS_ILOG_CORE | xfs_ilog_fbroot(whichfork))

** xfs_btree_kill_root(xfs_btree_root, xfs_buf, level, xfs_btree_ptr newroot)
   - 首先初始化新的根结点?? 
   > xfs_btree_cur->xfs_btree_ops->set_root(xfs_btree_cur, newroot, -1)
   - 释放参数xfs_buf?? 它是原来的根结点? 
   > xfs_btree_cur->xfs_btree_ops->free_block(xfs_btree_cur, xfs_buf)
   - 降低xfs_btree_cur->bc_nlevels --, 设置level指向的bc_bufs/bc_ra为NULL
   - 新的结点怎么弄?? 

** xfs_btree_dec_cursor(xfs_btree_cur, level, stat)
   - 如果level > 0, 操作内存结点?? 
   > xfs_btree_decrement(xfs_btree_cur, level, i)
   - 对于叶子结点,不操作??

** xfs_btree_delrec(xfs_btree_cur, level, stat)
   - 又是一个庞大的函数!!!
   - 删除xfs_btree_cur中level对应的结点的bc_ptrs对应的分支??
   - 获取对应的xfs_btree_block / xfs_buf  
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   > xfs_btree_get_numrecs(xfs_btree_block)
   - 获取对应的分支索引ptr = xfs_btree_cur->bc_ptrs[level]
   - 如果ptr超过numrecs, 返回错误
   - 如果level > 0, 操作内部结点, 直接移动xfs_btree_key/xfs_btree_ptr 
   > xfs_btree_shift_keys(xfs_btree_cur, xfs_btree_key, -1, num_recs-ptr)
   > xfs_btree_shfit_ptrs(..)
   > xfs_btree_log_keys(..)
   > xfs_btree_log_ptrs(..)
   - 如果ptr ==1, 需要准备一个xfs_btree_key, 给后面的操作使用??
   > xfs_btree_key_addr(xfs_btree_cur, 1, xfs_btree_block)
   - 如果是叶子结点, 同样移动后面的xfs_btree_rec, 覆盖调要删除的 
   > xfs_btree_shift_recs(..)
   > xfs_btree_log_recs(..) 
   - 如果ptr ==1, 同样准备一个xfs_btree_key 
   > xfs_btree_cur->xfs_btree_ops->init_key_from_rec(xfs_btree_key, xfs_btree_rec_addr(xfs_btree_cur, 1, xfs_btree_block))
   - 然后修改xfs_btree_block->numrecs, log这些修改!!
   - 如果操作的是最后一个记录,更新btree 
   > xfs_btree_is_lastrec(xfs_btree_cur, xfs_btree_block, level)
   > xfs_btree_cur->xfs_btree_ops->update_lastrec(xfs_btree_cur, xfs_btree_block, NULL, xfs_btree_ptr, LASTREC_UPDATE)
   - 如果level == xfs_btree_cur->bc_nlevels -1?? 可以结束操作??
   - 如果根结点在xfs_ifork中 
   - xfs_btree_cur->bc_flags有XFS_BTREE_ROOT_IN_INODE
   - 既然减少xfs_btree_ptr, 相应的减少xfs_dinode中的空间 
   > xfs_iroot_realloc(xfs_inode, -1, whichfork)
   - 尝试删除根结点,减小高度 
   > xfs_btree_kill_iroot(xfs_btree_cur)
   - 为何移动指针??
   > xfs_btree_dec_cursor(xfs_btree_cur, level, stat)
   - 如果根结点不在xfs_ifork中, 如果分支数numrecs ==1, 而且level > 0, 同样删除根结点 
   - 获取第一个分支指针
   > xfs_btree_ptr_addr(xfs_btree_cur, 1, xfs_btree_block)
   - 使用它代替这个根结点
   > xfs_btree_kill_root(xfs_btree_cur, xfs_buf, level, xfs_btree_ptr)
   - 原来的根结点直接删除了,而且新的根结点在xfs_btree_cur->bc_bufs[level]中, 但还是英国把它的指针放到磁盘的某个位置上?? 哪里实现这些操作??
   - 如果是根结点,操作完成,直接退出
   - 否则继续， 如果上面删除的是第一个结点,首先更新父结点的key  
   > xfs_btree_updkey(xfs_btree_cur, xfs_btree_key, level+1)
   - 如果当前分支数numrecs大于最小分支数, 直接退出,不需要合并之类的 
   > xfs_btree_cur->xfs_btree_ops->get_minrecs(xfs_btree_cur, level)
   - 但得移动分支. .
   > xfs_btree_dec_cursor(xfs_btree_cur, level, stat)
   - 否则检查是否需要合并
   - 获取2边的兄弟结点, rptr / lptr
   > xfs_btree_get_sibling(xfs_btree_cur, xfs_btree_block, rptr, XFS_BTREE_RIGHTSIB)
   - 如果根结点在xfs_ifork中, 而且2边都是空, 而且是在倒数第2层?? level == xfs_btree_cur->bc_levels - 2 
   - 说明最上面2层都只有1个分支?? 考虑降低高度 
   > xfs_btree_kill_iroot(xfs_btree_cur)
   > xfs_btree_dec_cursor(xfs_btree_cur, level, stat)
   - 否则不能2边的分支都是空,父结点不能只有一个分支, 因为它不是根结点
   - 复制一个xfs_btree_cur 
   > xfs_btree_dup_cursor(xfs_btree_cur, tcur)
   - 如果右兄弟不是空  
   > xfs_btree_ptr_is_null(xfs_btree_cur, rptr)
   - 检查是否能借一个分支
   - 移动tcur的level层的指针, 指向对应xfs_btree_block的最后一个分支 
   > xfs_btree_lastrec(xfs_btree_cur, level)
   - 还要往前移动 ?? 到了右兄弟的第一个分支??
   > xfs_btree_increment(xfs_btree_cur, level, i)
   - 还要移动, 指向最后一个分支?
   - 为了不影响下面的移动??
   > xfs_btree_lastrec(xfs_btree_cur, level)
   - 获取对应的xfs_buf / xfs_btree_block
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf) 
   - 根据左兄弟指针,获取当前的结点的指针?? 
   > xfs_btree_get_sibling(xfs_btree_cur, xfs_btree_block right, xfs_btree_ptr cptr, XFS_BB_LEFTSIB)
   - 如果右兄弟能够的分支足够多 
   > xfs_btree_get_numrecs(xfs_btree_block) -1 >= xfs_btree_cur->xfs_btree_ops->get_minrecs(xfs_btree_cur, level)
   - 然后直接移动一个结点, 直接退出
   > xfs_btree_lshift(xfs_btree_cur, level) 
   - 然后释放xfs_btree_cur
   > xfs_btree_del_cursor(xfs_btree_cur, XFS_BTREE_NOERROR)
   - 并且原来的xfs_btree_cur向前移动一个分支?? 
   > xfs_btree_dec_cursor(xfs_btree_cur, level, stat)
   - 如果右兄弟的分支不够多, 记录它的分支,给后面使用
   - 同时把复制的xfs_btree_cur恢复到原来的xfs_btree_block 
   > xfs_btree_firstrec(xfs_btree_cur, level)
   > xfs_btree_decrement(xfs_btree_cur, level, i)
   - 如果左兄弟不为null, 检查是否能接一个分支 
   - 移动备份的xfs_btree_cur
   > xfs_btree_firstrec(xfs_btree_cur, level)
   > xfs_btree_decrement(xfs_btree_cur, level, i)
   > xfs_btree_firstrec(xfs_btree_cur, level)
   - 根据cur/level获取对应的xfs_btree_block / xfs_buf 
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   - 获取这个左兄弟的右兄弟?? 不就是当前操作的结点? 
   > xfs_btree_get_sibling(xfs_btree_cur, xfs_btree_block, cptr, XFS_BB_RIGHTSIB)
   - 检查分支的数量是否满足 
   > xfs_btree_get_numrecs(xfs_btree_block) -1 >= xfs_btree_cur->xfs_btree_ops->get_minrecs(xfs_btree_cur, level)
   - 如果满足,直接向右移动一个结点,然后退出 
   > xfs_btree_rshift(xfs_btree_cur, level, i)
   - 同时删除备份的xfs_btree_cur 
   > xfs_btree_del_cursor(xfs_btree_cur) 
   - 如果不能移动来解决问题,记录当前结点的分支数量 lrecs
   - 无法通过借分支来解决,只能合并2个结点
   - 如果左兄弟存在, 而且lrecs + 当前结点没有超过最大值 
   > xfs_btree_get_numrecs(xfs_btree_block)
   > xfs_btree_cur->xfs_btree_ops->get_maxrecs(xfs_btree_cur, level)
   - 这里需要把左兄弟结点读出来?? 之前没有读出来? 
   > xfs_btree_read_buf_block(xfs_btree_cur, xfs_btree_ptr lptr, level, 0, xfs_btree_block, xfs_buf)
   - 否则检查rrecs 和当前结点的分支数之和没有超过限制, 使用当前结点和右兄弟 
   - 如果level > 0, 要合并的是内部结点
   - 需要把right的xfs_btree_key / xfs_btree_ptr移动到left结点 
   > xfs_btree_key_addr(xfs_btree_cur, lrecs + 1, left)
   > xfs_btree_key_addr(xfs_btree_cur, 1, right)
   > xfs_btree_ptr_addr(..)
   > xfs_btree_copy_keys(..)
   > xfs_btree_copy_ptrs(..)
   - log左边结点的修改, 右边结点不管,因为要删除 
   > xfs_btree_log_keys(..)
   > xfs_btree_log_ptrs(..)
   - 如果level ==0, 需要移动xfs_btree_rec 
   > xfs_btree_rec_addr(..)
   > xfs_btree_copy_recs(..)
   > xfs_btree_log_recs(..)
   - 最后设置左边的结点的xfs_btree_block 
   > xfs_btree_set_numrecs(left, lrecs + rrecs)
   - 修改对应的右兄弟结点
   > xfs_btree_get_sibling(xfs_btree_cur, right, cptr, XFS_BB_RIGHTSIB)
   > xfs_btree_set_sibling(xfs_btree_cur, left, cptr, XFS_BB_RIGHTSIB)
   - 还有右兄弟的右兄弟的左兄弟 
   > xfs_btree_get_sibling(xfs_btree_cur, left, cptr, XFS_BB_RIGHTSIB)
   > xfs_btree_read_buf_block(xfs_btree_cur, cpr, level, 0, xfs_btree_block, xfs_buf)
   > xfs_btree_set_sibling(xfs_btree_cur, rblock, xfs_btree_ptr, XFS_BB_LEFTSIB)
   - 还要log这些修改 
   > xfs_btree_log_block(xfs_btree_cur, xfs_buf, XFS_BB_LEFTSIB)
   - 把右边的兄弟结点释放  
   > xfs_btree_cur->xfs_btree_ops->free_block(xfs_btree_cur, xfs_buf)
   - 如果原来的结点释放,也就是合并到左兄弟上面
   - 需要修改xfs_btree_cur->bc_bufs/bc_ptrs
   - 如果原来的结点没有释放,它合并了右兄弟
   > xfs_btree_increment(xfs_btree_cur, level+1, i)
   - 这里的意思是右兄弟删除,所以指针level+1应该指向删除的结点
   - 就像上面合并到右兄弟一样,level+1层指向的还是当前结点
   - 当前结点虽然删除,但它在父结点中对应的xfs_btree_key / xfs_btree_ptr还留着
   - 需要继续调用这个函数,删除xfs_btree_cur level+1指向的记录
   - 这里需要向上删除,设置参数stat = 2
   - 而上面已经解决分支数量, 设置参数stat = 1
   - 还有不需要解决分支问题的,应该设置stat = 0

** xfs_btree_delete(xfs_btree_cur, stat)
   - 循环处理，直到不需要删除父结点记录  
   - i != 2
   > xfs_btree_delrec(xfs_btree_cur, level, i)
   - 检查xfs_btree_cur->bc_ptrs中的指针
   - 如果xfs_btree_cur->bc_ptrs[level] ==0, 向后移动指针 
   > xfs_btree_decrement(xfs_btree_cur, level, i)
   - 这里只是修正指针,因为level一下的不会修改..
   
** xfs_btree_get_rec(xfs_btree_cur, xfs_btree_rec, stat)
   - 获取叶子中的xfs_btree_rec的指针
   - 只检查叶子结点的分支索引 xfs_btree_cur->bc_ptrs[0]
   > xfs_btree_get_block(xfs_btree_cur, 0, xfs_buf)
   > xfs_btree_get_numrecs(xfs_btree_block)
   - 读取xfs_btree_block后面的数据
   > xfs_btree_cur_addr(xfs_btree_cur, ptr, xfs_btree_block)

** xfs_btree_block_change_owner(xfs_btree_cur, level, new_owner, buffer_list)
   - 把xfs_btree_cur中level对应的结点的owner改为new_owner? 它应该是xfs_ino_t
   - 首先预读兄弟结点 
   > xfs_btree_readahead(xfs_btree_cur, level, XFS_BTCUR_RIGHTRA)
   - 获取level对应的xfs_btree_block / xfs_buf 
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   - 设置xfs_btree_block->bb_u->l->bb_owner = new_owner
   - 上面可能获取不到xfs_buf, 因为他在xfs_ifork中?? 那还需要修改owner??
   - 如果xfs_buf不是NULL, log这些修改  
   - ordered??
   > xfs_trans_ordered_buf(xfs_trans, xfs_buf)
   > xfs_btree_log_block(xfs_btree_cur, xfs_buf, XFS_BB_OWNER)
   - 然后准备右兄弟结点 
   > xfs_btree_get_sibling(xfs_btree_cur, xfs_btree_block, xfs_btree_ptr, XFS_BB_RIGHTSIB)
   > xfs_btree_lookup_get_block(xfs_btree_cur, level, xfs_btree_ptr, xfs_btree_block)
   - 这里取出来没有使用

** xfs_btree_change_owner(xfs_btree_cur, new_owner, buffer_list)
   - 创建一个xfs_btree_ptr??
   > xfs_btree_cur->xfs_btree_ops->init_ptr_from_cur(xfs_btree_cur, xfs_btree_ptr)
   - 遍历所有的结点?? 使用兄弟结点,不需要回朔
   - 遍历每一层,获取第一个分支
   > xfs_btree_lookup_get_block(xfs_btree_cur, level, xfs_btree_ptr, xfs_btree_block)
   - 获取第一个分支的磁盘位置 
   > xfs_btree_ptr_addr(xfs_btree_cur, 1, xfs_btree_block)
   - 然后遍历这一层的所有结点
   > xfs_btree_block_change_owner(xfs_btree_cur, level, new_owenr, buffer_list)

* xfs_alloc_btree.c

** xfs_agf
   - 管理free block的btree的信息
   - 2个btree, XFS_BTNUM_BNOi, XFS_BTNUM_CNTi
   #+BEGIN_SRC 
	/*
	 * Common allocation group header information
	 */
	__be32		agf_magicnum;	/* magic number == XFS_AGF_MAGIC */
	__be32		agf_versionnum;	/* header version == XFS_AGF_VERSION */
	__be32		agf_seqno;	/* sequence # starting from 0 */
	__be32		agf_length;	/* size in blocks of a.g. */
	/*
	 * Freespace information
	 */
	__be32		agf_roots[XFS_BTNUM_AGF];	/* root blocks */
	__be32		agf_spare0;	/* spare field */
	__be32		agf_levels[XFS_BTNUM_AGF];	/* btree levels */
	__be32		agf_spare1;	/* spare field */

	__be32		agf_flfirst;	/* first freelist block's index */
	__be32		agf_fllast;	/* last freelist block's index */
	__be32		agf_flcount;	/* count of blocks in freelist */
	__be32		agf_freeblks;	/* total free blocks */

	__be32		agf_longest;	/* longest free space */
	__be32		agf_btreeblks;	/* # of blocks held in AGF btrees */
	uuid_t		agf_uuid;	/* uuid of filesystem */

	/*
	 * reserve some contiguous space for future logged fields before we add
	 * the unlogged fields. This makes the range logging via flags and
	 * structure offsets much simpler.
	 */
	__be64		agf_spare64[16];

	/* unlogged fields, written during buffer writeback. */
	__be64		agf_lsn;	/* last write sequence */
	__be32		agf_crc;	/* crc of agf sector */
	__be32		agf_spare2;

	/* structure must be padded to 64 bit alignment */   
   #+END_SRC

** xfs_alloc_rec 
   - xfs_btree_rec中的数据, 表示AG内部的磁盘空间
   - xfs_alloc_key也是用这个数据结构!!
   #+BEGIN_SRC 
	__be32		ar_startblock;	/* starting block number */
	__be32		ar_blockcount;	/* count of free blocks */   
   #+END_SRC

** xfs_alloc_rec_incore 
   #+BEGIN_SRC 
	xfs_agblock_t	ar_startblock;	/* starting block number */
	xfs_extlen_t	ar_blockcount;	/* count of free blocks */   
   #+END_SRC

** xfs_allocbt_dup_cursor(xfs_btree_cur)
   - 复制xfs_btree_cur, 使用xfs_btree_cur的参数创建一个
   - 最后一个参数bc_btnum区别2个btree
   - 如果是XFS_BTNUM_CNTi,就是以长度排序的btree
   - 如果是XFS_BTNUM_BNOi,就是按照位置排序的btree
   > xfs_allocbt_init_cursor(xfs_mount, xfs_trans, xfs_bug agi, agno, xfs_btree_cur->bc_btnum)

** xfs_allocbt_set_root(xfs_btree_cur, xfs_btree_ptr)
   - 设置根结点的指针,并修改对应的高度
   - 先获取xfs_agf, 根据xfs_btree_cur->bc_private->a->xfs_buf
   > XFS_BUF_TO_AGF(xfs_buf)
   - 设置xfs_agf->agf_roots[btnum], agf_levels[btnum]
   - xfs_agf->agf_seqno是agno?? 根据它获取xfs_perag
   - 增加xfs_perag->pagf_levels[btnum] += inc
   - log对xfs_agf的修改 
   > xfs_alloc_log_agf(xfs_trans, xfs_buf, XFS_AGF_ROOTS|XFS_AGF_LEVELS)

** xfs_allocbt_alloc_block(xfs_btree_cur, xfs_btree_ptr start, xfs_btree_ptr new, length, stat)
   - length还是没有使用
   - 根据start分配new
   - 先从freelist中分配, 缓存的block
   > xfs_alloc_get_freelist(xfs_trans, xfs_btree_cur->bc_private->a->xfs_buf, bno, 1)
   - 如果失败, 直接返回??
   - 重新设置这个xfs_buf 
   > xfs_extent_busy_reuse(xfs_mount, agno, bno, 1, false)
   - transaction?? 
   > xfs_trans_agbtree_delta(xfs_trans, 1)
   - 把agbno给参数new

** xfs_allocbt_free_block(xfs_btree_cur, xfs_buf)
   - 释放结点使用的xfs_buf
   - 获取地址的agbno
   > xfs_daddr_to_agbno(xfs_mount, XFS_BUF_ADDR(xfs_buf)
   - 把它释放给freelist??
   > xfs_alloc_put_freelist(xfs_trans, xfs_buf, NULL, bno, 1)
   - 同时把它放到busylist?? 
   > xfs_extent_busy_insert(xfs_trans, agno, bno, 1, XFS_EXTENT_BUSY_SKIP_DISCARD)
   - 修改预留的空间?? 
   > xfs_trans_agbtree_delta(xfs_trans, -1)
   - 提交transaction? 
   > xfs_trans_binval(xfs_trans, xfs_buf)

** xfs_allocbt_update_lastrec(xfs_btree_cur, xfs_btree_block, xfs_btree_rec rec, ptr, reason)
   - 更新AGF中最长的extent?
   - xfs_btree_cur->bc_btnum必须是XFS_BTNUM_CNT, btree中的extent根据长度排序
   - 如果reason == LASTREC_UPDATE, 检查xfs_btree_cur是否指向结点的最后一个记录
   - 如果不是,就不是最长的extent? 直接返回 
   > xfs_btree_get_numrecs(xfs_btree_block)
   - 获取extent的长度xfs_alloc_rec->ar_blockcount
   - 如果reason == LASTREC_INSERT?
   - 如果它长度超过xfs_agf->agf_longest, 使用它更新agf?
   - 如果reason == LASTREC_DELREC? ptr必须超过xfs_btree_block的长度,它指向的记录已经删除
   - 获取现在xfs_btree_block的最后一个记录 
    > XFS_ALLOC_REC_ADDR(xfs_mount, xfs_btree_block, numrecs)
   - 使用它的长度 xfs_alloc_rec->ar_blockcount
   - 使用上面计算的长度更新xfs_agf->agf_longest
   - 同时根据agno, 获取xfs_perag, 更新xfs_perag->pagf_longest
   - 记录对agf的修改 
   > xfs_alloc_log_agf(xfs_trans, xfs_buf, XFS_AGF_LONGEST)

** xfs_allocbt_get_minrecs(xfs_btree_cur, level)
   - 使用xfs_mount->m_alloc_mnr[level !=0 ]

** xfs_allocbt_get_maxrecs(xfs_btree_cur, level)
   - 使用xfs_mount->m_alloc_mxr[level !=0]

** xfs_allocbt_init_key_from_rec(xfs_btree_key, xfs_btree_rec)
   - 2者使用相同的数据结构,可以直接复制

** xfs_alloc_init_rec_from_key(xfs_btree_key, xfs_btree_rec)
   - 和上面相反  

** xfs_allocbt_init_rec_from_cur(xfs_btree_cur, xfs_btree_ptr)
   - 获取根结点的指针
   - 首先获取xfs_agf
   - xfs_agf->agf_seqno必须和xfs_btree_cur->bc_private->a->agno相同
   - 获取xfs_agf->agf_roots[xfs_btree_cur->bc_btnum]

** xfs_allocbt_key_diff(xfs_btree_cur, xfs_btree_key)
   - 比较xfs_btree_key->xfs_alloc_key和xfs_btree_cur->bc_rec->xfs_alloc_rec
   - 2者数据结构相同
   - 如果btree是XFS_BTNUM_BNO, 根据xfs_alloc_key->ar_startblock
   - 如果btree是XFS_BTNUM_CNT, 先根据ar_blockcount排序,然后根据startblock排序

** xfs_allocbt_verify(xfs_buf)
   - 首先检查xfs_btree_block
   - crc, blkno, uuid, owner
   - magci区分XFS_ABTB_MAGIC和XFS_ABTC_MAGIC
   - numrecs不能超过xfs_mount->m_alloc_mxr[level !=0]
   - 检查sibling指针, 不能超过xfs_sb->sb_agblocks

** xfs_allocbt_read_verify(xfs_buf)
   - 检查crc校验 
   > xfs_btree_sblock_verify_crc(xfs_buf)
   > xfs_allocbt_verify(xfs_buf)

** xfs_allocbt_write_verify(xfs_buf)
   > xfs_allocbt_verify(xfs_buf)
   > xfs_btree_sblock_calc_crc(xf_buf)

** xfs_buf_ops xfs_allocbt_buf_ops
   - 包装上面的2个函数 

** xfs_allocbt_keys_inorder(xfs_btree_cur,  xfs_btree_key key1, key2)
   - 比较xfs_btree_key, 使用里面的xfs_alloc_key
   - 如果xfs_btree_cur->bt_btnum是XFS_BTNUM_BNO
   - 比较startblock
   - 否则先比较blockcount, 再比较blockcount 

** xfs_allocbt_recs_inorder(xfs_btree_cur, xfs_btree_rec r1, r2)
   - 和上面一样

** xfs_btree_ops xfs_allocbt_ops
   - 保障上面这些回调函数

** xfs_allocbt_init_cursor(xfs_mount, xfs_trans, xfs_buf, xfs_agnumber_t agno, xfs_btnum_t btnum)
   - 构造一个xfs_btree_cur
   - 设置xfs_mount, xfs_trans, btnum
   - bc_blocklog什么用??
   - 设置xfs_btree_cur->bc_nlevels为xfs_agf->agf_levels
   - 如果btnum是XFS_BTNUM_CNT, 需要设置xfs_btree_cur->bc_flags的XFS_BTREE_LASTREC_UPDATE
   - 设置agf的xfs_buf, agno 
     
** xfs_allocbt_maxrecx(xfs_mount, blocklen, leaf)
   - 计算block支持的最多分支或记录数量
   - 这里和agi一样, blocklen 减去xfs_btree_block 
   - blocklen -= XFS_ALLOC_BLOCK_LEN(xfs_mount)
   - 对于叶子结点  blocklen /= sizeof(xfs_alloc_rec)
   - 对于内部结点 blocklen /= (sizeof(xfs_alloc_ptr) + sizeof(xfs_alloc_key)
