* xfs_alloc_btree.c

* xfs_alloc.c 

* xfs_bmap_btree.c

* xfs_buf.c

* xfs_ialloc_btree.c
* xfs_btree.c 

** xfs_btree_cur 
   #+BEGIN_SRC 
	struct xfs_trans	*bc_tp;	/* transaction we're in, if any */
	struct xfs_mount	*bc_mp;	/* file system mount struct */
	const struct xfs_btree_ops *bc_ops;
	uint			bc_flags; /* btree features - below */
	union {
		xfs_alloc_rec_incore_t	a;
		xfs_bmbt_irec_t		b;
		xfs_inobt_rec_incore_t	i;
	}		bc_rec;		/* current insert/search record value */
	struct xfs_buf	*bc_bufs[XFS_BTREE_MAXLEVELS];	/* buf ptr per level */
	int		bc_ptrs[XFS_BTREE_MAXLEVELS];	/* key/record # */
	__uint8_t	bc_ra[XFS_BTREE_MAXLEVELS];	/* readahead bits */
#define	XFS_BTCUR_LEFTRA	1	/* left sibling has been read-ahead */
#define	XFS_BTCUR_RIGHTRA	2	/* right sibling has been read-ahead */
	__uint8_t	bc_nlevels;	/* number of levels in the tree */
	__uint8_t	bc_blocklog;	/* log2(blocksize) of btree blocks */
	xfs_btnum_t	bc_btnum;	/* identifies which btree type */
	union {
		struct {			/* needed for BNO, CNT, INO */
			struct xfs_buf	*agbp;	/* agf/agi buffer pointer */
			xfs_agnumber_t	agno;	/* ag number */
		} a;
		struct {			/* needed for BMAP */
			struct xfs_inode *ip;	/* pointer to our inode */
			struct xfs_bmap_free *flist;	/* list to free after */
			xfs_fsblock_t	firstblock;	/* 1st blk allocated */
			int		allocated;	/* count of alloced */
			short		forksize;	/* fork's inode space */
			char		whichfork;	/* data or attr fork */
			char		flags;		/* flags */
#define	XFS_BTCUR_BPRV_WASDEL	1			/* was delayed */
		} b;
	}		bc_private;	/* per-btree type data */   
   #+END_SRC

** xfs_btree_block 
   - 这里的数据类型是大端的，所以应该是磁盘中的数据格式,使用时先转化
   #+BEGIN_SRC 
	__be32		bb_magic;	/* magic number for block type */
	__be16		bb_level;	/* 0 is a leaf */
	__be16		bb_numrecs;	/* current # of data records */
	union {
		struct {
			__be32		bb_leftsib;
			__be32		bb_rightsib;

			__be64		bb_blkno;
			__be64		bb_lsn;
			uuid_t		bb_uuid;
			__be32		bb_owner;
			__le32		bb_crc;
		} s;			/* short form pointers */
		struct	{
			__be64		bb_leftsib;
			__be64		bb_rightsib;

			__be64		bb_blkno;
			__be64		bb_lsn;
			uuid_t		bb_uuid;
			__be64		bb_owner;
			__le32		bb_crc;
			__be32		bb_pad; /* padding for alignment */
		} l;			/* long form pointers */
	} bb_u;				/* rest */   
   #+END_SRC

** xfs_magics
   - 各种magic
   #+BEGIN_SRC 
#define	XFS_ABTB_MAGIC		0x41425442	/* 'ABTB' for bno tree */
#define	XFS_ABTB_CRC_MAGIC	0x41423342	/* 'AB3B' */
#define	XFS_ABTC_MAGIC		0x41425443	/* 'ABTC' for cnt tree */
#define	XFS_ABTC_CRC_MAGIC	0x41423343	/* 'AB3C' */     
#define XFS_BMAP_MAGIC		0x424d4150	/* 'BMAP' */  //extentmap btree节点的头
#define XFS_BMAP_CRC_MAGIC	0x424d4133	/* 'BMA3' */
#define	XFS_IBT_MAGIC		0x49414254	/* 'IABT' */  //inode map btree节点的头
#define	XFS_IBT_CRC_MAGIC	0x49414233	/* 'IAB3' */
   #+END_SRC

** xfs_btnum_t 
   #+BEGIN_SRC 
	XFS_BTNUM_BNOi,   //对应XFS_ABTB_MAGIC
	XFS_BTNUM_CNTi,   //对应XFS_ABTC_MAGIC
	XFS_BTNUM_BMAPi,  //对应XFS_BMAP_MAGIC
	XFS_BTNUM_INOi,   //对应XFS_IBT_MAGIC
	XFS_BTNUM_MAX   
   #+END_SRC


** xfs_btree_check_lblock(xfs_btree_cur cur, xfs_btree_block block, level, xfs_buf)
   - 比较xfs_btree_block->bb_u->l->bb_uuid 和 xfs_sb->sb_uuid
   - 比较xfs_btree_block->bb_u->l->bb_blkno 和 xfs_buf->b_bn, 磁盘位置??
   - 比较magic, 根据xfs_btree_cur->bc_btnum计算使用的magic 
   > xfs_btree_magic(xfs_btree_cur)
   - 检查xfs_btree_block->level 和参数level
   - 检查xfs_btree_block->bb_numrecs, 不能超过上线
   > xfs_btree_cur->bc_ops->get_maxrecs(xfs_btree_cur, level)

** xfs_btree_check_sblock(xfs_btree_cur, xfs_btree_block, level, xfs_buf)
   - 这个和上面有什么区别??

** xfs_btree_check_block(xfs_btree_cur, xfs_btree_block, level, xfs_buf)
   - xfs_btree_cur->bc_flags的XFS_BTREE_LONG_PTRS表示什么?? 磁盘的指针?? 
   - 影响xfs_btree_block->bb_u->s的rightsib/leftsib
   > xfs_btree_check_lblock(xfs_btree_cur, xfs_btree_block, level, xfs_buf)
   > xfs_btree_check_sblock(xfs_btree_cur, xfs_btree_block, level, xfs_buf)

** xfs_btree_check_lptr(xfs_btree_cur, xfs_dfsbno_t bno, level)
   - 如果level>0, bno直线子节点??
   - 检查磁盘位置,包括agno, agbno 

** xfs_btree_check_sptr(xfs_btree_cur, xfs_agblock_t bno, level)
   - bno是ag内部偏移 
   > bno > xfs_btree_cur->xfs_mount->xfs_sb->sb_agblocks

** xfs_btree_check_ptr(xfs_btree_cur, xfs_btree_ptr, index, level)
   - xfs_btree_ptr是btree内部节点的value数组?? 指向子分支 
   - 如果xfs_btree_cur->bc_flags有XFS_BTREE_LONG_PTR
   - 检查对应的磁盘指针是否有意义
   > xfs_btree_check_ptr(xfs_btree_cur, xfs_btree_ptr->l[index], level)

** xfs_btree_lblock_calc_crc(xfs_buf)
   - 如果xfs版本表示不使用crc,直接退出 
   > xfs_sb_version_hascrc(xfs_buf->xfs_buftarg->xfs_mount->xfs_sb)
   - 如果buf有xfs_log_item? 更新xfs_btree_block 
   - xfs_btree_block->bb_u->l->ll_lsn = xfs_buf_log_item->xfs_log_item->li_lsn 
   - 计算crc, 只计算头部
   > xfs_update_cksum(xfs_buf->b_addr, BBTOB(xfs_buf->b_length), XFS_BTREE_LBLOCK_CRC_OFF)

** xfs_btree_lblock_verify_crc(xfs_buf)
   - 首先判断xfs版本,支持crc 
   > xfs_sb_version_hascrc(xfs_buf->xfs_buftarg->xfs_mount->xfs_sb)
   > xfs_verify_cksum(xfs_buf->b_addr, BBTOB(xfs_buf->b_length), XFS_BTREE_LBLOCK_CRC_OFF)

** xfs_btree_sblock_calc_crc(xfs_buf)
   - 上面的指针是64位,这里是32位 

** xfs_btree_sblock_verify_crc(xfs_buf)
   - 上面的指针是64位,这里是32位 

** xfs_btree_del_cursor(xfs_btree_cur, error)
   - 释放xfs_btree_cur遍历时使用的xfs_buf 
   > xfs_trans_brelse(xfs_btree_cur->xfs_trans, xfs_btree_cur->bc_bufs[i])
   - 如果btree是XFS_BTNUM_BMAP, 映射extent? xfs_btree_cur->bc_private->b->allocated === 0
   - 最后释放自己

** xfs_btree_dup_cursor(xfs_btree_cur, cur, xfs_btree_cur ncur)
   - 复制一个xfs_btree_cur, 需要增加哪些资源?? 
   > xfs_btree_cur->bc_ops-dup_cursor(xfs_btree_cur)
   - 复制xfs_btree_cur中的数据 xfs_btree_cur->bc_rec
   - 这些不是指针,而是btree中的具体记录, xfs_bmbt_irec/xfs_alloc_rec_incore等都已经把磁盘格式转化为内存格式
   - 遍历xfs_btree_cur使用的节点指针 xfs_btree_cur->bc_nlevels 
   - 重新读取数据??
   > xfs_trans_read_buf(xfs_mount, xfs_trans, xfs_mount->xfs_buftarg, XFS_BUF_ADDR(xfs_buf), xfs_mount->m_bsize, 0, xfs_buf, xfs_btree_cur->bc_ops->buf_ops)

** xfs_btree_block_len(xfs_btree_cur)
   - 计算btree节点的xfs_btree_block头的大小??
   - 如果xfs_btree_cur->bc_flags有XFS_BTREE_LONG_PTR, 而且是crc, XFS_BTREE_CRC_BLOCKS, 返回XFS_BTREE_LBLOCK_CRC_LEN
   - 如果没有crc, 使用XFS_BTREE_LBLOCK_LEN
   - 如果没有XFS_BTREE_LONG_PTR, 但有XFS_BTREE_CRC_BLOCKS, 使用XFS_BTREE_SBLOCK_CRC_LEN
   - 否则使用XFS_BTREE_SBLOCK_LEN

** xfs_btree_ptr_len(xfs_btree_cur)
   - 分支指针的大小, sizeof(__be64), 或者sizeof(__be32)

** xfs_btree_rec_offset(xfs_btree_cur, n)
   - 计算叶子节点第n个记录的位置?? 
   - xfs_btree_block_len(xfs_btree_cur) + (n-1) * xfs_btree_cur->bc_ops->rec_len

** xfs_btree_key_offset(xfs_btree_cur, n)
   - 计算内部节点第n个key的位置 
   > xfs_btree_block_len(xfs_btree_cur) + (n-1) * xfs_btree_cur->bc_ops->key_len

** xfs_btree_ptr_offset(xfs_btree_cur, n, level)
   - 内部节点value的位置, 包括3部分偏移
   - xfs_btree_block头的偏移
   > xfs_btree_block_len(xfs_btree_cur) 
   - key的偏移
   - xfs_btree_cur->bc_ops->get_maxrecs(xfs_btree_cur, level) * xfs_btree_cur->bc_ops->key_len 
   - 然后是value的偏移 
   - (n-1) * xfs_btree_ptr_len(xfs_btree_cur)

** xfs_btree_rec 
   #+BEGIN_SRC 
	xfs_bmbt_rec_t		bmbt;
	xfs_bmdr_rec_t		bmbr;	/* bmbt root block */
	xfs_alloc_rec_t		alloc;
	xfs_inobt_rec_t		inobt;   
   #+END_SRC

** xfs_btree_rec_addr(xfs_btree_cur, n, xfs_btree_block)
   - 访问xfs_btree_block中的第n个节点 
   > xfs_btree_rec_offset(xfs_btree_cur, n)
   - xfs_btree_block应该指向内存中一个xfs_buf的数据, 返回的xfs_btree_rec,数据类新是磁盘格式的

** xfs_btree_key
   #+BEGIN_SRC 
	xfs_bmbt_key_t		bmbt;
	xfs_bmdr_key_t		bmbr;	/* bmbt root block */
	xfs_alloc_key_t		alloc;
	xfs_inobt_key_t		inobt;   
   #+END_SRC

** xfs_btree_key_addr(xfs_btree_cur, n, xfs_btree_block)
   - 和上面一样

** xfs_btree_ptr_addr(xfs_btree_cur, n, xfs_btree_block)
   - 这里需要xfs_btree_block指向节点的level 
   > xfs_btree_get_level(xfs_btree_block)
   > xfs_btree_ptr_offset(xfs_btree_cur, n, level)

** xfs_btree_get_iroot(xfs_btree_cur)
   - 获取btree的根节点, 还是xfs_btree_block指针, 数据类型的磁盘使用的
   - 首先找到对应的xfs_ifork 
   > XFS_IFORK_PTR(xfs_btree_cur->bc_private->b->xfs_inode, xfs_btree_cur->bc_private->b->whichfork)
   - 然后返回xfs_ifork->if_broot

** xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   - 获取xfs_btree_cur中level对应的节点的xfs_buf和xfs_btree_block
   - 如果xfs_btree_cur->bc_flags有XFS_BTREE_ROOT_IN_INODE, 而且level == xfs_btree_cur->bc_nlevels-1, 表示跟节点在xfs_ifork中??
   - 对于block/inode等待,就使用ag的专门的block 
   > xfs_btree_get_iroot(xfs_btree_cur)
   - 否则直接使用xfs_btree_cur->bc_bufs[level]
   > XFS_BUF_TO_BLOCK(xfs_buf)

** xfs_btree_get_bufl(xfs_mount, xfs_trans, xfs_fsblock_t, lock)
   - 创建xfs_fsblock_t对应的xfs_buf
   - 先转化磁盘地址
   > XFS_FSB_TO_DADDR(xfs_mount, xfs_fsblock_t)
   - 这里有读操作?
   > xfs_trans_get_buf(xfs_trans, xfs_mount->xfs_buftarg, d, xfs_mount->m_bsize, lock)

** xfs_btree_get_bufs(xfs_mount, xfs_trans, xfs_agnumber_t agno, xfs_agblock_t agbno, lock)
   - 磁盘地址是(agno, agbno)
   > XFS_AGB_TO_DADDR(xfs_mount, agno, agbno)
   > xfs_trans_get_buf(xfs_trans, xfs_mount->xfs_buftarg, d, xfs_mount->m_bsize, lock)

** xfs_btree_islastblock(xfs_btree_cur, level)
   - 首先获取xfs_btree_cur对应level的节点 
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   - 检查它的有效性 
   > xfs_btree_check_block(xfs_btree_cur, xfs_btree_block, level, xfs_buf)
   - 检查他的rightsib, 是否为空, 表示他是level层的最后一个节点
   - 如果使用64为磁盘指针,比较NULLDFSBNO, 32位使用NULLAGBLOCK (-1)

** xfs_btree_firstrec(xfs_btree_cur, level)
   - 获取level对应的xfs_btree_block 
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   > xfs_btree_check_block(xfs_btree_cur, xfs_btree_block, level, xfs_buf)
   - 如果他没有子节点?? xfs_btree_block->bb_numrecs ==0, 返回0
   - 否则设置xfs_btree_cur->bc_ptrs[level] ==1
   - 这里xfs_btree_ptr->bc_bufs[level]已经取出来, 只是修改bc_ptrs[level], 它决定下一层分支

** xfs_btree_lastrec(xfs_btree_cur, level)
   - 和上面相反,这里设置xfs_btree_cur->bc_ptrs[level] = xfs_btree_block->bb_numrecs
   - 这个指针是从1开始的.. 

** xfs_btree_offset(fields, offset, nbits, first, last)
   - fields对应offset的内存, 检查(0,nbits)中置位的范围, 给(first,last)
   - 只需要检查开头和结尾 

** xfs_btree_read_bufl(xfs_mount, xfs_trans, xfs_fsblock_t fsbno, lock, xfs_buf, refval, xfs_buf_ops)
   - 读取btree节点,磁盘地址是xfs_fsblock_t, 先转化为绝对地址  
   > XFS_FSB_TO_DADDR(xfs_mount, xfs_fsblock_t)
   - 读取xfs_buf 
   > xfs_trans_read_buf(xfs_mount, xfs_trans, xfs_mount->xfs_buftarg, d, xfs_mount->m_bsize, lock, xfs_buf, xfs_buf_ops)
   - 这里节点大小是xfs_mount->m_bsize

** xfs_btree_read_bufl(xfs_mount, xfs_fsblock_t fsbno, xfs_extlen_tcount, xfs_buf_ops)
   - 预读磁盘数据,转化磁盘地址 
   > XFS_FSB_TO_DADDR(xfs_mount,xfs_fsblock_t)
   > xfs_buf_readahead(xfs_mount->xfs_buftarg, d, xfs_mount->m_bsize *count, xfs_buf_ops)

** xfs_btree_reada_bufs(xfs_mount, xfs_agnumber_t agno, xfs_agblock_t agbno, xfs_extlen_t count, xfs_buf_ops ops)
   - 读取磁盘数据,地址由(agno,agbno)决定 
   > XFS_AGB_TO_DADDR(xfs_mount,agno,agbno)
   > xfs_buf_readahead(xfs_mount->xfs_buftarg,d, xfs_mount->m_bsize * count, xfs_buf_ops)

** xfs_btree_readahead_lblock(xfs_btree_cur, lr,xfs_btree_block)
   - 读取xfs_btree_block的兄弟节点 
   - 从xfs_btree_block->bb_u->l->bb_leftsib/bb_rightsib获取指针
   - 如果lr有XFS_BTCUR_LEFTRA, 读取左边的节点
   > xfs_btree_reada_bufl(xfs_btree_cur->xfs_mount, left, 1, xfs_btree_cur->bc_ops->buf_ops)
   - lr的XFS_BTCUR_RIGHTRA对应右边节点 

** xfs_btree_readahead_sblock(xfs_btree_cur, lr, xfs_btree_block)
   - 上面的xfs_btree_block使用指针是fsb,这里是agbno
   - 使用xfs_btree_cur->bc_private->a->agno计算磁盘地址 
   > xfs_btree_reada_bufs(xfs_btree_cur->xfs_mount, xfs_btree_cur->bc_private->a->agno, left, 1, xfs_btree_cur->xfs_btree_ops->xfs_buf_ops)

** xfs_btree_readahead(xfs_btree_cur, level, lr)
   - 如果level指向根节点,而且根节点在xfs_ifork中, 直接返回
   - xfs_btree_cur->bc_flags有XFS_BTREE_ROOT_IN_INODE, level == xfs_btree_cur->bc_nlevels - 1
   - 如果xfs_btree_cur->bc_ra[level]中已经有lr的标志,直接返回, 表示readahead已经完成
   - 否则设置xfs_btree_cur->bc_ra[level] 
   - 获取对应的xfs_btree_block 
   > XFS_BUF_TO_BLOCK(xfs_btree_cur->bc_bufs[level]
   - 如果xfs_btree_cur->bc_flags有XFS_BTREE_LONG_PTR, 使用xfs_fsblock_t预读
   > xfs_btree_readahead_lblock(xfs_btree_cur, lr, xfs_block_btree)
   > xfs_btree_readahead_sblock(xfs_btree_cur, lr, xfs_block_btree)

** xfs_btree_setbuf(xfs_btree_cur, level, xfs_buf)
   - 把xfs_buf给xfs_btree_cur->bc_bufs[level], 释放原来的
   > xfs_trans_brelse(xfs_btree_cur->xfs_trans, xfs_btree_cur->bc_bufs[level])
   - 重新计算xfs_btree_cur->bc_ra[level]
   - 如果xfs_buf中的xfs_btree_block的兄弟节点指针是NULLDFSBNO, 设置相关的XFS_BTCUR_RIGHTRA, XFS_BTCUR_LEFTRA, 以后不需要readahead 

** xfs_btree_ptr_is_null(xfs_btree_cur cur, xfs_btree_ptr ptr)
   - xfs_btree_ptr是分支指针
   - 比较xfs_btree_ptr->l/s和NULLDFSBNO/NULLAGBLOCK

** xfs_btree_set_ptr_null(xfs_btree_cur cur, xfs_btree_ptr ptr)
   - 设置为空指针, xfs_btree_ptr使用大端的数据类型, 需要转化

** xfs_btree_get_sibling(xfs_btree_cur, xfs_btree_block, xfs_btree_ptr, lr)
   - 获取xfs_btree_block的兄弟节点, lr决定right/left
   - 如果xfs_btree_cur->bc_flags有XFS_BTREE_LONG_PTR, 使用fsb 
   - 如果lr有XFS_BB_RIGHTSIB,设置xfs_btree_ptr为xfs_btree_block->bb_u->l->bb_rightsib
   - 否则使用bb_leftsib

** xfs_btree_set_sibling(xfs_btree_cur, xfs_btree_block, xfs_btree_ptr, lr)
   - 设置兄弟节点指针

** xfs_btree_init_block_init(xfs_mount, xfs_btree_block, xfs_daddr_t, magic, level, numrec, owner, flags)
   - 初始化xfs_btree_block, 它的数据类型是大端的
   - 先设置magic, level, numrecs
   - 下面根据XFS_BTREE_LONG_PTR而定
   - 兄弟节点设为NULL, 
   - 如果flags有XFS_BTREE_CRC_BLOCK, 设置bno, uuid, owner

** xfs_btree_init_block(xfs_mount, xfs_buf, magic, level, numrecs, owner, flags)
   - 初始化xfs_btree_block, 首先获取对应的xfs_btree_block
   > xfs_btree_init_block_int(xfs_mount, XFS_BUF_TO_BLOCK(xfs_buf), xfs_buf->b_bn, magic, level, numrecs, owner, flags)

** xfs_btree_init_block_cur(xfs_btree_cur, xfs_buf, level, numrecs)
   - 初始化xfs_buf中的xfs_btree_block
   - 如果xfs_btree_cur->bc_flags有XFS_BTREE_LONG_PTRS, owner就是ino?? 这个btree就是xfs_ifork的?? 
   - 否则设为xfs_btree_cur->bc_private->a->agno? btree中使用的指针限于ag内部?
   > xfs_btree_init_block_init(xfs_btree_cur->xfs_mount, XFS_BUF_TO_BLOCK(xfs_buf), xfs_buf->b_bn, xfs_btree_magic(xfs_btree_cur), level, numrecs, owner, xfs_btree_cur->bc_flags)

** xfs_btree_is_lastrec(xfs_btree_cur, xfs_btree_block, level)
   - 检查xfs_btree_block是否为btree的最后一个叶子节点??
   - 如果level >0, 返回0. 最后一个节点应该是叶子节点
   - 如果xfs_btree_cur->bc_flags也没有XFS_BTREE_LASTREC_UPDATE?? 返回0?
   - 获取xfs_btree_block的右兄弟 
   > xfs_btree_et_sibling(xfs_btree_cur, xfs_btree_block, xfs_btree_ptr, XFS_BB_RIGHTSIB)
   - 检查指针是否为null 
   > xfs_btree_ptr_is_null(xfs_btree_cur, xfs_btree_ptr)

** xfs_btree_buf_to_ptr(xfs_btree_cur, xfs_buf, xfs_btree_ptr)
   - 把xfs_buf的地址给xfs_btree_ptr
   - 如果xfs_btree_cur->bc_flags有XFS_BTREE_LONG_PTR, 需要xfs_fsblock_t格式
   > XFS_DADDR_TO_FSB(xfs_btree_cur->xfs_mount, XFS_BUF_ADDR(xfs_buf))
   - 否则使用agbno 
   > xfs_daddr_to_agbno(xfs_mount, XFS_BUF_ADDR(xfs_buf))

** xfs_btree_ptr_to_daddr(xfs_btree_ptr, xfs_btree_ptr ptr)
   - 把xfs_btree_ptr的指针转化为xfs_daddr_t格式 
   - 如果xfs_btree_cur->bc_flags有XFS_BTREE_LONG_PTRS, 使用xfs_fsblock_t 
   > XFS_FSB_TO_DADDR(xfs_btree_block->xfs_mount, be64_to_cpu(xfs_btree_ptr->l))
   - 否则使用agno/agbno

** xfs_btree_set_refs(xfs_btree_cur, xfs_buf)
   - 根据xfs_btree_cur->bc_btnum, 设置xfs_buf->b_lru_ref中的标志
   > xfs_buf_set_ref(xfs_buf, lru_ref)
   - 对于不同的btree, 设置不同的标志, XFS_ALLOC_BTREE_REF/XFS_INO_BTREE_REF/XFS_BMAP_BTREE_REF

** xfs_btree_get_buf_block(xfs_btree_cur, xfs_btree_ptr, flags, xfs_btree_block block, xfs_buf)
   - 获取xfs_btree_ptr指向的xfs_buf, 以及对应的xfs_btree_block 
   > xfs_btree_ptr_to_daddr(xfs_btree_cur, xfs_btree_ptr)
   > xfs_trans_get_buf(xfs_btree_cur->xfs_trans, xfs_mount->xfs_buftarg, d, xfs_mount->m_bsize, flags)
   - 设置xfs_buf->xfs_buf_ops = xfs_btree_cur->xfs_btree_ops->xfs_buf_ops
   > XFS_BUF_TO_BLOCK(xfs_buf)

** xfs_btree_read_buf_block(xfs_btree_cur, xfs_btree_ptr, level, flags, xfs_btree_block, xfs_buf)
   - 读取xfs_btree_ptr对应的xfs_buf, xfs_btree_block 
   > xfs_btree_ptr_to_daddr(xfs_btree_cur, xfs_btree_ptr)
   > xfs_trans_read_buf(xfs_mount, xfs_btree_cur->xfs_trans, xfs_mount->xfs_buftarg, d, xfs_mount->m_bsize, flags, xfs_buf, xfs_btree_cur->xfs_btree_ops->xfs_buf_ops)
   - 为何这里设置refs?
   > xfs_btree_set_refs(xfs_btree_cur, xfs_buf)
   > XFS_BUF_TO_BLOCK(xfs_buf)

** xfs_btree_copy_keys(xfs_btree_cur, xfs_btree_key dst, xfs_btree_key src, numkeys)
   - 复制xfs_btree_key数组, 数组单元长度是xfs_btree_cur->xfs_btree_ops->key_len

** xfs_btree_copy_recs(xfs_btree_cur, xfs_btree_rec dst, xfs_btree_rec src, numrecs)
   - 复制xfs_btree_rec数组, 直接使用memcpy
   - 数组单位长度是xfs_btree_cur->xfs_btree_ops->rec_len

** xfs_btree_copy_ptrs(xfs_btree_cur, xfs_btree_ptr dst, src, numptrs)
   - 复制xfs_btree_ptr数组, 单位是指针长度
   > xfs_btree_ptr_len(xfs_btree_cur)

** xfs_btree_shift_keys(xfs_btree_cur, xfs_btree_key, dir, numkeys)
   - dir表示向前还是向后移动

** xfs_btree_shift_recs(xfs_btree_cur, xfs_btree_rec, dir, numrecs)

** xfs_btree_shift_ptrs(xfs_btree_cur, xfs_btree_ptr, dir, numptrs)

** xfs_btree_log_keys(xfs_btree_cur, xfs_buf, first, last)
   - log xfs_buf中的修改?
   - 如果xfs_buf不是NULL, 记录(first, last)范围内的xfs_btree_key 
   > xfs_trans_buf_set_type(xfs_btree_cur->xfs_trans, xfs_buf, XFS_BLFT_BTREE_BUF)
   > xfs_trans_log_buf(xfs_btree_cur->xfs_trans, xfs_buf, xfs_btree_key_offset(xfs_btree_cur, first), xfs_btree_key_offset(xfs_btree_cur, last+1) -1 )
   - 如果xfs_buf, 要log根节点,而且在xfs_ifork中
   - log把整个根节点
   > xfs_trans_log_inode(xfs_btree_cur->xfs_trans, xfs_btree_cur->bc_private->b->xfs_inode, xfs_ilog_fbroot(whichfork))

** xfs_btree_log_recs(xfs_btree_cur, xfs_buf, first, last)
   - xfs_buf是叶子节点,不可能是根节点 
   - 只是log (first, last)范围内的xfs_btree_rec数组 

** xfs_btree_log_ptrs(xfs_btree_cur, xfs_buf, first, last)
   - 和上面处理xfs_btree_key一样

** xfs_btree_log_block(xfs_btree_cur, xfs_buf, fields)
   - log xfs_btree_block, 根据field计算范围
   - 这里有XFS_BB_MAGIC/LEVEL/NUMRECS/LEFTSIB/RIGHTSIB/BLKNO
   - 如果xfs_btree_cur->bc_flags有XFS_BTREE_CRC_BLOCKS, 而且fields是XFS_BB_ALL_BITS, 需要包括XFS_BB_ALL_BITS_CRC, 只有在全部log时,crc的log才有意义
   - 计算xfs_buf中的数据范围
   > xfs_btree_offset(fields, loffset/soffset, nbits, first, last)
   > xfs_trans_buf_set_type(xfs_btree_cur->xfs_trans, xfs_buf, XFS_BLFL_BTREE_BUF)
   > xfs_trans_log_buf(xfs_trans, xfs_buf, first, last)
   - 如果xfs_buf == NULL, 要log xfs_ifork中的数据 
   > xfs_trans_log_inode(xfs_btree_cur->xfs_trans, xfs_btree_cur->bc_private->b->xfs_inode, xfs_ilog_fbroot(whichfork))

** xfs_btree_increment(xfs_btree_cur, level, state)
   - 修改level层的指针, 指向下一个节点 
   - 预读level节点的右边兄弟节点, 可能会用到, 但不一定
   > xfs_btree_readahead(xfs_btree_cur, level, XFS_BTCUR_RIGHTRA)
   - 获取level对应的xfs_btree_block 
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   > xfs_btree_check_block(xfs_btree_cur, xfs_btree_block, level, xfs_buf)
   - 如果当前分支指针不是指向最后一个, 直接修改xfs_btree_cur->bc_ptrs[level], 然后可以结束
   - xfs_btree_get_numrecs(xfs_btree_block)
   - 如果当前是最后一个分支,需要使用对应的兄弟节点
   - 获取兄弟节点的磁盘位置
   > xfs_btree_get_sibling(xfs_btree_cur, xfs_btree_block, ptr, XFS_BB_RIGHTSIB)
   - 如果指针为空,直接退出
   > xfs_btree_ptr_is_null(xfs_btree_cur, xfs_btree_ptr)
   - 这里不用回朔就能判断level层是否有下一个节点
   - 但要修改xfs_btree_cur->bc_ptrs/bc_bufs, 还是得回朔
   - 向根结点方向回朔,找到不是最有一个分支的节点 
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   - 移动指针xfs_btree_cur->bc_ptrs[level], 指向下一个分支
   - 如果超过xfs_btree_block的分支数, 继续回朔
   > xfs_btree_get_numrecs(xfs_btree_block)
   - 如果需要继续,预读右边的兄弟节点 
   > xfs_btree_readahead(xfs_btree_cur, level, XFS_BTCUR_RIGHTRA)
   - 然后向level遍历,获取对应的xfs_buf指针,同时修改分支指针为1
   - 获取子节点磁盘位置
   > xfs_btree_ptr_add(xfs_btree_cur, xfs_btree_cur->bc_ptrs[level], xfs_btree_block)
   - 读取对应的xfs_buf
   > xfs_btree_read_buf_block(xfs_btree_cur, xfs_btree_ptr, level, 0, xfs_btree_block, xfs_buf)
   - 设置xfs_btree_cur->bc_bufs[level]
   > xfs_btree_setbuf(xfs_btree_cur, level, xfs_buf)
   - 设置xfs_btree_cur->bc_ptrs[level] ==1

** xfs_btree_decrement(xfs_btree_cur, level, stata)
   - 首先读取对应的左兄弟节点 
   > xfs_btree_readahead(xfs_btree_cur, leve, XFS_BTCUR_LEFTRA)
   - 首先修改分支指针 xfs_btree_cur->bc_ptrs[level] --
   - 如果修改后>0, 说明不用切换节点,直接退出
   - 否则需要切换多个节点, 检查是否有左边的兄弟节点 
   > xfs_btree_get_sibling(xfs_btree_cur, xfs_btree_block, xfs_btree_ptr, XFS_BB_LEFTSIB)
   > xfs_btree_ptr_is_null(xfs_btree_cur, xfs_btree_ptr)
   - 否则向上回朔, 找到有左边分支的父节点 
   - 只要减小 --xfs_btree_cur->bc_ptrs[level]
   - 而且减小后>0, 也就是有效的, 可以回朔
   > xfs_btree_readahead(xfs_btree_cur, level, XFS_BTCUR_LEFTRA)
   - 然后向level遍历, 更新xfs_btree_cur->bc_ptrs/bc_bufs
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   - 获取对应的子节点地址, 读取对应的xfs_buf
   > xfs_btree_ptr_addr(xfs_btree_cur, xfs_btree_cur->bc_ptrs[level], xfs_btree_block)
   > xfs_btree_read_buf_block(xfs_btree_cur, xfs_btree_ptr, level, 0, xfs_btree_block, xfs_buf)
   - 设置xfs_btree_cur->bc_bufs
   > xfs_btree_setbuf(xfs_btree_cur, level, xfs_buf)
   - 设置子分支的索引,指向最后一个节点 
   > xfs_btree_get_numrecs(xfs_btree_block)

** xfs_btree_lookup_get_block(xfs_btree_cur, level, xfs_btree_ptr, xfs_btree_block blkp)
   - 获取xfs_btree_cur中level对应的节点?? 
   - 如果level是最高层,而且btree在xfs_ifork中 
   - xfs_btree_cur->bc_flags有XFS_BTREE_ROOT_IN_INODE
   - level == xfs_btree_cur->bc_nlevels -1 
   - 直接去xfs_ifork中查找 
   > xfs_btree_get_iroot(xfs_btree_cur)
   - 否则获取level对应的xfs_buf, 检查它的地址和参数xfs_btree_ptr是否一致
   > XFS_BUF_ADDR(xfs_btree_cur->bc_bufs[level])
   > xfs_btree_ptr_to_daddr(xfs_btree_cur, xfs_btree_ptr)
   - 如果一致,可以使用对应的xfs_buf的xfs_btree_block 
   > XFS_BUF_TO_BLOCK(xfs_buf)
   - 如果不一致,需要读取参数xfs_btree_ptr指向的xfs_buf 
   > xfs_btree_read_buf_block(xfs_btree_cur, xfs_btree_ptr, level, 0, xfs_block_btree, xfs_buf)
   - 然后设置xfs_btree_cur->bc_bufs 
   > xfs_btree_setbuf(xfs_btree_cur, level, xfs_buf)

** xfs_lookup_get_search_key(xfs_btree_cur, level, keyno, xfs_btree_block, xfs_btree_key)
   - 计算当前查找的xfs_btree_key? 也就是keyno对应的分支的key?
   - 对于叶子节点,根据第keyno对应的xfs_btree_rec构造一个?? 
   > xfs_btree_cur->xfs_btree_ops->init_key_from_rec(xfs_btree_key, xfs_btree_rec_addr(xfs_btree_cur, keyno, xfs_btree_block))
   - 否则返回xfs_btree_block中keyno对应的xfs_btree_key 
   > xfs_btree_key_addr(xfs_btree_cur, keyno, xfs_btree_block)

** xfs_btnum_t
   #+BEGIN_SRC 
	XFS_LOOKUP_EQi, XFS_LOOKUP_LEi, XFS_LOOKUP_GEi   
   #+END_SRC

** xfs_btree_lookup(xfs_btree_cur, xfs_lookup_t, state)
   - 查找的是什么, xfs_btree_cur->bc_rec?
   - 初始化xfs_btree_ptr? 
   > xfs_btree_cur->xfs_btree_ops->init_ptr_from_cur(xfs_btree_cur, xfs_btree_ptr)
   - 开始向叶子节点遍历
   - 对于一个节点,使用2分查找 
   - 先获取节点的分支数 
   > xfs_btree_get_numrecs(xfs_btree_block) 
   - 如果节点分支数为0, 它必须是叶子节点,没有任何记录
   - 查找对应的xfs_btree_key 
   > xfs_lookup_get_search_key(xfs_btree_key, level, keyno, xfs_btree_block, key)
   - 然后比较什么?? 
   > xfs_btree_cur->xfs_btree_ops->key_diff(xfs_btree_cur, xfs_btree_key)
   - 查找介绍后根据level设置子节点指针 
   > xfs_btree_ptr_addr(xfs_btree_cur, keyno, xfs_btree_block)
   > xfs_btree_check_ptr(xfs_btree_cur, xfs_btree_ptr, 0, level)
   - 设置xfs_btree_cur->bc_ptrs[level] = keyno
   - 如果参数dir不是XFS_LOOKUP_LE?? 而且diff < 0,需要向前移动指针 
   - 直接增加keyno, 也就是分支指针, 如果查找XFS_LOOKUP_EQ, 反正找不到,所以keyno没有意义也可以接受
   > xfs_btree_get_sibling(xfs_btree_cur, xfs_btree_block, xfs_btree_ptr, XFS_BB_RIGHTSIB)
   - 如果dir是XFS_LOOKUP_GE, 既然找不到,也需要指向有意义的节点 
   - 如果keyno超过分指数,需要指向下一个节点
   > xfs_btree_increment(xfs_btree_cur, 0, i)
   - 最后根据keyno设置查找结果

** xfs_btree_updkey(xfs_btree_cur, xfs_btree_key, leven)
   - 更新xfs_btree_key路径上的节点的xfs_btree_key? 
   - 设置为参数xfs_btree_key
   - 从level=1向上, 直到xfs_btree_cur->bc_nlevels 
   - 但是只有子分支是第一个子节点时,才继续回朔
   - 找到level对应的xfs_buf, 也就是父节点
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   - 节点中针对下层的分支指针是xfs_btree_cur->bc_ptrs[level] 
   - 就直接修改这个子分支的xfs_btree_key 
   > xfs_btree_key_addr(xfs_btree_cur, xfs_btree_ptr, xfs_btree_block)
   - 从参数复制数据
   > xfs_btree_copy_keys(xfs_btree_cur, xfs_btree_key, xfs_btree_key, 1)
   > xfs_btree_log_keys(xfs_btree_cur, xfs_buf, xfs_btree_ptr, xfs_btree_ptr)
   - 这里更新节点的xfs_btree_key, 只能在父节点里更新

** xfs_btree_update(xfs_btree_cur, xfs_btree_cur)
   - 更新xfs_btree_cur查找的结果
   - 获取叶子节点  
   > xfs_btree_get_block(xfs_btree_cur, 0, xfs_buf)
   - 根据xfs_btree_cur->bc_ptrs[0], 找到对应的xfs_btree_rec 
   > xfs_btree_rec_addr(xfs_btree_cur, ptr, xfs_btree_block)
   - 复制参数 
   > xfs_btree_copy_recs(xfs_btree_cur, xfs_btree_rec, xfs_btree_cur, 1)
   > xfs_btree_log_recs(xfs_btree_cur, xfs_buf, ptr, ptr)
   - 如果这个节点是最后一个, 需要更新什么?? 
   > xfs_btree_cur->xfs_btree_ops->update_lastrec(xfs_btree_cur, xfs_btree_block, xfs_btree_rec, ptr, LASTREC_UPDATE)
   - 如果上面分支指针是1, 这个叶子节点的key需要更新 
   - 首先构造一个xfs_btree_key
   > xfs_btree_cur->xfs_btree_ops->init_key_from_rec(xfs_btree_key, xfs_btree_rec)
   - 更新到父节点中
   > xfs_btree_updkey(xfs_btree_cur, xfs_btree_key, 1)

** xfs_btree_lshift(xfs_btree_cur, level, state)
   - 如果更新根结点,而且根结点在xfs_ifork中,不允许修改??
   - 找到level层的节点 xfs_buf/xfs_btree_block
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   - 获取左边的叶子节点 
   > xfs_btree_get_sibling(xfs_btree, xfs_btree_block, xfs_btree_ptr, XFS_BB_LEFTSIB)
   - 如果不存在,直接返回 
   > xfs_btree_ptr_is_null(xfs_btree_cur, xfs_btree_ptr)
   - 移动的子分支是第一个分支, 如果当前路径在使用这个分支,不再移动
   - 因为太复杂???
   - xfs_btree_cur->bc_ptrs[level] <= 1
   - 获取左边的叶子节点xfs_buf, xfs_btree_block 
   > xfs_btree_read_buf_block(xfs_btree_cur, xfs_btree_ptr, level, 0, xfs_btree_block, xfs_buf)
   - 检查左边的节点是否满了?? 
   > xfs_btree_cur->xfs_btree_ops->get_maxrecs(xfs_btree_cur, level)
   > xfs_btree_get_numrecs(xfs_btree_block)
   - 要从当前的节点,向左边的兄弟节点中移动一个子分支
   - 如果不是叶子节点, level > 0
   - 先找到xfs_btree_key/xfs_btree_ptr的位置
   > xfs_btree_key_addr(xfs_btree_cur, lrecs, left)
   > xfs_btree_key_addr(xfs_btree_cur, 1, right)
   > xfs_btree_ptr_addr(xfs_btree_cur, lrecs, left)
   > xfs_btree_ptr_addr(xfs_btree_cur, 1, left)
   - 复制xfs_btree_key/xfs_btree_ptr 
   > xfs_btree_copy_keys(xfs_btree_cur, xfs_btree_key, xfs_btree_key, 1)
   > xfs_btree_copy_ptrs(xfs_btree_cur, xfs_btree_ptrs, xfs_btree_ptrs, 1) 
   - 然后log左边的节点??
   > xfs_btree_log_keys(xfs_btree_cur, left, lrecs, lrecs)
   > xfs_btree_log_ptrs(xfs_btree_cur, left, lrecs, lrecs)
   - 如果是叶子节点, level ==0
   - 找到xfs_btree_rec位置 
   > xfs_btree_rec_addr(xfs_btree_cur, lrecs, left)
   > xfs_btree_rec_addr(xfs_btree_cur, 1, right)
   > xfs_btree_copy_recs(xfs_btree_cur, l, r, 1)
   - 然后log左边的节点
   > xfs_btree_log_recs(xfs_btree_cur, xfs_buf, lrecs, lrecs)
   - 最后设置2个xfs_btree_block->numrecs
   > xfs_btree_set_numrecs(left, lrecs)
   > xfs_btree_log_block(xfs_btree_cur, xfs_buf, XFS_BB_NUMRECS)
   - 然后是右边节点 
   > xfs_btree_set_numrecs(right, rrecs)
   > xfs_btree_log_block(xfs_btree_cur, xfs_buf, XFS_BB_NUMRECS)
   - 然后删除右边节点的第一个分支
   - 如果不是叶子节点, level >0 
   - 从第2个key/ptr开始移动,向左移动
   > xfs_btree_shift_keys(xfs_btree_cur, xfs_btree_key_addr(xfs_btree_cur, 2, right), -1, rrecs)
   > xfs_btree_shift_ptrs(xfs_btree_cur, xfs_btree_ptr_addr(xfs_btree_cur, 2, right), -1, rrecs)
   - 然后log右边的节点, 把整个key/ptr都log下来
   - 为何不和上面一块, 把整个节点都log下来??
   > xfs_btree_log_keys(xfs_btree_cur, xfs_buf, 1, rrecs)
   > xfs_btree_log_ptrs(xfs_btree_cur, xfs_buf, 1, rrecs)
   - 如果是叶子节点, level=0
   > xfs_btree_shift_recs(xfs_btree_cur, xfs_btree_rec_addr(xfs_btree_cur, 2, right), -1, rrecs)
   > xfs_btree_log_recs(xfs_btree_cur, xfs_buf, 1, rrecs)
   - 然后更新right节点的父节点的xfs_btree_key 
   > xfs_btree_cur->xfs_btree_ops->init_key_from_rec(xfs_btree_key, xfs_btree_rec_addr(xfs_btree_cur, 1, right))
   > xfs_btree_updkey(xfs_btree_cur, xfs_btree_key, level+1)
   - 同样修改路径的指针, 只需要修改当前移动的level的子分支 
   - xfs_btree_cur->bc_ptrs[level] --

** xfs_btree_rshift(xfs_btree_cur, level, state)
   - 首先判断根结点, 如果在xfs_ifork中不做修改?? 
   - 但是对于其他的btree就能修改?? 也只有一个根结点??
   - 获取2个节点, xfs_buf/xfs_btree_block 
   - left就是xfs_btree_cur中level指向的
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   - 然后获取右边兄弟指针
   > xfs_btree_get_sibling(xfs_btree_cur, xfs_btree_block, xfs_btree_ptr, XFS_BB_RIGHTSIB)
   - 如果不存在,直接返回 
   > xfs_btree_ptr_is_null(xfs_btree_cur, xfs_btree_ptr)
   - 检查需要移动的子节点,也就是最后一个子分支,是否在路径中正常使用  xfs_btree_block->bc_ptrs[level]
   > xfs_btree_get_numrecs(xfs_btree_block)
   - 如果是，不再移动,太复杂!!
   - 否则获取对应的xfs_buf/xfs_btree_block 
   - 下面的参数level没有使用!!
   > xfs_btree_read_buf_block(xfs_btree_cur, xfs_btree_ptr, level, 0, xfs_buf, xfs_btree_block)
   - 检查right是否满了 
   > xfs_btree_cur->xfs_btree_ops->get_maxrecs(xfs_btree_cur, level)
   - 如果不是叶子节点, level >0
   - 移动对应的xfs_btree_key/xfs_btree_ptr
   - 找到对应的位置 
   > xfs_btree_key_addr(..)
   > xfs_btree_ptr_addr(..)
   - 需要先从right节点中空出来位置 
   > xfs_btree_shift_keys(xfs_btree_cur, xfs_buf, 1, rrecs)
   > xfs_btree_shift_ptrs(xfs_btree_cur, xfs_buf, 1, rrecs)
   > xfs_btree_copy_keys(..)
   > xfs_btree_copy_ptrs(..)
   - 然后log右边的节点
   > xfs_btree_log_keys(..)
   > xfs_btree_log_ptrs(..)
   - 如果是叶子节点, level==0 
   - 找到对应的位置 
   > xfs_btree_rec_addr(..)
   - right节点准备 
   > xfs_btree_shift_recs(..)
   > xfs_btree_copy_recs(..)
   > xfs_btree_log_recs(..)
   - 最有左边节点,只需要修改xfs_btree_block->numrecs 
   > xfs_btree_set_numrecs(left, --lrecs)
   > xfs_btree_log_block(xfs_btree_cur, xfs_buf, XFS_BB_NUMRECS)
   - 使用临时的xfs_btree_cur? 修改右边节点的父节点的xfs_btree_key?
   > xfs_btree_dup_cursor(xfs_btree_cur, xfs_btree_cur)
   - 原来的xfs_btree_cur指针不需要任何移动
   - 如果这里移动了,需要完全复原,还得需要一个临时变量保存
   - 所以不如直接使用一个临时的xfs_btree_cur
   - 首先移动指针?? 
   > xfs_btee_increment(xfs_btree_cur, level, i)
   > xfs_btree_updkey(xfs_btree_cur, xfs_btree_key, level+1)
   
** xfs_btree_split(xfs_btree_cur, level, xfs_btree_ptr ptr, xfs_btree_key key, xfs_btree_cur, state)
   - 把xfs_btree_cur中level对应的节点分裂开??  
   - 获取xfs_buf/xfs_btree_block 
   > xfs_btree_get_block(xfs_btree_cur, level, xfs_buf)
   > xfs_btree_check_block(xfs_btree_cur, xfs_btree_block, level, xfs_buf)
   - 获取节点磁盘位置,为何还是用xfs_btree_ptr
   > xfs_btree_buf_to_ptr(xfs_btree_cur, xfs_buf, xfs_btre_ptr)
   - 分配新的节点,使用上面的地址做提示信息?? 
   > xfs_btree_cur->xfs_btree_ops->alloc_block(xfs_btree_cur, xfs_btree_ptr, xfs_btree_ptr rptr, 1, stat)
   - 获取对应的xfs_btree_block 
   > xfs_btree_get_buf_block(xfs_btree_cur, xfs_btree_ptr, 0, xfs_btree_block, xfs_buf)
   - 初始化新的xfs_btree_block, 放到原来的xfs_btree_block的后面 
   > xfs_btree_init_block_cur(xfs_btree_cur, xfs_buf, xfs_btree_get_level(xfs_btree_block), 0)
   - 移动xfs_btree_key/xfs_btree_ptr, 或者xfs_btree_rec
   > xfs_btree_get_numrecs(xfs_btree_block)
   - 如果level >0 
   - 复制一半的xfs_btree_key/xfs_btree_ptr 
   > xfs_btree_key_addr(xfs_btree_cur, src_idx, xfs_btree_block)
   > xfs_btree_ptr_addr(..)
   > xfs_btree_copy_keys(..)
   > xfs_btree_copy_ptrs(..)
   - log右边的节点 
   > xfs_btree_log_keys(..)
   > xfs_btree_log_ptrs(..)
   - 这里还有记录第一个xfs_btree_key, 作为新节点的xfs_btree_key
   - 如果level ==0, 复制xfs_btree_rec数组 
   > xfs_btree_rec_addr(xfs_btree_cur, src_idx, xfs_btree_block)
   > xfs_btree_rec_addr(xfs_btree_cur, 1, xfs_btree_block)
   > xfs_btree_copy_recs(xfs_btree_cur, ..)
   > xfs_btree_log_recs(xfs_btree_cur, ..)
   - 使用回调函数构造新节点的xfs_btree_key 
   > xfs_btree_cur->xfs_btree_ops->init_key_from_rec(xfs_btree_key, xfs_btree_cur_addr(xfs_btree_rec, 1, xfs_btree_block))
   - 设置兄弟节点
   > xfs_btree_get_sibling(xfs_btee_cur, xfs_btree_block, xfs_btree_ptr, XFS_BB_RIGHTSIB)
   - 设置原来节点的右兄弟节点为新的
   > xfs_btree_set_sibling(xfs_btree_cur, ...)
   - 设置新的节点的兄弟节点
   - 设置2个节点的numrecs, 并且log 
   > xfs_btree_set_numrecs(xfs_btree_block, lrecs)
   - 对于新的节点,整个xfs_btree_block都log
   > xfs_btree_log_block(xfs_btree_cur, xfs_buf, XFS_BB_ALL_BITS)
   - 对于原来的节点,只有右兄弟节点和numrecs 
   > xfs_btree_log_block(xfs_btree_cur, xfs_buf, XFS_BB_NUMRECS | XFS_BB_RIGHTSIB)
   - 还有节点原来的右兄弟节点,需要设置它的做兄弟节点,指向新的节点 
   > xfs_btree_read_buf_block(xfs_btree_cur, xfs_btree_ptr, level, 0, xfs_btree_block, xfs_buf)
   > xfs_btree_set_sibling(xfs_btree_cur, xfs_btree_block, xfs_btree_ptr, XFS_BB_LEFTSIB)
   > xfs_btree_log_block(xfs_btree_cur, xfs_btree_ptr, XFS_BB_LEFTSIB)
   - 如果xfs_btree_cur中的路径使用的分支被复制到新的xfs_btree_block,修改对应的xfs_btree_cur->bc_bufs/bc_ptrs 
   > xfs_btree_setbuf(xfs_btree_cur, level, xfs_buf)
   - 如果level不是指向根, 就创建一个新的xfs_btree_cur?
   - 这里通过参数返回xfs_btree_key / xfs_btree_cur

** xfs_btree_new_iroot(xfs_btree_cur, logflags, stat)
   - btree的根结点必须在xfs_ifork中? 
   - xfs_btree_cur->bc_flags有XFS_BTREE_ROOT_IN_INODE
   - 添加一个新节点代替原有的根结点, 分支全部复制到新的节点 
   - 新节点作为原来根结点的分支, 相当于btree高度增加一层
   - 获取现在xfs_btree_cur指向的根结点 
   > xfs_btree_get_iroot(xfs_btree_cur)
   - 获取第一个分支指针?? 
   > xfs_btree_ptr_addr(xfs_btree_cur, 1, xfs_btree_block)
   - 创建新的节点 
   > xfs_btree_cur->xfs_btree_ops->alloc_block(xfs_btree_cur, xfs_btree_ptr, new_ptr, 1, stat)
   - 这里是get, 不是read??
   > xfs_btree_get_buf_block(xfs_btree_cur, new_ptr, 0, xfs_btree_block, xfs_buf)
   - 把原来的根结点复制到新的根结点上, memcpy
   - 但要重新设置xfs_btree_block->bb_u->l->bb_bklno = xfs_buf->b_bn
   - 设置xfs_btree_block->bb_level = 1, numrecs 
   - 增加xfs_btree_cur->bc_nlevels ?? 
   - 复制xfs_btree_key/xfs_btree_ptr 
   - 把原来根结点的数据给新节点
   - 然后把新节点的xfs_btree_ptr给原来根结点, 不是修改xfs_btree_key,和原来一样
   - 重新设置xfs_ifork中的根结点的长度
   > xfs_iroot_realloc(xfs_btree_cur->bc_private->b->xfs_inode, 1-xfs_btree_get_numrecs(xfs_btree_cur), xfs_btree_cur->bc_private->b->whichfork)
   - 新创建的节点怎么添加到新的根节点中??
   - 最后log新的节点
   - XFS_BB_ALL_BITS, xfs_btree_key, xfs_btree_ptr数组
     
