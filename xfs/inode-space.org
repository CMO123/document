* xfs_ialloc_btree.c

** xfs_agi 
   - 这个数据结构是磁盘中使用的,数据类型是大端的
   - 下面的磁盘位置指针都是32的,只有agbno
   #+BEGIN_SRC 
	/*
	 * Common allocation group header information
	 */
	__be32		agi_magicnum;	/* magic number == XFS_AGI_MAGIC */
	__be32		agi_versionnum;	/* header version == XFS_AGI_VERSION */
	__be32		agi_seqno;	/* sequence # starting from 0 */
	__be32		agi_length;	/* size in blocks of a.g. */
	/*
	 * Inode information
	 * Inodes are mapped by interpreting the inode number, so no
	 * mapping data is needed here.
	 */
	__be32		agi_count;	/* count of allocated inodes */
	__be32		agi_root;	/* root of inode btree */
	__be32		agi_level;	/* levels in inode btree */
	__be32		agi_freecount;	/* number of free inodes */

	__be32		agi_newino;	/* new inode just allocated */
	__be32		agi_dirino;	/* last directory inode chunk */
	/*
	 * Hash table of inodes which have been unlinked but are
	 * still being referenced.
	 */
	__be32		agi_unlinked[XFS_AGI_UNLINKED_BUCKETS];

	uuid_t		agi_uuid;	/* uuid of filesystem */
	__be32		agi_crc;	/* crc of agi sector */
	__be32		agi_pad32;
	__be64		agi_lsn;	/* last write sequence */
   
   #+END_SRC

** xfs_btree_cur
   - 这里使用xfs_btree_cur->bc_private->a 
   - btree是属于ag, 而不是inode
   - 这里的xfs_buf指向xfs_agi, 里面是inode的btree的信息
   #+BEGIN_SRC 
			struct xfs_buf	*agbp;	/* agf/agi buffer pointer */
			xfs_agnumber_t	agno;	/* ag number */
   #+END_SRC

** xfs_inobt_rec 
   #+BEGIN_SRC 
	__be32		ir_startino;	/* starting inode number */
	__be32		ir_freecount;	/* count of free inodes (set bits) */
	__be64		ir_free;	/* free inode mask */   
   #+END_SRC

** xfs_inobt_key 
   #+BEGIN_SRC 
	__be32		ir_startino;	/* starting inode number */
   #+END_SRC

** xfs_inobt_rec_incore 
   #+BEGIN_SRC 
	xfs_agino_t	ir_startino;	/* starting inode number */
	__int32_t	ir_freecount;	/* count of free inodes (set bits) */
	xfs_inofree_t	ir_free;	/* free inode mask */   
   #+END_SRC

** xfs_inobt_get_minrecs(xfs_btree_cur, level)
   - 使用xfs_mount->m_inobt_mnr[level != 0] 

** xfs_inobt_dup_cursor(xfs_btree_cur)
   - 复制一个xfs_btree_cur, 使用参数的bc_private
   > xfs_inobt_init_cursor(xfs_mount, xfs_trans, xfs_btree_cur->bc_private->a->xfs_buf, agno)

** xfs_inobt_set_root(xfs_btree_cur, xfs_btree_ptr, inc)
   - btree的根结点改变,高度也改变,更新到xfs_agi中
   - 从xfs_buf中获取xfs_agi 
   > XFS_BUF_TO_AGI(xfs_buf)
   - 设置xfs_agi->agi_root = xfs_btree_ptr->s
   - 增加xfs_agi->agi_level += inc
   - log这些修改  
   > xfs_ialloc_log_agi(xfs_btree_cur->xfs_trans, xfs_buf, XFS_AGI_ROOT | XFS_AGI_LEVEL)

** xfs_inobt_alloc_block(xfs_btree_cur, xfs_btree_ptr start, new, length, stat)
   - 创建新的结点, 分配block
   - 参数length没有使用, 和上面bmbt的类似
   - 准备xfs_alloc_arg, 设置xfs_trans, xfs_mount, minlen = maxlen = prod = 1
   - 使用参数start作为提示信息, 它是agbno, 需要和xfs_btree_cur的agno构造xfs_fsblock_t地址 
   > XFS_AGB_TO_FSB(xfs_alloc_arg->xfs_mount, xfs_btree_cur->bc_private->a->agno, start->s)
   - 使用XFS_ALLOCTYPE_NEAR_BNO方式分配
   > xfs_alloc_vextent(xfs_alloc_arg)
   - 如果成功,把地址的agbno给new->s
   > XFS_FSB_TO_AGBNO(xfs_mount, xfs_alloc_arg->fsbno)

** xfs_inobt_free_block(xfs_btree_cur, xfs_buf)
   - 释放结点的block, 获取xfs_buf的磁盘位置
   > XFS_DADDR_TO_FSB(xfs_mount, XFS_BUF_ADDR(xfs_buf))
   - 直接释放, 不想bmbt一样?? 
   > xfs_free_extent(xfs_trans, fsbno, 1)
   - 提交transaction? 
   > xfs_trans_binval(xfs_trans, xfs_buf)

** xfs_inobt_get_maxrecs(xfs_btree_cur, level)
   - 上面是获取最小的分支数,这里是最大的
   - 使用xfs_mount->m_inobt_mxr[level !=0]

** xfs_inobt_init_key_from_rec(xfs_btree_key, xfs_btree_rec)
   - xfs_btree_key使用里面的xfs_inobt_key, 不过是ag内部的inode的偏移 
   - 使用xfs_btree_rec->xfs_inobt_rec->ir_startino
   - 也即是inode簇的第一个ino 

** xfs_inobt_init_rec_from_key(xfs_btree_key, xfs_btree_rec)
   - 只设置xfs_inobt_rec->ir_startino 

** xfs_inobt_init_rec_from_cur(xfs_btree_cur, xfs_btree_rec)
   - 获取xfs_btree_cur->bc_rec->xfs_inobt_rec_incore
   - 数据类型转化为大端模式的

** xfs_inobt_init_ptr_from_cur(xfs_btree_cur, xfs_btree_ptr)
   - 获取btree的根结点磁盘位置指针
   - 先获取xfs_agi,使用xfs_agi->agi_root
   > XFS_BUF_TO_AGI(xfs_btree_cur->bc_private->a->xfs_buf)

** xfs_inobt_key_diff(xfs_btree_cur,xfs_btree_key)
   - 比较xfs_btree_key->xfs_inobt_key和xfs_btree_cur->bc_rec->xfs_inobt_rec_incore
   - 比较startino 

** xfs_inobt_verify(xfs_buf)
   - 检查xfs_btree_block, magic, uuid, blkno
   - owner和xfs_buf->xfs_perag->pag_agno
   - level < xfs_mount->m_in_maxlevels
   - numrecs <= xfs_mount->m_inobt_mxr[level]
   - 检查兄弟节点指针, 使用agbno

** xfs_inobt_read_verify(xfs_buf)
   - 检查crc校验
   > xfs_btree_sblock_verify_crc(xfs_buf)
   > xfs_inobt_verify(xfs_buf)

** xfs_inobt_write_verify(xfs_buf)
   > xfs_inobt_verify(xfs_buf)
   - 计算crc校验值 
   > xfs_btree_sblock_calc_crc(xfs_buf)

** xfs_buf_ops xfs_inobt_buf_ops
   - 给xfs_buf的IO使用

** xfs_btree_ops xfs_inobt_ops 
   - 下面构造xfs_btree_cur时使用 

** xfs_inobt_init_cursor(xfs_mount, xfs_trans, xfs_buf agbp, xfs_agnumber_t agno)
   - 构造xfs_btree_cur
   - 设置xfs_mount, xfs_trans
   - 获取xfs_agi, 设置树的高度bc_nlevels = xfs_agi->agi_level
   - 设置bc_blocklog = xfs_sb->sb_blocklog ?? 块大小?
   - 设置xfs_btree_cur->bc_private的agi的xfs_buf, agno

** xfs_inobt_maxrecs(xfs_mount, blocklen, leaf)
   - 在mount中使用,计算分支的最大值
   - 上面xfs_btree_ops也有,但使用固定的值
   - 估计那些值是使用这个函数计算的
   - blocklen减去头部大小 XFS_INOBT_BLOCK_LEN(xfs_mount)
   - 根据xfs的版本,支持crc就是56, 如果不支持就是16
   - 如果是内部节点, blocklen /= ( sizeof(xfs_inobt_key) + sizeof(xfs_inode_ptr))
   - 如果是叶子节点, blocklen /= sizeof(xfs_inobt_rec)

* xfs_ialloc.c

** xfs_alloc_arg
   - 分配xfs_dinode也像分配block一样?? 需要这么多参数??

   #+begin_src 
	struct xfs_trans *tp;		/* transaction pointer */
	struct xfs_mount *mp;		/* file system mount point */
	struct xfs_buf	*agbp;		/* buffer for a.g. freelist header */
	struct xfs_perag *pag;		/* per-ag struct for this agno */
	xfs_fsblock_t	fsbno;		/* file system block number */
	xfs_agnumber_t	agno;		/* allocation group number */
	xfs_agblock_t	agbno;		/* allocation group-relative block # */
	xfs_extlen_t	minlen;		/* minimum size of extent */
	xfs_extlen_t	maxlen;		/* maximum size of extent */
	xfs_extlen_t	mod;		/* mod value for extent size */
	xfs_extlen_t	prod;		/* prod value for extent size */
	xfs_extlen_t	minleft;	/* min blocks must be left after us */
	xfs_extlen_t	total;		/* total blocks needed in xaction */
	xfs_extlen_t	alignment;	/* align answer to multiple of this */
	xfs_extlen_t	minalignslop;	/* slop for minlen+alignment calcs */
	xfs_extlen_t	len;		/* output: actual size of extent */
	xfs_alloctype_t	type;		/* allocation type XFS_ALLOCTYPE_... */
	xfs_alloctype_t	otype;		/* original allocation type */
	char		wasdel;		/* set if allocation was prev delayed */
	char		wasfromfl;	/* set if allocation is from freelist */
	char		isfl;		/* set if is freelist blocks - !acctg */
	char		userdata;	/* set if this is user data */
	xfs_fsblock_t	firstblock;	/* io first block allocated */   
   #+end_src

** xfs_ialloc_cluster_alignment(xfs_alloc_arg)
   - 获取最小分配空间??
   - 如果xfs的版本要求对齐? 
   > xfs_sb_version_hasalign(xfs_alloc_arg->xfs_mount->xfs_sb)
   - 而且xfs_alloc_arg->xfs_mount->xfs_sb->sb_inoalignment > cluster size
   > XFS_INODE_CLUSTER_SIZE(xfs_alloc_arg->xfs_mount)
   - 使用xfs_sb->sb_inoalignment, 他在xfs_dsb中,表示inode chunk的开始地址对齐的标准??
   - 否则返回1

** xfs_lookup
   - 大于小于等于??

   #+begin_src 
	XFS_LOOKUP_EQi, XFS_LOOKUP_LEi, XFS_LOOKUP_GEi   
   #+end_src

** xfs_inobt_lookup(xfs_btree_cur, xfs_agino, xfs_lookup, stat)
   - 使用xfs_btree_cur查找btree, 目标节点指向xfs_agino
   - xfs_agino是inode在ag内部的id
   - 设置xfs_btree_cur->bc_rec->xfs_inobt_rec_incore->ir_startino = xfs_agino
   - 查找btree 
   > xfs_btree_lookup(xfs_btree_cur, xfs_lookup, stat)

** xfs_inobt_rec 
   #+begin_src 
	__be32		ir_startino;	/* starting inode number */
	__be32		ir_freecount;	/* count of free inodes (set bits) */
	__be64		ir_free;	/* free inode mask */   
   #+end_src

** xfs_inobt_rec_incore
   #+begin_src 
	xfs_agino_t	ir_startino;	/* starting inode number */
	__int32_t	ir_freecount;	/* count of free inodes (set bits) */
	xfs_inofree_t	ir_free;	/* free inode mask */   
   #+end_src

   - 这是inode的btree上的叶子节点中的value
   - 上面是磁盘中的格式,使用大端数据类型
   - 下面是内存中的格式

** xfs_btree_rec 
   #+begin_src 
	xfs_bmbt_rec_t		bmbt;
	xfs_bmdr_rec_t		bmbr;	/* bmbt root block */
	xfs_alloc_rec_t		alloc;
	xfs_inobt_rec_t		inobt;   
   #+end_src
   
   - generic btree record, 也就是btree中保存的value, 包括data extent?, free extent, inode cluster..
   - 这里只会使用到xfs_inobt_rec

** xfs_inobt_update(xfs_btree_cur, xfs_inobt_rec_incore)
   - 把xfs_inobt_rec_incore的数据给xfs_btree_cur指向的xfs_btree_rec
   - 构造一个临时的xfs_btree_rec, 使用inobt保存xfs_inobt_rec_incore的数据
   - 经过大小端转化
   - 然后更新到btree中?? btree直接操作block buf?  
   > xfs_btree_update(xfs_btree_cur, xfs_btree_rec

** xfs_inobt_get_rec(xfs_btree_cur, xfs_inobt_rec_incore, stat)
   - 获取xfs_btree_cur指向的xfs_btree_rec 
   > xfs_btree_get_rec(xfs_btree_cur, xfs_btree_rec, stat)
   - 数据转化大小端,给xfs_btree_rec_incore

** xfs_check_agi_freecount(xfs_btree_cur, xfs_agi)
   - xfs_btree_cur->bc_nlevels必须是1??? 必须指向最下层的内部节点?
   - 让xfs_btree_cur指向第一个叶子节点?? 
   > xfs_inobt_lookup(xfs_btree_cur, 0, XFS_LOOKUP_GE, &i)
   - 取出对应的xfs_inobt_rec_incore
   - 然后继续遍历 
   > xfs_btree_increment(xfs_btree_cur, 0, &i)
   - 累加xfs_inobt_rec_incore->ir_freecount, 它必须和xfs_agi->agi_freecount

** xfs_ialloc_inode_init(xfs_mount, xfs_trans, list_head, xfs_agnumber_t agno, xfs_agblock_t agbno, xfs_agblock_t length, gen)
   - 分配xfs_dinode使用的空间,初始化必要的成员变量
   - 空间是(agbno, length), 对于v3的xfs, ino根据agbno而定
   - 遍历时以cluster/fsb为单位
   - 如果xfs_sb->sb_blocksize > cluster size, 遍历次数nbufs是length, 每次遍历的大小是1, 包含的xfs_dinode数量是xfs_sb->sb_inopblock
   - 否则,遍历次数nbufs是length / cluser size, 每次遍历的大小blks_per_cluster是cluster size / xfs_sb->sb_blocksize, 需要转化为fsb, 包含的inode数量是blks_per_cluster * xfs_sb->sb_inopblock
   - log the initialisation?? 
   > xfs_icreate_log(xfs_trans, agno, agbno, XFS_IALLOC_INODES(xfs_mount), xfs_sb->sb_inodesize, length, gen)
   - 遍历所有的cluster
   - 首先获取对应的xfs_buf, 没有根据ino, 而是根据参数agbno 
   > XFS_AGB_TO_DADDR(xfs_mount, agno, agbno + (j * blks_per_cluster))
   - 使用xfs_trans读回数据??
   > xfs_trans_get_buf(xfs_trans, xfs_mount->m_ddev_targp, d, xfs_mount->m_bsize * blks_per_cluster, XBF_UNMAPPED)
   - 设置xfs_buf->b_ops = xfs_inode_buf_ops
   - 清空整个空间? 
   > xfs_buf_zero(xfs_buf, 0, BBTOB(xfs_buf->b_length))
   - 遍历里面的xfs_dinode
   > xfs_make_iptr(xfs_mount, xfs_buf, i)
   - 设置di_magic / di_version / di_gen / di_next_unlinked / uuid / di_ino, 还有crc
   - 根据version, xfs_trans的处理不一样??
   > xfs_trans_inode_alloc_buf(xfs_trans, xfs_buf)
   > xfs_trans_ordered_buf(xfs_trans, xfs_buf)
   > xfs_trans_log_buf(xfs_trans, xfs_buf, 0, BBTOB(xfs_buf->b_length)-1)
   - 如果没有xfs_trans, 就把xfs_buf放到参数的list_head中??

** xfs_ialloc_ag_alloc(xfs_trans, xfs_buf, alloc)
   - 在ag中分配xfs_dinode使用的空间
   - xfs_buf什么作用? 
   - 检查系统inode是否太多?
   > XFS_IALLOC_INODE(xfs_mount)
   - xfs_mount->m_ialloc_inos + xfs_sb->sb_icount > xfs_mount->m_maxicount
   - xfs_alloc_arg->minlen / maxlen 是空间大小?  xfs_mount->m_ialloc_blks
   > XFS_IALLOC_BLOCKS(xfs_mount)
   - 开始准备xfs_alloc_arg, 去申请空间
   - 如果xfs_agi->agi_newino不是NULLAGINO, 使用他作为分配的其实地址?
   - 计算空间位置, 是否超过AG边界 xfs_agi->agi_length
   > XFS_AGINO_TO_AGBNO(xfs_alloc_arg->mount, newino) + XFS_IALLOC_BLOCKS(xfs_mount)
   - 设置xfs_alloc_arg, 表示这个空间, 为何添加偏移??
   - fsbno = XFS_AGB_TO_FSB(xfs_mount, agno, agbno)
   - xfs_alloc_arg->type = XFS_ALLOCTYPE_THIS_BNO
   - 设置xfs_alloc_arg->minalignslop, 什么对齐??
   > xfs_ialloc_cluster_alignment(xfs_alloc_arg)
   > xfs_alloc_vextent(xfs_alloc_arg)
   - xfs_alloc_arg->fsbno表示分配的结果
   - 这里会分配3次,每次对应不同的策略,依次尝试,直到成功分配
   - 然后初始化对应的buf 
   > xfs_ialloc_inode_init(xfs_alloc_arg->xfs_mount, xfs_trans, NULL, agno, xfs_alloc_arg->agbno, xfs_alloc_arg->len, randome())
   - 增加xfs_agi的agi_count, agi_freecount
   - 增加xfs_perag->pagi_freecount
   - 设置xfs_agi->agi_newino, 下次分配使用
   - 把分配的空间插入到ialloc的btree中
   - 初始化xfs_btree_cur
   > xfs_inobt_init_cursor(xfs_alloc_arg->xfs_mount, xfs_trans, xfs_buf, agno)
   - 虽然分配一个cluster, 但还是分成多个chunk
   - 每个对应xfs_inobt_rec, 遍历这些chunk
   - 查找对应的btree, 确认没有重复的 
   > xfs_btree_lookup(xfs_btree_cur, XFS_LOOKUP_EQ, i)
   > xfs_btree_insert(xfs_btree_cur, i)
   - xfs_btree_cur中的数据却使用的xfs_inobt_rec_host
   - 最后释放xfs_btree_cur 
   > xfs_btree_del_cursor(xfs_btree_cur, XFS_BTREE_NOERROR)
   - 最后创建什么log?? 
   > xfs_ialloc_log_agi(xfs_trans, xfs_buf, XFS_AGI_COUNT|XFS_AGI_FREECOUNT|XFS_AGI_NEWINO)
   - 释放xfs_sb的变量,同样需要log记录这些修改.. 
   > xfs_trans_mod_sb(xfs_trans, XFS_TRANS_SB_ICOUNT, newlen)
   > xfs_trans_mod_sb(xfs_trans, XFS_TRANS_SB_IFREE, newlen)

** xfs_ialloc_next_ag(xfs_mount) 
   - 增加xfs_mount->m_agirotor, 如果达到xfs_mount->m_maxagi变为0

** xfs_ialloc_ag_select(xfs_trans, xfs_ino_t parent, mode, okalloc)
   - 找一个xfs_perag分配xfs_dinode使用的block
   - 遍历所有的xfs_perag
   - 如果是dir文件， 使用xfs_mount->m_agirotor 
   > xfs_ialloc_next_ag(xfs_mount)
   - 否则使用parent的xfs_perag 
   > XFS_INO_TO_AGNO(xfs_mount, parent)
   - 检查xfs_perag->pagi_inodeok ==0, 什么意思, 不能给inode使用??
   > xfs_ialloc_next_ag(xfs_mount)
   - 如果xfs_perag->pagei_init ==0, 先初始化什么?? 
   > xfs_ialloc_pagi_init(xfs_mount, xfs_trans, agno)
   - 如果xfs_perag->pagi_freecount > 0, 可以使用这个xfs_perag?
   - 如果okalloc ==0, 不会分配??
   - 下面要检查这个xfs_perag的空间足够,分配block ?
   - 如果xfs_perag->pagf_init ==0, 先去分配什么?
   > xfs_alloc_pagf_init(xfs_mount, xfs_trans, agno, flags)
   - 要分配的空间是cluster大小indeed ?
   > XFS_IALLOC_BLOCKS(xfs_mount)
   - 比较xfs_perag->pagf_freeblks > indeed, xfs_perag->pagf_longest > indeed

** xfs_ialloc_next_rec(xfs_btree_cur, xfs_inobt_rec_incore, done, left)
   - 移动xfs_btree_cur, 如果left>0, 减小,否则增加 
   > xfs_btree_decrement(xfs_btree_cur, 0, i)
   > xfs_btree_increment(xfs_btree_cur, 0, i)
   - 然后把btree中的记录放到参数中 
   > xfs_inobt_get_rec(xfs_btree_cur, xfs_inobt_rec_incore, i)

** xfs_ialloc_get_rec(xfs_btree_cur, xfs_agino_t, xfs_inobt_rec_incore, done)
   - 在btree中查找agino对应的xfs_inobt_rec_incore 
   > xfs_inobt_lookup(xfs_btree_cur, agino, XFS_LOOKUP_EQ, i)
   > xfs_inobt_get_rec(xfs_btree_cur, xfs_inobt_rec_incore, i)

** xfs_dialloc_ag(xfs_trans, xfs_buf, xfs_ino_t parent, xfs_ino_t inop)
   - 分配xfs_dinode??
   - xfs_buf中是agi, 也就是allocate group information
   - 准备xfs_btree_cur, 遍历inode btree
   - 如果parent为0, 使用xfs_agi->agi_newino开始查找
   - 验证btree中的空闲节点的个数??
   - xfs_check_agi_freecount(xfs_btree_cur, agi)
   - 如果parent所在的ag就是xfs_buf指向的ag, 查找一个parent接近的ion
   > xfs_inobt_lookup(xfs_btree_cur, pagino, XFS_LOOKUP_LE, i) 
   - 这样查找的是inode trunk
   > xfs_inobt_get_rec(xfs_btree_cur, xfs_inobt_rec_incore, i)
   - 如果xfs_inobt_rec_incore->ir_freecount > 0, 去分配inode
   - 否则需要查找2边的btree节点
   - 如果parent agino是xfs_perag->pagl_pagino, 而且xfs_perag->pagl_leftrec和xfs_perag->pagl_rightrec不是NULLAGINO
   - 这些是上次分配的记录,这次继续从那些点分配 
   > xfs_ialloc_get_rec(xfs_btree_cur, xfs_perag->pagl_leftrec, xfs_inobt_rec_incore, done)
   > xfs_ialloc_get_rec(xfs_btree_cur, xfs_perag->pagl_rightrec, xfs_inobt_rec_incore, done)
   - 否则遍历2边的xfs_btree_cur 
   > xfs_ialloc_next_rec(xfs_btree_cur, xfs_inobt_rec_incore, done, 1)
   - 在遍历时,选择近的inode trunk
   - 如果没有合适的xfs_inobt_rec_incore, 继续移动xfs_btree_cur, 直到查找10次
   - 如果上面查找结束前没有找到xfs_inobt_rec_incore, 从0开始遍历 
   > xfs_inobt_lookup(xfs_btree_cur, 0, XFS_LOOKUP_GE, i)
   - 遍历到最后,直到碰到一个xfs_inobt_rec_incore 
   > xfs_btree_increment(xfs_btree_cur, 0, i)
   - 如果找到xfs_inobt_rec_incore, 查找ir_free中空闲的一位, 标志表记
   - 写回xfs_inobt_rec_incore 
   > xfs_inobt_update(xfs_btree_cur, xfs_inobt_rec_incore)
   - 减小xfs_agi->agi_freecount, 而且记录这个修改 
   > xfs_ialloc_log_agi(xfs_trans, xfs_buf, XFS_AGI_FREECOUNT)
   - 减小xfs_perag->pagi_freecount
   - 修改xfs_trans中的计数 ?? 
   > xfs_trans_mod_sb(xfs_trans, XFS_TRANS_SB_IFREE, -1)
  
** xfs_dialloc(xfs_trans, xfs_ino_t parent, umode_t, okalloc, xfs_buf, xfs_ino_t)
   - 根据注释，这个函数回调用2次，第一次不会分配block给inode chunk
   - 如果xfs_buf不是空,直接去分配??
   - 否则xfs_buf是空, 只能去查找可用的inode chunk
   - 先查找一个xfs_agi 
   > xfs_ialloc_ag_select(xfs_trans, parent, umode_t, okalloc)
   - 检查inode使用的block达到上限 
   > xfs_mount->xfs_sb + XFS_IALLOC_INODES(xfs_mount) > xfs_mount->m_maxicount
   - 不能再分配block, okalloc = 0, noroom = 1
   - 如果上面没有找到, 为何还要重新查找?? 
   - 下面的处理应该和上面的查找类似
   > xfs_perag_get(xfs_mount, agno)
   - 如果xfs_perag->pagi_init ==0, 跳过处理下一个
   - 如果xfs_perag->pagi_freecount ==0, 而且okalloc ==0, 跳过,不允许分配block
   - 获取agi对应的xfs_buf  
   > xfs_ialloc_read_agi(xfs_mount, xfs_trans, agno, xfs_buf)
   - 如果xfs_perag->pagi_freecount >0, 使用这个agi, 调到最后分配xfs_dinode
   - 否则分配block 
   > xfs_ialloc_ag_alloc(xfs_trans, xfs_buf, ialloced)
   - 如果分配成功返回xfs_buf, 但回返ino为NULLFSINO, 还得调用一次
   - 否则释放xfs_buf, 继续查找 
   > xfs_trans_brelse(xfs_trans, xfs_buf)
   - 如果找到合适的xfs_agi, 分配xfs_dinode
   > xfs_dialloc_ag(xfs_trans, xfs_buf, parent, inop)
   - 如果要分配block, 就要调用2次,为了提交xfs_trans

** xfs_bmap_free_item 
   #+BEGIN_SRC 
	xfs_fsblock_t		xbfi_startblock;/* starting fs block number */
	xfs_extlen_t		xbfi_blockcount;/* number of blocks in extent */
	struct xfs_bmap_free_item *xbfi_next;	/* link to next entry */   
   #+END_SRC

** xfs_bmap_free 
   #+BEGIN_SRC 
	xfs_bmap_free_item_t	*xbf_first;	/* list of to-be-free extents */
	int			xbf_count;	/* count of items on list */
	int			xbf_low;	/* alloc in low mode */   
   #+END_SRC

** xfs_difree(xfs_trans, xfs_ino_t, xfs_bmap_free_t, delete, xfs_ino_t first_in)
   - 释放xfs_ino_t对应的xfs_dinode?
   - 解析agno, agino
   - 找到xfs_dinode所在的xfs_buf 
   > xfs_ialloc_read_agi(xfs_mount, xfs_trans, agno, xfs_buf)
   - 还有找到对应的xfs_inobt_rec 
   - 准备xfs_btree_cur 
   > xfs_inobt_init_cursor(xfs_mount, xfs_trans, xfs_buf, agno)
   - 检查freecount 
   > xfs_check_agi_freecount(xfs_btree_cur, xfs_agi)
   - 根据agino查找xfs_inobt_rec 
   > xfs_inobt_lookup(xfs_btree_cur, agino, XFS_LOOKUP_LE, i)
   - 获取xfs_inobt_rec_incore 
   > xfs_inobt_get_rec(xfs_btree_cur, xfs_inobt_rec_incore, i)
   - 修改ir_free / ir_freecount
   - 如果xfs_mount没有XFS_MOUNT_IKEEP, 而且xfs_inobt_rec_incore->ir_freecount达到最大值XFS_IALLOC_INODES, 可以释放这个xfs_buf?
   - 修改xfs_agi->agi_count / agi_freecount
   > xfs_ialloc_log_agi(xfs_trans, xfs_buf, XFS_AGI_COUNT | XFS_AGI_FREECOUNT)
   - 减小xfs_perag->pagi_freecount 
   > xfs_trans_mod_sb(xfs_trans, XFS_TRANS_SB_ICOUNT, -ilen)
   > xfs_trans_mod_sb(xfs_trans, XFS_TRANS_SB_IFREE, -ilen)
   - 释放xfs_inobt_rec 
   > xfs_btree_delete(xfs_btree_cur)
   - 释放xfs_buf 
   > xfs_bmap_add_free(XFS_AGB_TO_FSB(xfs_mount, agno, XFS_INO_TO_AGBNO(xfs_mount, xfs_inobt_rec->ir_startino)), XFS_IALLOC_BLOCKS(xfs_mount), xfs_bmap_free, xfs_mount)
   - 如果不需要释放,可能因为XFS_MOUNT_IKEEP, 或者xfs_inobt_rec还有使用的位 
   - 更新xfs_inobt_rec 
   > xfs_inobt_update(xfs_btree_cur, xfs_inobt_rec)
   - 更新其他计数
   - xfs_agi->agi_freecount , xfs_perag->pagi_freecount

** xfs_imap_lookup(xfs_mount, xfs_trans, xfs_agnumber_t, xfs_agino_t, xfs_agblock_t agbno, xfs_agblock_t chunk_agbno, xfs_agblock_t offset_agbno)
   - 根据xfs_agnumber_t读回xfs_agi使用的xfs_buf 
   > xfs_ialloc_read_agi(xfs_mount, xfs_trans, agno, xfs_buf)
   - 查找inode btree, 准备xfs_btree_cur 
   > xfs_inobt_init_cursor(xfs_mount, xfs_trans, xfs_buf, xfs_agnumber_t)
   - 根据xfs_agino_t查找xfs_inobt_rec_incore
   > xfs_inobt_lookup(xfs_btree_cur, xfs_agino_t, XFS_LOOKUP_LE, i)
   > xfs_inobt_get_rec(xfs_btree_cur, xfs_inobt_rec_incore, i)
   - 获取agi的xfs_buf是为了查找btree做准备?? 
   - 释放xfs_buf
   > xfs_trans_brelse(xfs_trans, xfs_buf)
   - 根据xfs_inobt_rec_incore, 获取chunk_agbno, 它是inode chunk使用的block的起始地址 
   > XFS_AGINO_TO_AGBNO(xfs_mount, xfs_inobt_rec_incore->ir_stateino)
   - 还有参数agbno对应它的偏移？？

** xfs_imap 
   #+BEGIN_SRC 
	xfs_daddr_t	im_blkno;	/* starting BB of inode chunk */
	ushort		im_len;		/* length in BBs of inode chunk */
	ushort		im_boffset;	/* inode offset in block in bytes */   
   #+END_SRC

** xfs_imap(xfs_mount, xfs_trans, xfs_ino_t, xfs_imap, flags)
   - 查找xfs_ino_t对应的xfs_dinode使用的xfs_imap
   - inode chunk和cluster什么关系??
   - 为什么不可以直接根据inode获取chunk对齐的第一个ino对应的xfs_buf? 然后根据偏移定位xfs_dinode?
   - 首先获取一个cluster包含的block个数  blks_per_cluster
   > XFS_INODE_CLUSTER_SIZE(xfs_mount) >> xfs_sb->sb_blocklog
   - 如果flags有FSX_IGET_UNTRUSTED, 什么意思?? 
   > xfs_imap_lookup(xfs_mount, xfs_trans, agno, agino, agbno, chunk_agbno, offset_agbno, flags)
   - 否则使用其他方法获取imap?
   - 如果cluster < xfs_sb->sb_blocksize
   > XFS_INODE_CLUSTER_SIZE(xfs_mount)
   - 可以直接计算出来, 一个inode cluster就是一个fsb, 即使它有多个inode chunk
   > im_blkno = XFS_AGB_TO_DADDR(xfs_mount, agno, agbno)
   > im_len = XFS_FSB_TO_BB(xfs_mount, 1)
   > im_boffset = XFS_INO_TO_OFFSET(xfs_mount, ino) << xfs_sb->sb_inodelog
   - 否则一个cluster使用多个block? 要尽量精确到某个block?
   - 如果chunk大小是对齐的? 可以定位这个chunk的位置, 它可以使用一个xfs_buf来访问?
   - offset_agbno = agbno & xfs_mount->m_inoalign_mask
   - chunk_agbno = agbno - offset_agbno
   - 否则还得查找btree 
   > xfs_imap_lookup(xfs_mount, xfs_trans, agno, agino, agbno, chunk_agbno, offset_agbno, flags)
   - 然后根据chunk的位置构造cluster地址? 一个chunk包含多个cluster? 
   - cluster_agbno = chunk_agbno + (offset_agbno / blks_per_cluster) * blks_per_cluster
   - offset = (agbno - cluster_agbno) * xfs_sb->sb_inopblock + XFS_INO_TO_OFFSET(xfs_mount, ino)
   - 偏移包括cluster内部偏移和block内部偏移
   - 然后根据cluster构造xfs_imap
   - im_blkno = XFS_AGB_TO_DADDR(xfs_mount, agno, cluster_agbno)
   - im_len = XFS_FSB_TO_BB(xfs_mount, blks_per_cluster)
   - im_boffset = offset << xfs_sb->sb_inodelog

** xfs_ialloc_compute_maxlevels(xfs_mount)
   - 先计算可能最多的xfs_inobt_rec, maxleafents
   - 根据xfs_mount->m_agino_log,m_agino_log应该根据ag的大小计算出来
   > 1<<XFS_INO_AGINO_BITS(xfs_mount) >> XFS_INODES_PER_CHUNK_LOG
   - xfs_mount->m_alloc_mnr[2]表示btree中节点最少的记录数?
   - 逐层计算所需要的最多的节点数 
   > maxblocks = maxleafents / minnoderecs
   > maxblocks = maxblocks / minnoderecs

** xfs_ialloc_log_agi(xfs_trans, xfs_buf, fields)
   - xfs_buf中是xfs_agi, 记录它特殊的成员修改
   - 包括migac,versionnum,agi_setno,agi_length, . 
   - 根据修改的域,计算返回
   > xfs_btree_offsets(fields, offsets, XFS_AGI_NUM_BITS, first, last)
   > xfs_trans_buf_set_type(xfs_trans, xfs_buf, XFS_BLFL_AGI_BUF)
   > xfs_trans_log_buf(xfs_trans, xfs_buf, first, last)

** xfs_agi 
   #+BEGIN_SRC 
	/*
	 * Common allocation group header information
	 */
	__be32		agi_magicnum;	/* magic number == XFS_AGI_MAGIC */
	__be32		agi_versionnum;	/* header version == XFS_AGI_VERSION */
	__be32		agi_seqno;	/* sequence # starting from 0 */
	__be32		agi_length;	/* size in blocks of a.g. */
	/*
	 * Inode information
	 * Inodes are mapped by interpreting the inode number, so no
	 * mapping data is needed here.
	 */
	__be32		agi_count;	/* count of allocated inodes */
	__be32		agi_root;	/* root of inode btree */
	__be32		agi_level;	/* levels in inode btree */
	__be32		agi_freecount;	/* number of free inodes */

	__be32		agi_newino;	/* new inode just allocated */
	__be32		agi_dirino;	/* last directory inode chunk */
	/*
	 * Hash table of inodes which have been unlinked but are
	 * still being referenced.
	 */
	__be32		agi_unlinked[XFS_AGI_UNLINKED_BUCKETS];

	uuid_t		agi_uuid;	/* uuid of filesystem */
	__be32		agi_crc;	/* crc of agi sector */
	__be32		agi_pad32;
	__be64		agi_lsn;	/* last write sequence */

	/* structure must be padded to 64 bit alignment */   
   #+END_SRC

** xfs_agi_verify(xfs_buf)
   - xfs_buf中是xfs_agi, 验证数据有效性
   - 首先是version/crc/uuid
   > xfs_sb_version_hascrc(xfs_mount->xfs_sb)
   - uuid和xfs_sb->sb_uuid比较
   - 检查magic/version
   - 检查xfs_agi->agi_seqno和xfs_perag->pag_agno
   - 检查unlinked链表, 不能是0??
   > xfs_check_agi_unlinked(xfs_agi)

** xfs_agi_ready_verify(xfs_buf)
   > xfs_agi_verify(xfs_buf)

** xfs_agi_write_verify(xfs_buf)
   - 验证数据有效性
   > xfs_agi_verify(xfs_buf)
   - 如果有错误,返回EFSCORRUPTED? 
   > xfs_buf_ioerror(xfs_buf, EFSCORRUPTED)
   - 设置xfs_agi->agi_lsn = xfs_buf_log_item->xfs_lig_item->li_lsn??
   - 检查checksum 
   > xfs_update_cksum(xfs_buf->b_addr, BBTOB(xfs_buf->b_length), offsetof(xfs_agi, agi_crc)

** xfs_read_agi(xfs_mount, xfs_trans, xfs_agnumber_t, xfs_buf)
   - 读取xfs_agnumber_t对应的ag的xfs_agi 
   > xfs_trans_read_buf(xfs_mount, xfs_trans, xfs_mount->m_ddev_targp, XFS_AG_DADDR(xfs_mount, agno, XFS_AGI_DADDR(xfs_mount)), XFS_FSS_TO_BB(xfs_mount, 1), 0, xfs_buf, xfs_agi_buf_ops)
   - 设置XFS_AGI_REF? 
   > xfs_buf_set_ref(xfs_buf, XFS_AGI_REF)

** xfs_ialloc_read_agi(xfs_mount, xfs_trans, xfs_agnumber_t, xfs_buf)
   - 读取数据
   > xfs_read_agi(xfs_mount, xfs_trans, agno, xfs_buf)
   - 获取xfs_perag? 
   > xfs_perag_get(xfs_mount, agno)
   - 如果xfs_perag->pagi_init ==0, 初始化它?
   - 设置xfs_perag->pagi_freecount = xfs_agi->agi_freecount
   - apgi_count = xfs_agi->agi_count, pagi_init = 1, 算是一段缓存
   
** xfs_ialloc_pagi_init(xfs_mount, xfs_trans, xfs_agnumber_t)
   - 初始化xfs_agnumber_t对应的xfs_perag 
   > xfs_ialloc_read_agi(xfs_mount, xfs_trans, xfs_agnumber_t, xfs_buf)
   > xfs_trans_brelse(xfs_trans, xfs_buf)

* xfs_icache.c 

** xfs_inode_alloc 
   - 分配xfs_inode, 只制定ino 
   - 初始化inode
   > xfs_init_always(xfs_mount->super_block, inode)
   - 清空xfs_ifork, xfs_icdinode

** xfs_inode_free_callback(rcu_head)
   - 释放xfs_inode的内存 

** xfs_inode_free(xfs_inode)
   - 对于普通文件, reg/dir/link, 释放xfs_ifork 
   > xfs_idestroy_fork(xfs_inode, XFS_DATA_FORK)
   - 然后是attribute fork 
   > xfs_idestroy_fork(xfs_inode, XFS_ATTR_FORK)
   - 如果还关联xfs_inode_log_item, 释放它
   > xfs_inode_item_destroy(xfs_inode)
   - 设置xfs_inode->i_flags的XFS_IRECLAIM, 重置ino 
   > call_rcu(xfs_inode->inode->i_rcu, xfs_inode_free_callback)

** xfs_iget_cache_hit(xfs_perag, xfs_inode, xfs_ino, flags, lock_flags)
   - 验证cache的xfs_inode??
   - 放置rcu锁的漏洞??
   - 首先检查xfs_ino和xfs_inode->i_ino
   - 检查xfs_inode->i_flags的XFS_INEW|XFS_IRECLAIM, 这个inode已经释放
   - 如果xfs_inode->xfs_icdinode->di_mode是0, 而且参数flags没有XFS_IGET_CREATE?
   - 说明inode在释放中?? unlink ?
   - 如果xfs_inode->i_flags包含XFS_IRECLAIMABLE, 哪里设置??
   - 这时inode已经销毁, 设置xfs_inode->i_flags的XFS_IRECLAIM ??
   - 重新初始化inode 
   > inode_init_always(xfs_mount->super_block, inode)
   - 去掉xfs_inode->i_flags的XFS_IRECLAIM_RESET_FLAGS, 设置XFS_INEW
   - 从radix上释放关系?? 
   > __xfs_inode_clear_reclaim_tag(xfs_mount, xfs_perag, xfs_inode)
   - 设置xfs_inode->inode->i_state的I_NEW??
   - 如果没有XFS_IRECLAIMABLE标志, 说明什么?
   - 可以直接获取inode ?? 
   > igrab(inode)

** xfs_iget_cache_miss(xfs_mount, xfs_perag, xfs_trans, xfs_ino, xfs_inode, flags, lock_flags)
   - 先分配xfs_inode
   > xfs_inode_alloc(xfs_mount, ino)
   - 读取磁盘的xfs_dinode?
   > xfs_iread(xfs_mount, xfs_trans, xfs_inode, flags)
   - 如果xfs_inode->xfs_icdinode->di_mode是0, 而且flags没有XFS_IGET_CREATE, 返回ENOENT
   - 设置xfs_inode->flags的XFS_INEW 
   > xfs_iflags_set(xfs_inode, iflags)
   - 把它放到xfs_perag的radix中
   > radix_tree_insert(xfs_perag->pag_ici_root, agino, xfs_inode)

** xfs_iget(xfs_mount, xfs_trans, xfs_ino_t, flags, lock_flags, xfs_inode)
   - 根据xfs_ino_t查找xfs_inode
   - 现在cache中查找,它是radix树? 如果找到需要初始化inode
   - 如果cache中没有,去磁盘中查找
   - 先查找radix
   > xfs_perag_get(xfs_mount, XFS_INO_TO_AGNO(xfs_mount, ino))
   > radix_tree_lookup(xfs_perag->pag_ici_root, agino)
   - 如果找到,初始化inode
   > xfs_iget_cache_hit(xfs_perag, xfs_inode, ino, flags, lock_flags)
   - 否则读取磁盘的数据
   > xfs_iget_cache_miss(xfs_mount, xfs_perag, xfs_trans, ino, xfs_inode, flags, lock_flags)
   - 如果文件已经存在,而且inode是刚创建的, 设置inode
   - xfs_iflags_test(xfs_inode, XFS_INEW)
   - 有XFS_INEW标志,而且xfs_inode->xfs_icdinode->di_mode !=0
   > xfs_setup_inode(xfs_inode)
   - 这个文件肯定不是刚创建的!!

** xfs_inode_ag_walk_grab(xfs_inode)
   - inode查找磁盘时是批量处理的,减小radix查找和锁的次数?
   - 首先检查xfs_inode
   - xfs_inode->i_ino不能是0
   - xfs_inode->i_flags不能包含XFS_INEW|XFS_IRECLAIMABLE|XFS_IRECLAIM? 
   > __xfs_iflags_test(xfs_inode, XFS_INEW|XFS_IRECLAIMABLE|XFS_IRECLAIM)
   - 增加inode计数 ?? 
   > igrab(inode)
   
** xfs_inode_ag_walk(xfs_mount, xfs_perag, execute, flags, args, tag)
   - 遍历所有的inode? 执行execute函数
   > execute(xfs_inode, xfs_perag, flag, args)
   - tag用来过滤radix中的xfs_inode 
   - 遍历xsf_perag->pag_ici_root中的xfs_inode 
   > radix_tree_gang_lookup_tag(xfs_perag->pag_ici_root, xfs_inode, first_index, XFS_LOOKUP_BATCH, tag)
   - 每次处理32个, 处理之前增加inode计数
   > xfs_inode_ag_walk_grab(xfs_inode)
   - 然后执行回调函数
   > execute(xfs_inode, xfs_perag, flags, args)

** xfs_queue_eofblocks(xfs_mount)
   - xfs_mount->m_perag_tree是什么?
   - 如果它有标志XFS_ICI_EOFBLOCKS_TAG, 启动xfs_mount->m_eofblocks_work任务 
   > radix_tree_tagged(xfs_mount->m_perag_tree, XFS_ICI_EOFBLOCKS_TAG)
   > queue_delayed_work(xfs_mount->m_eofblocks_workqueue, xfs_mount->m_eofblocks_work, xfs_eofb_secs)
   - xfs_eofb_secs单位是秒
   - sec = 1000 msec = 1000*1000 usec

** xfs_inode_ag_iterator(xfs_mount, execute, args, flags)
   - 遍历xfs_mount的所有xfs_perag
   - 遍历xfs_perag的所有xfs_inode 
   > xfs_perag_get(xfs_mount, ag) 
   - tag是-1, flags是和args一块的
   > xfs_inode_ag_walk(xfs_mount, xfs_perag, execute, flags, args, -1)

** xfs_inode_ag_iterator_tag(xfs_mount, execute, flags, args, tag) 
   - 这里传递了tag
   > xfs_inode_ag_walk(xfs_mount, xfs_perag, execute, flags, args, tag)

** xfs_reclaim_work_queue(xfs_mount)
   - 如果系统中存在xfs_perag, 它需要回收inode?
   - 启动对应的xfs_mount->m_reclaim_work? 
   > radix_tree_tagged(xfs_mount->m_perag_tree, XFS_ICI_RECLAIM_TAG)
   > queue_delayed_work(xfs_mount->m_reclaim_workqueue, xfs_mount->m_reclaim_work, xfs_syncd_centisecs)

** xfs_reclaim_worker(work_struct)
   - 回收xfs_inode cache? 
   - work_struct是xfs_mount->m_reclaim_work
   > xfs_reclaim_inodes(xfs_mount, SYNC_TRYLOCK)
   - 然后检查是否还需要运行work_struct 
   > xfs_reclaim_work_queue(xfs_mount)

** __xfs_inode_set_reclaim_tag(xfs_perag, xfs_inode)
   - 设置xfs_perag->pag_ici_root中xfs_inode对应的标志XFS_ICI_RECLAIM_TAG
   > radix_tree_tag_set(xfs_perag->pag_ici_root, XFS_INO_TO_AGNO(xfs_mount, xfs_inode->i_ino), XFS_ICI_RECLAIM_TAG)
   - 如果xfs_perag->pag_ici_reclaimable ==0? 设置对应的xfs_mount的标志 
   - 使用一样的标志??
   > radix_tree_tag_set(xfs_mount->m_perag_tree, XFS_INO_TO_AGNO(xfs_mount, xfs_inode->i_ino), XFS_ICI_RECLAIM_TAG)
   - 启动work_struct 
   > xfs_reclaim_work_queue(xfs_mount)
   - 最后增加xfs_perag->pag_ici_reclaimable ?? 

** xfs_inode_set_reclaim_tag(xfs_inode)
   - 设置xfs_inode->i_flags的XFS_IRECLAIMABLE
   > __xfs_inode_set_reclaim_tag(xfs_perag, xfs_inode)
   > __xfs_iflags_set(xfs_inode, XFS_IRECLAIMABLE)

** __xfs_inode_clear_reclaim(xfs_perag, xfs_inode)
   - 操作的是xfs_perag
   - 减小xfs_perag->pag_ici_reclaimable
   - 如果减为0, 修改对应radix的标志
   > radix_tree_tag_clear(xfs_inode->xfs_mount->m_perag_tree, XFS_INO_TO_AGNO(xfs_inode->xfs_mount, xfs_inode->i_ino), XFS_ICI_RECLAIM_TAG)
   - 这个和上面是对应的,操作inode时使用 

** __xfs_inode_clear_reclaim_tag(xfs_mount, xfs_perag, xfs_inode)
   - 先修改xfs_perag的radix树 
   > radix_tree_tag_clear(xfs_perag->pag_ici_root, XFS_INO_TO_AGINO(xfs_mount, xfs_inode->i_ino), XFS_ICI_RECLAIM_TAG)
   > __xfs_inode_clear_reclaim(xfs_perag, xfs_inode)

** xfs_reclaim_inode_grab(xfs_inode, flags)
   - 这里应该是回收过程中设置的,而不是标记为可回收的reclaimable
   - 如果flags包含SYNC_TRYLOCK, 而且xfs_inode->i_flags有XFS_IFLOCK|XFS_IRECLAIM
   - 直接返回,因为锁不住??
   - 如果xfs_inode没有XFS_IRECLAIMABLE, 直接返回
   - 如果xfs_inode有XFS_IRECLAIM, 直接返回
   - 设置xfs_inode->flags的XFS_IRECLAIM 
   > __xfs_iflags_set(xfs_inode, XFS_IRECLAIM)
   - 这里没有grab操作??

** xfs_reclaim_inode(xfs_inode, xfs_perag, sync_mode)
   - 回收inode? 但inode的状态不确定? 需要检查xfs_inode的状态
   - 首先锁住inode 
   > xfs_ilock(xfs_inode, XFS_ILOCK_EXCL)
   - 检查flush lock 
   > xfs_iflock_nowait(xfs_inode)
   - 如果需要等待锁,而sync_mode没有SYNC_WAIT, 直接返回
   - 否则等待完成 
   > xfs_iflock(xfs_inode)
   - 如果inode是bad? 回收inode ?
   > is_bad_inode(xfs_inode->inode)
   - 如果inode在ail中? 需要等待log操作?
   > xfs_ipincount(xfs_inode)
   - 如果sync_mode没有SYNC_WAIT，直接返回
   - 否则等待pincount 
   > xfs_iunpin_wait(xfs_inode)
   - 如果inode是无效的? 已经删除? 直接去回收
   > xfs_iflags_test(xfs_inode, XFS_ISTALE)
   - 检查xfs_inode是否是dirty/clean, 表示有metadata需要写回
   > xfs_inode_clean(xfs_inode)
   - 如果是clean, 直接去回收
   - 然后开始flush, 如果sync_mode没有SYNC_WAIT，直接返回 
   > xfs_iflush(xfs_inode, xfs_buf)
   - 写回xfs_buf? 
   > xfs_bwrite(xfs_buf)
   - 通过flush lock等待写完?? 
   > xfs_iflock(xfs_inode)
   - 开始reclaim操作
   - 释放flush lock, XFS_ILOCK_EXCL锁? 是什么保证xfs_inode不会再被使用? XFS_ISTALE?
   - 释放radix索引 
   > radix_tree_delete(xfs_perag->pag_ici_root, XFS_INO_TO_AGINO(xfs_mount, xfs_inode->i_ino))
   - 去掉claim标志? 
   > __xfs_inode_clear_reclaim(xfs_perag, xfs_inode)
   - 再此锁住inode? 操作quota 
   > xfs_ilock(xfs_inode, XFS_ILOCK_EXCL)
   > xfs_qm_dqdetch(xfs_inode)
   - 最后释放xfs_inode 
   > xfs_inode_free(xfs_inode)

** xfs_reclaim_inodes_ag(xfs_mount, flags, nr_to_scan)
   - 遍历xfs_mount的所有xfs_perag, 还有所有的xfs_inode
   - 回收带有XFS_ICI_RECLAIM_TAG标志的inode
   > xfs_perag_get_tag(xfs_mount, ag, XFS_ICI_RECLAIM_TAG)
   > radix_tree_gang_lookup_tag(xfs_perag->pag_ici_root, xfs_inode, first_index, XFS_LOOKUP_BATCH, XFS_ICI_RECLAIM_TAG)
   - 检查xfs_inode的标志
   > xfs_reclaim_inode_grab(xfs_inode, flags)
   - 回收 
   > xfs_reclaim_inode(xfs_inode, xfs_perag, flags)
   - 上面遍历过程中,如果flags包含SYNC_WAIT,而且处理的xfs_inode不满足nr_to_scan,可能回遍历2遍
   - 第一遍如果锁不住xfs_perag不会等待, 第2遍回等待锁

** xfs_reclaim_inodes(xfs_mount, mode)
   > xfs_reclaim_inodes_ag(xfs_mount, mode, INT_MAX)

** xfs_reclaim_inodes_nr(xfs_mount, nr_to_scan)
   - 同步释放? 
   - 为何启动回收工作?
   > xfs_reclaim_work_queue(xfs_mount)
   - 写回log ? 
   > xfs_ail_push_all(xfs_mount->xfs_ail)
   - 回收xfs_inode 
   > xfs_reclaim_inodes_ag(xfs_mount, SYNC_TRYLOCK|SYNC_WAIT, nr_to_scan)

** xfs_reclaim_inodes_count(xfs_mount)
   - 累计可回收的xfs_inode的个数?
   - 遍历XFS_ICI_RECLAIM_TAG的xfs_perag 
   > xfs_perag_get_tag(xfs_mount, xfs_perag, XFS_ICI_RECLAIM_TAG)
   - 累加xfs_perag->pag_ici_reclaimable

** xfs_eofblocks
   - 和pre-allocate有关?

   #+BEGIN_SRC 
	__u32		eof_version;
	__u32		eof_flags;
	uid_t		eof_uid;
	gid_t		eof_gid;
	prid_t		eof_prid;
	__u32		pad32;
	__u64		eof_min_file_size;
	__u64		pad64[12];   
   #+END_SRC

** xfs_inode_match_id(xfs_inode, xfs_eofblocks)
   - 使用xfs_eofblocks过滤xfs_inode
   - 使用uid/gid/eof_prid信息过滤

** xfs_inode_free_eofblocks(xfs_inode, xfs_perag, flags, args)
   - args就是xfs_eofblocks
   - 先检查什么? 
   > xfs_can_free_eofblocks(xfs_inode, false)
   - 如果address_space_mapping中有PAGECACHE_TAG_DIRTY, 写回数据需要等待
   - 如果flags没有SYNC_WAIT, 直接返回
   - 使用args过滤xfs_inode，如果不满足之家返回
   > xfs_inode_match_id(xfs_inode, xfs_eofblocks)
   - 如果xfs_eofblocks->eof_flags包含XFS_EOF_FLAGS_MINFILESIZE, 而且文件大小太小,直接返回 
   > XFS_ISIZE(xfs_inode) < xfs_eofblocks->eof_min_file_size
   - 文件大小是inode->i_size
   - 回收eof blocks 
   > xfs_free_eofblocks(xfs_mount, xfs_inode, true)

** xfs_icache_free_eofblocks(xfs_mount, xfs_eofblocks)
   - 遍历xfs_inode, 回收什么? 
   - 如果xfs_eofblocks->eof_flags包含XFS_EOF_FLAGS_SYNC, 遍历使用SYNC_WAIT方式 
   > xfs_inode_ag_iterator_tag(xfs_mount, xfs_inode_free_eofblocks, flags, xfs_eofblocks, XFS_ICI_EOFBLOCKS_TAG)

** xfs_inode_set_eofblocks_tag(xfs_inode)
   - 设置XFS_ICI_EOFBLOCKS_TAG, 在pre-allocation中设置 
   - 获取xfs_perag 
   > xfs_perag_get(xfs_mount, XFS_INO_TO_AGNO(xfs_mount, xfs_inode->i_ino))
   - 设置xfs_inode对应的标志 
   > radix_tree_tag_set(xfs_perag->pag_ici_root, XFS_INO_TO_AGINO(xfs_mount, xfs_inode->i_ino), XFS_ICI_EOFBLOCKS_TAG)
   - 如果原来xfs_perag在xfs_mount的radix树中没有设置, 这里同样要设置 
   > radix_tree_tag_set(xfs_mount->m_perag_tree, XFS_INO_TO_AGNO(xfs_mount, xfs_inode->i_ino), XFS_ICI_EOFBLOCKS_TAG)
   
** xfs_inode_clear_eofblocks_tag(xfs_inode)
   - 先去掉xfs_inode对应的标志  
   > radix_tree_tag_clear(xfs_perag->pag_ici_root, XFS_INO_TO_AGINO(xfs_mount, xfs_inode->i_ino), XFS_ICI_EOFBLOCKS_TAG)
   - 如果xfs_perag->pag_ici_root中没有xfs_inode使用这个标志, 去掉xfs_perag对应的标志  
   > radix_tree_tag_clear(xfs_mount->m_perag_tree, XFS_INO_TO_AGNO(xfs_mount, xfs_inode->i_ino), XFS_ICI_EOFBLOCKS_TAG)
   - 这里只是修改标志, 不想上面reclaim那么复杂!!

* xfs_icreate_item.c

** xfs_icreate_log 
   - 创建inode使用的log数据
   - 这里的数据类型是大端的,磁盘中使用的
   #+BEGIN_SRC 
	__uint16_t	icl_type;	/* type of log format structure */
	__uint16_t	icl_size;	/* size of log format structure */
	__be32		icl_ag;		/* ag being allocated in */
	__be32		icl_agbno;	/* start block of inode range */
	__be32		icl_count;	/* number of inodes to initialise */
	__be32		icl_isize;	/* size of inodes */
	__be32		icl_length;	/* length of extent to initialise */
	__be32		icl_gen;	/* inode generation number to use */   
   #+END_SRC

** xfs_icreate_item 
   #+BEGIN_SRC 
 	struct xfs_log_item	ic_item;
	struct xfs_icreate_log	ic_format;
   #+END_SRC

** ICR_ITEM(xfs_log_item)
   - ICR = inode create ? 参数xfs_log_item是xfs_icreate_log内嵌成员 

** xfs_icreate_item_size(xfs_log_item, nvecs, nbytes)
   - log需要的iovec数组长度, 只需要多1个?  nvecs += 1
   - 长度增加sizeof(xfs_icreate_log)
   
** xfs_icreate_item_format(xfs_log_item, xfs_log_iovec)
   - 把xfs_icreate_item的log数据放到xfs_log_iovec中
   - (i_addr,i_len)就是xfs_log_item->xfs_icreate_log内存块
   - xfs_log_iovec->i_type设置为XLOG_REG_TYPE_ICREATE

** xfs_icreate_item_pin(xfs_log_item)
   - 不影响任何东西?!

** xfs_icreate_item_unpin(xfs_log_item, remove)
   - 也没什么影响 

** xfs_icreate_item_unlock(xfs_log_item)
   - 如果xfs_icreate_item->xfs_log_item->li_flags有XFS_LI_ABORTED, 可以直接释放

** xfs_icreate_item_committed(xfs_log_item, xfs_lsn_t)
   - xfs_icreate_log提交之后可以直接释放?! 这里就是直接释放内存

** xfs_icreate_item_push(xfs_log_item, list_head)
   - xfs_icreate_log不会提交到AIL?
   - 返回XFS_ITEM_SUCCESS

** xfs_icreate_item_committed(xfs_log_item, xfs_lsn_t)
   - 什么都不做

** xfs_item_ops xfs_icreate_item_ops

** xfs_icreate_log(xfs_trans, xfs_agnumber_t, xfs_agblock_t, count, inode_size, length, generation)
   - 构造xfs_icreate_item, 先初始化xfs_log_item 
   > xfs_log_item_init(xfs_trans->xfs_mount, xfs_icreate_item->xfs_log_item, XFS_LI_ICREATE, xfs_icreate_item_ops)
   - 填充xfs_icreate_item->xfs_icreate_log_item
   - 记录分配的inode的block位置(agno, agbno)
   - 放到xfs_trans中  
   > xfs_trans_add_item(xfs_trans, xfs_icreate_item->xfs_log_item)
   - 设置xfs_trans->t_flags的XFS_TRANS_DIRTY, xfs_icreate_item->xfs_log_item->lid_flags的XFS_LID_DIRTY

* xfs_inode_buf.c
** xfs_inobp_check(xfs_mount, xfs_buf)
   - xfs_buf中是xfs_dinode数组, 数组长度是xfs_mount->m_inode_cluster_size >> xfs_sb->sb_inodelog
   - 遍历xfs_buf中的xfs_dinode 
   > xfs_buf_offset(xfs_buf, i*xfs_mount->xfs_sb->sb_inodesize)
   - 如果xfs_dinode->di_next_unlinked是0报错. 不是0应该是什么?

** xfs_inode_buf_verify(xfs_buf, readahead)
   - 检查xfs_buf中的xfs_dinode的内容
   - 如果readahead ==1, 表示log recovery中操作,虽然有错误,也不会报错,可能只是分配了空间,但没有写入xfs_dinode
   - 这里计算xfs_buf的xfs_dinode的方法和上面不一样, xfs_buf的大小是一个fsb
   - 首先转化xfs_buf的大小为fsb单位,然后获取每个fsb的inode的数量
   > XFS_BB_TO_FSB(xfs_mount, xfs_buf->b_length) * xfs_mount->xfs_sb->sb_inopblock
   - 遍历xfs_buf的xfs_dinode
   > xfs_buf_offset(xfs_buf, i<<xfs_mount->xfs_sb->sb_inodelog)
   - 通过magic/version, 确认xfs_dinode是正确的
   - xfs_dinode->di_magic是XFS_DINODE_MAGIC  'IN'
   - xfs_dinode->di_version是[1,3]
   - 否则处理错误
   - 如果是readahead, 去掉xfs_buf->b_flags的XBF_DONE 
   - 否则设置ioerror, EFSCORRUPTED
   - 然后检查unlink链表??
   > xfs_inobp_check(xfs_mount, xfs_buf)
     
** xfs_inode_buf_read_verify(xfs_buf)
   > xfs_inode_buf_verify(xfs_buf, false)

** xfs_inode_buf_readahead_verify(xfs_buf)
   > xfs_inode_buf_verify(xfs_buf, true)

** xfs_inode_buf_write_verify(xfs_buf)
   > xfs_inode_buf_verify(xfs_buf)

** xfs_buf_ops xfs_inode_buf_ops
   - 构造xfs_buf的回调函数

** xfs_imap_to_bp(xfs_mount, xfs_trans, xfs_imap, xfs_dinode dipp, xfs_buf bpp, buf_flags, iget_flags)
   - 把一个inode读到内存中, 获取对应的xfs_dinode/xfs_buf指针
   - 设置buf_flags的XBF_UNMAPPED, 不需要给page建立影射, 后面找xfs_dinode时再建立
   - 使用transaction包装的函数读xfs_buf
   > xfs_trans_read_buf(xfs_mount, xfs_trans, xfs_mount->m_ddev_targp, xfs_imap->im_blkno, xfs_imap->im_len, buf_flags, xfs_buf, xfs_inode_buf_ops)
   - 上面verify的错误在这里上传
   - xfs_dinode的指针在xfs_buf上 
   > xfs_buf_offset(xfs_buf, xfs_imap->im_boffset)

** xfs_dinode_from_disk(xfs_idcinode, xfs_dinode)
   - xfs_idcinode是xfs_dinode内存中的表示形式,使用大端数据类型
   - 把xfs_dinode数据给xfs_icdinode
   - xfs_icdinode在xfs_inode中

** xfs_dinode_to_disk(xfs_dinode, xfs_idcinode)
   - 上面的逆操作

** xfs_dinode_verify(xfs_mount, xfs_inode, xfs_dinode)
   - 验证xfs_dinode数据
   - xfs_dinode->di_magic是cpu_to_be16(XFS_DINODE_MAGIC)
   - xfs_dinode->di_version >= 3, 这个域是char, 不需要大小端
   - 如果支持crc验证,计算checksum
   > xfs_sb_version_hasrcr(xfs_mount->xfs_sb)
   > xfs_verify_cksum(xfs_dinode, xfs_sb->sb_inodesize, offsetof(xfs_dinode, di_crc))
   - 比较xfs_dinode->di_ino = xfs_inode->i_ino
   - uuid比较, xfs_dinode->di_uuid

** xfs_dinode_calc_crc(xfs_mount, xfs_dinode)
   - 计算的对象是xfs_dinode->di_crc前面的数据, 结果给xfs_dinode->di_crc
   > xfs_start_cksum(xfs_dinode, xfs_mount->xfs_sb->sb_inodesize, offsetof(xfs_dinode, di_crc))

** xfs_iread(xfs_mount, xfs_trans, xfs_inode, iget_flags)
   - 把xfs_dinode读到磁盘中
   - 计算xfs_imap信息, inode的磁盘位置
   > xfs_imap(xfs_mount, xfs_trans, xfs_inode->i_ino, xfs_inode->i_imap, iget_flags)
   - 如果iget_flags包含XFS_IGET_CREATE, xfs版本有crc,而且xfs_mount->m_flags没有XFS_MOUNT_IKEEP
   - 表示inode是刚创建的??? 初始化xfs_inode->xfs_icdinode
   - 设置di_magic, di_gen = prandom_u32()
   - 查找读取对应的block, 获取xfs_dinode指针
   > xfs_imap_to_bp(xfs_mount, xfs_trans, xfs_inode->xfs_imap, xfs_dinode, xfs_buf, 0, iget_flags)
   - 验证xfs_dinode数据
   > xfs_dinode_verify(xfs_mount, xfs_inode, xfs_dinode)
   - 如果xfs_inode->di_mode !=0, 表示它已经存在
   > xfs_dinode_from_disk(xfs_inode->xfs_icdinode, xfs_dinode)
   - 获取xfs_ifork信息
   > xfs_iformat(xfs_inode, xfs_dinode)
   - 否则它是刚创建的,只初始化一部分xfs_icdinode?
   - 设置magic, version, gen, flushiter?
   - 设置xfs_buf的XFS_INO_REF, 让他在内存中缓存一段时间
   > xfs_buf_set_ref(xfs_buf, XFS_INO_REF)
   - xfs_buf读操作使用xfs_trans, 释放对应的资源, 这里没修改xfs_dinode??
   > xfs_trans_brelse(xfs_trans, xfs_buf)

