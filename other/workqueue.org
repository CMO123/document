* kernel/workqueue.c

** work_struct flags
   #+begin_src 
	WORK_STRUCT_PENDING_BIT	= 0,	/* work item is pending execution */
	WORK_STRUCT_DELAYED_BIT	= 1,	/* work item is delayed */
	WORK_STRUCT_PWQ_BIT	= 2,	/* data points to pwq */ pool_workqueue
	WORK_STRUCT_LINKED_BIT	= 3,	/* next work is linked to this one */
	WORK_STRUCT_COLOR_SHIFT	= 4,	/* color for workqueue flushing */

	WORK_STRUCT_COLOR_BITS	= 4,

	WORK_STRUCT_PENDING	= 1 << WORK_STRUCT_PENDING_BIT,
	WORK_STRUCT_DELAYED	= 1 << WORK_STRUCT_DELAYED_BIT,
	WORK_STRUCT_PWQ		= 1 << WORK_STRUCT_PWQ_BIT,
	WORK_STRUCT_LINKED	= 1 << WORK_STRUCT_LINKED_BIT,
#ifdef CONFIG_DEBUG_OBJECTS_WORK
	WORK_STRUCT_STATIC	= 1 << WORK_STRUCT_STATIC_BIT,
#else
	WORK_STRUCT_STATIC	= 0,
#endif

	/*
	 * The last color is no color used for works which don't
	 * participate in workqueue flushing.
	 */
	WORK_NR_COLORS		= (1 << WORK_STRUCT_COLOR_BITS) - 1,
	WORK_NO_COLOR		= WORK_NR_COLORS,

	/* special cpu IDs */
	WORK_CPU_UNBOUND	= NR_CPUS,
	WORK_CPU_END		= NR_CPUS + 1,

	/*
	 * Reserve 7 bits off of pwq pointer w/ debugobjects turned off.
	 * This makes pwqs aligned to 256 bytes and allows 15 workqueue
	 * flush colors.
	 */
	WORK_STRUCT_FLAG_BITS	= WORK_STRUCT_COLOR_SHIFT +
				  WORK_STRUCT_COLOR_BITS,

	/* data contains off-queue information when !WORK_STRUCT_PWQ */
	WORK_OFFQ_FLAG_BASE	= WORK_STRUCT_COLOR_SHIFT,

	WORK_OFFQ_CANCELING	= (1 << WORK_OFFQ_FLAG_BASE),

	/*
	 * When a work item is off queue, its high bits point to the last
	 * pool it was on.  Cap at 31 bits and use the highest number to
	 * indicate that no pool is associated.
	 */
	WORK_OFFQ_FLAG_BITS	= 1,
	WORK_OFFQ_POOL_SHIFT	= WORK_OFFQ_FLAG_BASE + WORK_OFFQ_FLAG_BITS,
	WORK_OFFQ_LEFT		= BITS_PER_LONG - WORK_OFFQ_POOL_SHIFT,
	WORK_OFFQ_POOL_BITS	= WORK_OFFQ_LEFT <= 31 ? WORK_OFFQ_LEFT : 31,
	WORK_OFFQ_POOL_NONE	= (1LU << WORK_OFFQ_POOL_BITS) - 1,

	/* convenience constants */
	WORK_STRUCT_FLAG_MASK	= (1UL << WORK_STRUCT_FLAG_BITS) - 1,
	WORK_STRUCT_WQ_DATA_MASK = ~WORK_STRUCT_FLAG_MASK,
	WORK_STRUCT_NO_POOL	= (unsigned long)WORK_OFFQ_POOL_NONE << WORK_OFFQ_POOL_SHIFT,

	/* bit mask for work_busy() return values */
	WORK_BUSY_PENDING	= 1 << 0,
	WORK_BUSY_RUNNING	= 1 << 1,

	/* maximum string length for set_worker_desc() */
	WORKER_DESC_LEN		= 24,   
   #+end_src

** work_struct
   #+begin_src 
	atomic_long_t data;   //work_struct的属性
	struct list_head entry;  
	work_func_t func;   
   #+end_src

** delayed_work 
   #+begin_src 
	struct work_struct work;
	struct timer_list timer;

	/* target workqueue and CPU ->timer uses to queue ->work */
	struct workqueue_struct *wq;
	int cpu;   
   #+end_src

** worker
   #+begin_src 
	/* on idle list while idle, on busy hash table while busy */
	union {
		struct list_head	entry;	/* L: while idle */
		struct hlist_node	hentry;	/* L: while busy */ 在worker_pool->busy_hash表中
	};

	struct work_struct	*current_work;	/* L: work being processed */
	work_func_t		current_func;	/* L: current_work's fn */
	struct pool_workqueue	*current_pwq; /* L: current_work's pwq */
	bool			desc_valid;	/* ->desc is valid */
	struct list_head	scheduled;	/* L: scheduled works */

	/* 64 bytes boundary on 64bit, 32 on 32bit */

	struct task_struct	*task;		/* I: worker task */
	struct worker_pool	*pool;		/* I: the associated pool */
						/* L: for rescuers */

	unsigned long		last_active;	/* L: last active timestamp */
	unsigned int		flags;		/* X: flags */
	int			id;		/* I: worker id */

	/*
	 * Opaque string set with work_set_desc().  Printed out with task
	 * dump for debugging - WARN, BUG, panic or sysrq.
	 */
	char			desc[WORKER_DESC_LEN];

	/* used only by rescuers to point to the target workqueue */
	struct workqueue_struct	*rescue_wq;	/* I: the workqueue to rescue */   
   #+end_src

** worker_pool 
   #+begin_src 
	spinlock_t		lock;		/* the pool lock */
	int			cpu;		/* I: the associated cpu */
	int			node;		/* I: the associated node ID */
	int			id;		/* I: pool ID */
	unsigned int		flags;		/* X: flags */

	struct list_head	worklist;	/* L: list of pending works */
	int			nr_workers;	/* L: total number of workers */

	/* nr_idle includes the ones off idle_list for rebinding */
	int			nr_idle;	/* L: currently idle ones */

	struct list_head	idle_list;	/* X: list of idle workers */
	struct timer_list	idle_timer;	/* L: worker idle timeout */
	struct timer_list	mayday_timer;	/* L: SOS timer for workers */

	/* a workers is either on busy_hash or idle_list, or the manager */
	DECLARE_HASHTABLE(busy_hash, BUSY_WORKER_HASH_ORDER);
						/* L: hash of busy workers */

	/* see manage_workers() for details on the two manager mutexes */
	struct mutex		manager_arb;	/* manager arbitration */
	struct mutex		manager_mutex;	/* manager exclusion */
	struct idr		worker_idr;	/* MG: worker IDs and iteration */

	struct workqueue_attrs	*attrs;		/* I: worker attributes */
	struct hlist_node	hash_node;	/* PL: unbound_pool_hash node */
	int			refcnt;		/* PL: refcnt for unbound pools */

	/*
	 * The current concurrency level.  As it's likely to be accessed
	 * from other CPUs during try_to_wake_up(), put it in a separate
	 * cacheline.
	 */
	atomic_t		nr_running ____cacheline_aligned_in_smp;

	/*
	 * Destruction of pool is sched-RCU protected to allow dereferences
	 * from get_work_pool().
	 */
	struct rcu_head		rcu;   
   #+end_src

** pool_workqueue
   #+begin_src 
	struct worker_pool	*pool;		/* I: the associated pool */
	struct workqueue_struct *wq;		/* I: the owning workqueue */
	int			work_color;	/* L: current color */
	int			flush_color;	/* L: flushing color */
	int			refcnt;		/* L: reference count */
	int			nr_in_flight[WORK_NR_COLORS];
						/* L: nr of in_flight works */
	int			nr_active;	/* L: nr of active works */
	int			max_active;	/* L: max active works */
	struct list_head	delayed_works;	/* L: delayed works */
	struct list_head	pwqs_node;	/* WR: node on wq->pwqs */
	struct list_head	mayday_node;	/* MD: node on wq->maydays */

	/*
	 * Release of unbound pwq is punted to system_wq.  See put_pwq()
	 * and pwq_unbound_release_workfn() for details.  pool_workqueue
	 * itself is also sched-RCU protected so that the first pwq can be
	 * determined without grabbing wq->mutex.
	 */
	struct work_struct	unbound_release_work;
	struct rcu_head		rcu;   
   #+end_src

** wq_flusher
   #+begin_src 
	struct list_head	list;		/* WQ: list of flushers */
	int			flush_color;	/* WQ: flush color waiting for */
	struct completion	done;		/* flush completion */   
   #+end_src

** workqueue_struct
   #+begin_src 
	struct list_head	pwqs;		/* WR: all pwqs of this wq */
	struct list_head	list;		/* PL: list of all workqueues */

	struct mutex		mutex;		/* protects this wq */
	int			work_color;	/* WQ: current work color */
	int			flush_color;	/* WQ: current flush color */
	atomic_t		nr_pwqs_to_flush; /* flush in progress */
	struct wq_flusher	*first_flusher;	/* WQ: first flusher */
	struct list_head	flusher_queue;	/* WQ: flush waiters */
	struct list_head	flusher_overflow; /* WQ: flush overflow list */

	struct list_head	maydays;	/* MD: pwqs requesting rescue */
	struct worker		*rescuer;	/* I: rescue worker */

	int			nr_drainers;	/* WQ: drain in progress */
	int			saved_max_active; /* WQ: saved pwq max_active */

	struct workqueue_attrs	*unbound_attrs;	/* WQ: only for unbound wqs */
	struct pool_workqueue	*dfl_pwq;	/* WQ: only for unbound wqs */

#ifdef CONFIG_SYSFS
	struct wq_device	*wq_dev;	/* I: for sysfs interface */
#endif
#ifdef CONFIG_LOCKDEP
	struct lockdep_map	lockdep_map;
#endif
	char			name[WQ_NAME_LEN]; /* I: workqueue name */

	/* hot fields used during command issue, aligned to cacheline */
	unsigned int		flags ____cacheline_aligned; /* WQ: WQ_* flags */
	struct pool_workqueue __percpu *cpu_pwqs; /* I: per-cpu pwqs */
	struct pool_workqueue __rcu *numa_pwq_tbl[]; /* FR: unbound pwqs indexed by node */   
   #+end_src

** worker_pool_assign_id(worker_pool)
   - 从worker_pool_idr中分配一个id, 索引worker_pool指针

** unbound_pwq_by_node(workqueue_struct, node)
   - node应该对应cpu
   - 获取workqueue_struct->numa_pwq_tbl[node]
   - 使用rcu保护,或者pwq_lock, workqueue_struct->mutex

** work_color_to_flags(color)
   - color是work_struct->data中的标志, 从WORK_STRUCT_COLOR_SHIFT开始
   - 一共WORK_STRUCT_COLOR_BITS(4)位, 也就是有16种, 在flush中使用

** get_work_color(work_struct)
   - ( work_struct->data >> WORK_STRUCT_COLOR_SHIFT) & ((1<<WORK_STRUCT_COLOR_BITS)-1)

** work_next_work(color)
   - ( color + 1 ) % WORK_NR_COLORS, 不能超过15

** set_work_data(work_struct, data, flags)
   - 设置work_struct->data的标志位
   - work_struct当前必须在等待? work_struct->data必须有WORK_STRUCT_PENDING_BIT
   > atomic_long_set(&work->data, data | flags | work_static(work))
   - 最后需要留下WORK_STRUCT_STATIC?

** set_work_pwq(work_struct, pool_workqueue, extra_flags)
   - 设置work_struct->data的标志位
   > set_work_data(work_struct, pool_workqueue, WORK_STRUCT_PENDING|WORK_STRUCT_PWQ|extra_flags)

** set_work_pool_and_keep_pending(work_struct, pool_id)
   - 设置pool_id, 它表示什么? 
   > set_work_data(work_struct, pool_id << WORK_OFFQ_POOL_SHIFT, WORK_STRUCT_PENDING)

** set_work_pool_and_clear_pending(work_struct, pool_id)
   - 设置pool_id, 而且去掉WORK_STRUCT_PENDING 
   > set_work_data(work_struct, pool_id << WORK_OFFQ_POOL_SHIFT, 0)

** clear_work_data(work_struct)
   - 这里的pool_id是WORK_STRUCT_NO_POOL 
   > set_work_data(work_struct, WORK_STRUCT_NO_POOL, 0)

** get_work_pwq(work_struct)
   - 从work_struct->data中获取pool_workqueue
   - 只有data中包含WORK_STRUCT_PWQ时,他才包含pool_workqueue指针 
   > data & WORK_STRUCT_WQ_DATA_MASK

** get_work_pool(work_struct)
   - 计算worker_pool
   - 如果work_struct->data带标志WORK_STRUCT_PWQ
   - 使用pool_workqueue->worker_pool
   - 如果没有, 获取pool_id
   - work_struct->data >> WORK_OFFQ_POOL_SHIFT
   - 如果是WORK_OFFQ_POOL_NONE, pool_id无效,返回NULL 
   - 查找全局的worker_pool
   > idr_find(worker_pool_idr, pool_id)

** get_work_pool_id(work_struct)
   - 计算pool_id
   - 如果work_struct->data带标志WORK_STRUCT_PWQ, 使用pool_workqueue->worker_pool->id
   - 否则使用work_struct->data >> DATA_OFFQ_POOL_SHIFT

** mark_work_concelling(work_struct)
   - 设置work_struct->data
   - 包括pool_id, WORK_OFFQ_CANCELING, WORK_STRUCT_PENDING
   > set_work_data(work, pool_id | WORK_OFFQ_CANCELING, WORK_STRUCT_PENDING)

** work_is_cancelling(work_struct)
   - work_struct->data没有WORK_STRUCT_PWQ??
   - 而且有WORK_OFFQ_CANCELLING

** __need_more_worker(worker_pool)
   - 如果worker_pool->nr_running == 0, 需要更多的worker??

** need_more_worker(worker_pool)
   - worker_pool->worklist里面是什么? 不为空
   > __need_more_worker(worker_pool)

** may_start_working(worker_pool)
   - 是否可以启动现有的worker??
   > worker_pool->nr_idle

** keep_working(worker_pool)
   - 是否需要继续工作? 
   > worker_pool->worklist不为空,而且worker_pool->nr_running <= 1

** need_to_create_worker(worker_pool)
   - 需要更多的worker
   > need_more_worker(worker_pool)
   - 而且不能启动现有的?
   > may_start_working(worker_pool)

** need_to_manage_workers(worker_pool)
   - 是否可以变成manager? 
   - 需要创建新的worker 
   > need_to_create_worker(worker_pool)
   - 或者worker_pool->flags有POOL_MANAGE_WORKERS??

** too_many_workers(worker_pool)
   - 计算是否有太多的worker?
   - 如果worker_pool->idle_list为空,返回false? 不够用的?!
   - worker_pool->nr_idle表示空闲的worker, nr_workers表示工作中的
   - nr_idle > 2 && (nr_idle - 2) * MAX_IDLE_WORKERS_RATIO >= nr_busy

** first_worker(worker_pool)
   - 返回第一个可用的worker 
   - 如果worker_pool->idle_list为空, 返回NULL
   > list_first_entry(&pool->idle_list, struct worker, entry)

** wake_up_worker(worker_pool)
   - 唤醒第一个worker?  没有任何保护?  
   > first_worker(worker_pool)
   > wake_up_process(worker->task_struct)

** wq_worker_waking_up(task_struct, cpu)
   - 回调函数, 在唤醒任务中调用
   - task_struct->flags包含PF_WQ_WORKER,表示这个任务执行workqueue
   - task_struct=>vfork_done是kthread->completion, kthread->data就是worker
   - 如果worker->flags没有WORKER_NOT_RUNNING, 表示已经唤醒??
   - 增加worker->worker_pool->nr_running
   - cpu应该和worker->worker_pool->cpu相同

** wq_worker_sleeping(task_struct, cpu)
   - 在__schedule函数中调用, 应该是调度之前?
   - 这个worker要去sleep?
   - 如果worker->flags没有WORKER_NOT_RUNNING, 直接退出
   - 如果cpu不是当前cpu, 直接退出?
   - 减小worker_pool->nr_running, 如果减为0, 而且worker_pool->worklist还有任务?
   - 需要唤醒下一个?  既然有任务,何必要调度?
   > first_worker(worker_pool)
   - 返回worker_pool->task, 后面会尝试唤醒这个任务??

** worker_set_flags(worker, flgs, wakeup)
   - 设置worker标志,更新worker_pool->nr_running计数
   - worker必须是current执行的任务
   - 设置worker->flags |= flags
   - 如果flags中包含WORKER_NOT_RUNNING, 而且原来没有, 说明这个worker要变为idle状态?
   - 减小worker_pool->nr_running
   - 如果wakeup !=0, 检查是否还有工作, 而且没有worker在nr_running状态, 唤醒下一个任务
   > wake_up_worker(worker_pool)

** worker_clr_flags(worker, flags)
   - 和上面相反, 去掉worker->flags中的flags标志
   - 因为WORKER_NOT_RUNNING包含多个标志
   - 这里要保证worker->flags没有任何这些标志,才减小worker_pool->nr_running

** find_worker_executing_work(worker_pool, work_struct)
   - 查找worker_pool中正在执行work_struct的worker
   - 遍历worker_pool->busy_hash链表
   - 比较worker->current_work = work, worker->current_func == work_struct->func
   - 这里比较2个是为了避免work_struct的重用? 重用也可能导致func也重用呢?

** move_linked_works(work_struct, list_head, work_struct)
   - 把work_struct->entry中的work_struct放到list_head中, 包括它自己
   - work_struct->entry是单链表??
   - 如果work_struct->data没有WORK_STRUCT_LINKED, 停止移动

** get_pwq(pool_workqueue)
   - 增加pool_workqueue->refcnt

** put_pwq(pool_workqueue)
   - 减小pool_workqueue->refcnt
   - 如果减为0, 使用work_struct释放自己?? 
   > schedule_work(pool_workqeueu->unbound_release_work)

** put_pwq_unlocked(pool_workqueue)
   - 锁住pool_workqueue->pool->lock, 锁住当前的worker_pool?
   > put_pwq(pool_workqueue)

** pwq_activate_delayed_work(work_struct)
   - 把work_struct放到pool_workqueue->worker_pool->worklist队列中
   - 获取pool_workqueue 
   > get_work_pwq(work_struct)
   > move_linked_works(work_struct, pool_workqueue->worker_pool->worklist, NULL)
   - 去掉work_struct->data的WORK_STRUCT_DELAYED_BIT标志?
   - 增加pool_workqueue->nr_active

** pwq_activate_first_delayed(pool_workqueue)
   - 唤醒pool_workqueue->delayed_works队列上的第一个work_struct
   > pwq_activate_delayed_work(work_struct)

** pwq_dec_nr_in_flight(pool_workqueue, color)
   - work_struct完成,退出pool_workqueue?
   - 处理workqueue的flush
   - 如果color是WORK_NO_COLOR, 不处理flush, 直接释放pool_workqueue
   - 减小pool_workqueue->nr_in_flight[color], pool_workqueue->nr_active
   - 如果pool_workqueue还有work_struct, pool_workqueue->delayed_works队列中有work_struct
   - 唤醒下一个work_struct ? 仅仅是队列操作?
   > pwq_activate_first_delayed(pool_workqueue)
   - 如果pool_workqueue->flush_color != color, 不处理flush操作
   - 如果pool_workqueue->nr_in_flight[color] !=0, 也不处理???
   - 设置pool_workqueue->flush_color = -1, flush完成? 
   - 减小pool_workqueue->workqueue_struct->nr_pwqs_to_flush, 如果为0, 唤醒等待的flush操作 
   > complete(&pwq->wq->first_flusher->done)
   - 最后释放pool_workqueue 
   > put_pwq(pool_workqueue)

** try_to_grab_pending(work_struct, is_dwork, flags)
   - 首先禁止中断 
   > local_irq_save(flags)
   - is_dwork表示work_struct是delayed_work
   - 撤销计时器
   > del_timer(delayed_work->timer)
   - 设置work_struct->data的WORK_STRUCT_PENDING_BIT, 
   - 如果原来, 说明当前任务设置这个标志??  直接返回0
   > test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_struct->data)
   - 否则这个work_struct已经被别人处理, 已经在队列中
   - 获取pool_workqueue 和 worker_pool
   > get_work_pool(work_struct)
   > get_work_pwq(work_struct)
   - 这里需要注意work_struct->data的数据,他里面不一定有pool_workqueue的指针, 所以这里使用worker_pool->lock保护起来
   - 如果work_struct->data带标志WORK_STRUCT_DELAYED, 唤醒他? 
   > pwq_activate_delayed_work(work_struct)
   - 减小等待的任务数量? 
   > pwq_dec_nr_in_flight(get_work_pwd(work_struct), get_work_color(work_struct))
   - 再改变work_struct->data, 放上pool id, 而且让他等待? 
   > set_work_pool_and_keep_pending(work_struct, worker_pool->id)
   - 等待的位置改变了?? 
   - 然后返回1, 表示什么?? 
     
** insert_work(pool_workqueue, work_struct, list_head, extra_flags)
   - 把work_struct放到pool_workqueue->worker_pool中
   > set_work_pwq(work_struct, pool_workqueue, extra_flags)
   - 把work_struct->entry放到list_head中, 哪个队列?
   > get_pwq(pool_workqueue)
   - 检查worker_pool是否需要开始工作 worker_pool->nr_running == 0??
   > __need_more_worker(worker_pool)
   - 唤醒这个worker_pool的线程
   > wake_up_worker(worker_pool)

** __queue_work(cpu, workqueue_struct, work_struct)
   - 这时中断必须是关闭的?
   - 如果pool_workqueue->flags有__WQ_DRAINING, 而且workqueue_struct不是特殊的
   - workqueue_struct已经释放,不再处理work_struct,直接返回
   > is_chained_work(workqueue_struct)
   - 选择cpu针对的pool_workqueue
   - 如果参数cpu == WORK_CPU_UNBOUND, 使用当前cpu 
   > raw_smp_processor_id()
   - 如果workqueue_struct->flags有WQ_UNBOUND, 不限制cpu 
   > unbound_pwq_by_node(workqueue_struct, cpu_to_node(cpu))
   - 否则使用对应的pool_workqueue 
   > per_cpu_ptr(workqueue_struct->cpu_pwqs, cpu)
   - 再检查之前使用的worker对应的worker_pool
   - 之前执行完毕,还会重复执行?
   > get_work_pool(work_struct)
   - 如果选出来的worker_pool和上面cpu对应的不一样, 检查worker?? 
   > find_worker_executing_work(pool_workqueue, work_struct)
   - 如果worker->pool_workqueue->workqueue_struct和参数一样,可以使用这个pool_workqueue
   - 为何这么复杂??
   - 检查work_struct->entry, 如果已经在某个队列中,直接退出?? 
   - 否则开始放到队列 
   - 增加pool_workqueue->nr_in_flight[pool_workqueue->work_color], 这个work_struct就使用这个color 
   > work_color_to_flags(pool_workqueue->work_color)
   - 如果当前pool_workqueue的任务太重,把它放到delayed_works链表中, 而且设置WORK_STRUCT_DELAYED标志
   - pool_workqueue->nr_active < pool_workqueue->max_active
   - 否则放到pool_workqueue->worker_pool->worklist中,而且增加pool_workqueue->nr_active
   - 放到队列中 
   > insert_work(pool_workqueue, work_struct, worklist, color_flags)

** queue_work_on(cpu, workqueue_struct, work_struct)
   - 使用中断保护队列操作
   - 使用work_struct->data的WORK_STRUCT_PENDING_BIT同步这里的操作
   - test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work_struct))
   - 操作队列 
   > __queue_work(cpu, pool_workqueue, work_struct)

** delayed_work_timer_fn(data)
   - 这是timer回调,必须在中断保护中使用 
   - 参数是delayed_work
   > __queue_work(delayed_work->cpu, delayed_work->workqueue_struct, delayed_work->work_struct)

** __queue_delayed_work(cpu, workqueue_struct, delayed_work, delay)
   - 安装计时器,经过一段延时,启动delayed_work
   - 检查参数delayed_work->timer的回调函数必须是上面的delayed_work_timer_fn
   - timer没有开始使用, work_struct没有在任何队列中
   - 如果delay == 0, 直接插入队列 
   > __queue_work(cpu, workqueue_struct, delayed_work->work_struct)
   - 否则安装计时器, 如果cpu != WORK_CPU_UNBOUND, 使用特定的cpu
   > add_timer_on(timer, cpu)
   > add_time(timer)

** queue_delayed_work_on(cpu, workqueue_struct, delayed_work, delay)
   - 使用中断保护操作 
   > local_irq_save(flags)
   - 同样使用work_struct->data的WORK_STRUCT_PENDING_BIT同步 
   > __queue_delayed_work(cpu, workqueue_struct, delayed_work, delay)

** mod_delayed_work_on(cpu, workqueue_struct, delayed_work, delay)
   - 处理一个未知状态的任务?
   - 获取work_struct->data的WORK_STRUCT_PENDING_BIT 
   > try_to_grab_pending(delayed_work->work_struct, true, flags)
   - 如果获取到,进行队列操作 
   > __queue_delayed_work(cpu, workqueue_struct, delayed_work, delay)

** worker_enter_idle(worker)
   - worker变为idle状态?
   - 如果worker->flags有WORKER_IDLE 或者worker->entry在队列中, 而且worker->hentry在队列中
   - 说明它已经是idle状态
   - 否则修改worker状态
   - 设置worker->flags的WORKER_IDLE, 增加pool_workqueue->nr_idle
   - worker->last_active = jiffies
   - 把worker->entry放到pool_workqueue->idle_list队列中
   - 如果pool_workqueue的worker太多, 启动计时器, 应该是关闭worker?
   > mod_timer(&pool_workqueue->idle_timer, jiffies + IDLE_WORKER_TIMEOUT)
 
** worker_leave_idle(worker)
   - worker变为不是idle的状态,开始工作,还是退出工作? 
   - worker->flags应该有WORKER_IDLE
   - 去掉worker->flags中的WORKER_IDLE标志 
   > worker_clr_flags(worker, WORKER_IDLE)
   - 减小pool_workqueue->nr_idle, 释放worker->entry链表

** worker_maybe_bind_and_lock(worker_pool)
   - 把当前任务绑定给worker_pool?
   - 这里通过设定task_struct使用的cpu, 以及调度,实现current绑定给worker_pool 
   - 如果worker_pool->flags没有POOL_DISASSOCIATED
   - 需要特定的cpu? 
   > set_cpus_allowed_ptr(current, worker_pool->attrs->cpumask)
   - 如果worker_pool->flags有POOL_DISASSOCIATED， 直接退出? 那上面还设置什么?
   - 检查current是否满足要求
   - 当前cpu和worker_pool->cpu一样
   > task_cpu(current)
   > cpumask_equal(current->cpu_allowed, worker_pool->attrs->cpumask)
   - 如果上面条件不满足, 重新调度 ? 
   > cond_resched()

** alloc_worker()
   - 构造一个worker
   - 开始设置worker->flags = WORKER_PREP

** create_worker(worker_pool)
   - 构造worker, 分配idr索引
   > idr_alloc(worker_pool->worker_idr, NULL, 0, 0, GFP_NOWAIT)
   > alloc_worker()
   - 创建独立的线程,线程的名字根据cpu或id而定
   - 如果worker_pool->cpu>=0, 他绑定到固定的cpu, 线程名字使用cpu:id, 否则使用id
   > kthread_create_on_node(worker_thread, worker, worker_pool->node, 'kworker/id')
   - 设置线程属性 
   > set_user_nice(worker->task, worker_pool->attrs->nice)
   > set_cpus_allowed_ptr(worker->task, worker_pool->attrs->cpumask)
   - 还是worker->task_struct->flags的PF_NO_SETAFFINITY, 不需要改动绑定?
   - 如果worker_pool->flags有POOL_DISASSOCIATED，不需要把任务绑定都cpu上面?
   - 设定worker->flags的WORKER_UNBOUND
   
** start_worker(worker)
   - 设定worker->flags的WORKER_STARTED
   - 增加worker->worker_pool->nr_workers
   - worker开始是idle状态? 
   > worker_enter_idle(worker)
   - 唤醒刚创建的线程
   > wake_up_process(worker->task)

** create_and_start_worker(worker_pool)
   - 创建并启动一个worker 
   > create_worker(worker_pool)
   > start_worker(worker)

** destroy_worker(worker)
   - 销毁worker
   - 先检查是否满足条件
   - worker->current_work != NULL, 或者worker->scheduled不再链表中, 直接返回
   - 如果worker->flags包含WORKER_STARTED, 减小worker_pool->nr_workers
   - 如果worker->flags包含WORKER_IDLE, 减小worker_pool->nr_idle
   - 释放worker->entry链表?? 设置worker->flags的WORKER_DIE?
   - 释放idr索引, 关闭线程
   - kthread_stop(worker->task_struct)
   - 释放worker

** idle_worker_timeout(pool)
   - 这个函数是worker_pool->idle_timer的回调函数
   - 在worker太多时,关闭多于的worker 
   > too_many_worker(worker_pool)
   - 从worker_pool->idle_list中取出最后一个
   - 如果它睡眠太常时间
   - worker->last_active + IDLE_WORKER_TIMEOUT < jiffies, 设置worker->flags的POOL_MANAGE_WORKERS, 唤醒它? 
   > wake_up_worker(worker_pool)
   - 否则让计时器继续

** send_mayday(work_struct)
   - 要唤醒workqueue_struct->rescure做什么?
   - 从work_struct获取pool_workqueue, workqueue_struct
   > get_work_pwq(work_struct)
   - 如果workqueue_struct->rescuer为NULL, 没有rescuer, 直接退出
   - 如果pool_workqueue->mayday_node链表为空, 把pool_workqueue->mayday_node放到workqueue_struct->maydays中
   - 唤醒workqueue_struct->rescuer->task, 处理这个pool_workqueue? 

** pool_mayday_timeout(pool)
   - 这是worker_pool->mayday_timer的回调函数
   - 检查是否需要worker_pool 
   > need_to_create_worker(worker_pool)
   - 这时不能再创建新的worker?
   - 向所有的worker发送mayday求救信号
   - 遍历worker_pool->worklist链表中的worker 
   > send_mayday(work_struct)
   - 重新安装计时器
   > mod_timer(worker_pool->mayday_timer, jiffies + MAYDAY_INTERVAL)

** maybe_create_worker(worker_pool)
   - 创建一个新的worker
   - 如果不需要,直接返回
   > need_to_create_worker(worker_pool)
   - 设置计时器,如果一段时间都无法建立worker, 发送求救信号
   > mod_timer(worker_pool->mayday_timer, jiffiest + MAYDAY_INITIAL_TIMEOUT)
   - 开始循环执行创建工作
   > create_worker(worker_pool)
   - 如果创建成功,取消worker_pool->mayday_timer
   - 启动worker 
   > start_worker(worker)
   - 否则等待一段时间重新创建
   > __set_current_state(TASK_INTERRUPTIBLE)
   > schedule_timeout(CREATE_COOLDOWN)

** maybe_destroy_workers(worker_pool)
   - 关闭长时间不用的worker
   - 这里会循环执行,直到没有多余的worker 
   > too_many_workers(worker_pool)
   - 获取worker_pool->idle链表最后一个work_struct
   - 如果它睡眠太常时间 worker->last_active + IDLE_WORKER_TIMEOUT < jiffies, 关闭这个worker 
   > destroy_worker(worker)
   - 最后没有worker处理,重新安装worker_pool->idle_timer

** manage_workers(worker)
   - worker_pool的管理者任务,创建或关闭线程
   - 使用worker_pool->manager_arb同步这些操作 
   > mutex_trylock(worker_pool->manager_arb)
   - 如果无法获取锁,别人在操作,直接返回
   - 去掉worker_pool->flags的POOL_MANAGE_WORKERS标志?
   - 同时获取worker_pool->manager_mutex, 防止别人创建worker?
   - 开始创建或释放任
   > maybe_destroy_workers(worker_pool)
   > maybe_create_worker(worker_pool)
   
** process_one_work(worker, work_struct)
   - 从work_struct获取pool_workqueue, worker_pool
   - 检查cpu是否正确
   - 如果worker->flags没有WORKER_UNBOUND, 而且worker_pool->flags没有POOL_DISASSOCIATED
   - 判断worker_pool->cpu是否和当前的状态一样
   > raw_smp_processor_id()
   - 检查是否有冲突的worker? 
   > find_worker_executing_work(worker_pool, work_struct)
   - 如果找到??? 返回
   > move_linked_works(work_struct, worker->scheduled, NULL)
   - 开始处理work_struct 
   - 把work_struct->hentry放到worker_pool->busy_hash中, 设置worker
   - worker->current_pwd = pool_workqueue, 原来这2者不是绑定的?
   - 释放work_struct->entry链表
   - 如果pool_workqueue->worker_pool->flags包含WQ_CPU_INTENSIVE, 设置worker->flags的WORKER_CPU_INTENSIVE? 
   > worker_set_flags(worker, WORKER_CPU_INTENSIVE, true)
   - 如果是unbound的worker, worker->flags有WORKER_UNBOUND
   - 不需要同步? 唤醒其他worker 
   > need_more_worker(worker_pool)
   > wake_up_worker(worker_pool)
   - 更新work_struct的标志 
   > set_work_pool_and_clear_pending(work_struct, worker_pool->id)
   - 执行任务?
   > worker->current_func(work_struct)
   - 完成之后,开始恢复操作
   - 释放worker->hentry, worker->current_work/current_func等
   - 最后减小计数
   > pwq_dec_nr_in_flight(pool_workqueue, work_color)

** process_scheduled_works(worker)
   - 处理worker->scheduled队列上的work_struct
   - 循环处理队列上的第一个work_struct, 直到队列为空
   > process_one_work(worker, work_struct)

** worker_thread(worker)
   - 这是worker的工作线程?
   - 设置worker->task->flags的PF_WQ_WORKER
   - 检查worker->flags的WORKER_DIE, 说明它在被关闭,直接退出
   - 离开idle状态 
   > worker_leave_idle(worker)
   - 检查是否有work? 如果不需要,去睡眠
   > need_more_worker(worker_pool)
   - 是否需要做manager的工作 worker_pool->nr_idle > 0??
   > may_start_working(worker_pool)
   - 开始创建或关闭worker 
   > manage_workers(worker)
   - 开始处理work_struct, 先准备worker
   > worker_clr_flags(worker, WORKER_PREP|WORKER_REBOUND)
   - 这里从worker_pool->worklist获取work_struct
   - 如果work_struct->data没有WORK_STRUCT_LINKED, 只处理一个work_struct?
   > process_one_work(worker, work_struct)
   - 否则把它放到worker->scheduled链表中
   > move_linked_works(work_struct, worker->scheduled, NULL)
   - 集中处理 
   > process_scheduled_works(worker)
   - 循环处理,直到worker_pool->worklist不为空,而且没有其他的worker? 
   > keep_working(worker_pool)
   - 循环结束,恢复worker 
   - 设置worker->flags的WORKER_PREP
   - 睡眠处理, 检查是否需要manager工作
   > need_to_manage_worker(worker_pool)
   > manage_workers(worker)
   - 进入IDLE状态
   > worker_enter_idle(worker)
   - 整个过程使用worker_pool->lock保护? 
   - 最后进入TASK_INTERRUPTIBLE状态等待

** rescuer_thread(rescuer)
   - rescuer任务使用的函数
   - 提高任务优先级? 最后-20
   > set_user_nice(current, RESCUER_NICE_LEVEL)
   - 设置worker->task->flags的PF_WQ_WORKER
   - 首先睡眠?
   - 这个任务处理worker->rescue_wq->maydays的pool_workqueue
   - 获取一个pool_workqueue 
   > worker_maybe_bind_and_lock(worker_pool)
   - 设置worker->pool = worker_pool?
   - 遍历worker_pool->worklist, 过滤属于当前pool_workqueue的，放到临时队列
   > move_linked_works(work_struct, scheduled, n)
   - 集中处理这些 
   > process_scheduled_works(rescuer)
   - 如果worker_pool有工作需要作, 唤醒它的worker 
   > keep_working(worker_pool)
   > wake_up_worker(worker_pool)
   
** wq_barrier 
   #+BEGIN_SRC 
	struct work_struct	work;
	struct completion	done;
   #+END_SRC

** wq_barrier_func(work_struct)
   - 唤醒wq_barrier->completion

** insert_wq_barrier(pool_workqueue, wq_barrier, work_struct target, worker)
   - 把wq_barrier->work_struct放到target的链表中?
   - 当target完成之后,wq_barrier才完成?
   - 初始化wq_barrier, completion
   - 设置wq_barrier->work_struct->func = wq_barrier_func
   - 设置work_struct->data的WORK_STRUCT_PENDING_BIT??
   - 如果参数worker有效, 它正在执行?
   - 把wq_barrier插入到worker->scheduled
   - 否则放到work_struct->entry队列中
   - 设置work_struct->data的WORK_STRUCT_LINKED_BIT标志
   > insert_work(pool_workqueue, wq_barrier->work_struct, list_head, work_color_to_flags(WORK_NO_COLOR) | linked)
   - 如果原来work_struct是linked, 传递这个标志,同时执行后面的work_struct

** flush_workqueue_prep_pwqs(workqueue_struct, flush_color, work_color)
   - 刷新一个workqueue_struct?
   - 如果flush_color >=0, 设置workqueue_struct->nr_pwqs_to_flush = 1
   - 遍历workqueue_struct的pool_workqueue?
   - 如果flush_color >=0, 而且pool_workqueue->nr_in_flight[flush_color] > 0
   - 需要等待这个pool_workqueue?
   - 设置pool_workqueue->flush_color = flush_color
   - 增加workqueue_struct->nr_pwqs_to_flush
   - 如果work_color > 0
   - 设置pool_workqueue->work_color = work_color
   - 最后如果flush_color >=0, 减小workqueue_struct->nr_pwqs_to_flush
   - 如果它减为0, 说明flush完成? 
   > complete(workqueue_struct->first_flusher_done)

** wq_flusher
   #+BEGIN_SRC 
	struct list_head	list;		/* WQ: list of flushers */
	int			flush_color;	/* WQ: flush color waiting for */
	struct completion	done;		/* flush completion */   
   #+END_SRC

** flush_workqueue(workqueue_struct)
   - flush所有的work_struct ?
   - 计算可使用的color? 
   > work_next_work(workqueue_struct->work_color)
   - 如果color不是workqueue_struct->flush_color, color还没用完?
   - 设置wq_flusher->flush_color = workqueue_struct->work_color
   - 更新workqueue_struct->work_color = next_color, 就是上面计算的
   - 如果workqueue_struct->first_flusher是NULL, 还没有flusher?
   - 刷新workqueue_struct 
   > flush_workqueue_prep_pwqs(workqueue_struct, workqueue_struct->flush_color, workqueue_struct->work_color)
   - 如果上面返回false, 说明没有work_struct ?
   - 如果不是第一个wq_flusher
   - 把wq_flusher->list放到workqueue_struct->flusher_queue链表中
   - 使用不同的参数等待? 
   > flush_workqueue_prep_pwqs(workqueue_struct, -1, workqueue_struct->work_color)
   - 如果color空间不够用?
   - 把wq_flusher->list放到workqueue_struct->flusher_overflow链表
   - 等待wq_flusher->done 
   > wait_for_completion(wq_flusher->done)
   - 被唤醒后, 如果workqueue_struct->first_flusher不是当前wq_flusher直接返回?
   - 否则还要处理其他的wq_flusher? 
   - 遍历workqueue_struct->flusher_queue, 
   - 如果wq_flusher->flush_color != workqueue_struct->flush_color?  它已经完成? 
   > complete(wq_flusher->done)
   - 然后处理workqueue_struct->flusher_overflow链表中的wq_flusher
   - 让他们使用同一个flush_color
   - 遍历workqueue_struct->flusher_overflow
   - 设置wq_flusher->flush_color = workqueue_struct->work_color
   - 设置workqueue_struct->work_color = next_color 
   > work_next_color(workqueue_struct->work_color)
   - 把workqueue_struct->flusher_overflow队列中的wq_flusher放到workqueue_struct->flusher_queue中
   - flush_workqueue_prep_pwqs(workqueue_struct, -1, workqueue->work_color)
     
** drain_workqueue(workqueue_struct)
   - 刷新workqueue_struct, 不再接受新的work_struct 
   - 增加workqueue_struct->nr_drainers, 设置workqueue_struct->flags的__WQ_DRAINING 
   > flush_workqueue(workqueue_struct)
   - 遍历workqueue_struct的pool_workqueue
   - 检查是否完成 pool_workqueue->nr_active ==0
   - 而且pool_workqueue->delayed_works为空
   - 如果还有work_struct, 重新flush
   - 最后恢复, 减小workqueue_struct->nr_drainers, 去掉__WQ_DRAINING标志

** start_flush_work(work_struct, wq_barrier)
   - 获取work_struct的pool_workqueue, worker_pool
   > get_work_pool(work_struct)
   > get_work_pwq(work_struct)
   - worker_pool一定存在,但pool_workqueue不一定?
   - 如果worker_pool和pool_workqueue不一致,work_struct已经结束? 不再处理
   - 如果pool_workqueue不存在,计算对应的worker 
   > find_worker_executing_work(worker_pool, work_struct)
   - 如果找不到,work_struct也结束,直接返回 
   - 否则使用worker->pool_workqueue
   - 把wq_barrier插入到pool_workqueue 
   > insert_wq_barrier(pool_workqueue, wq_barrier, work_struct, worker)
   
** __flush_work(work_struct)
   - 刷新一个work_struct?
   - 使用wq_barrier 
   > start_flush_work(work_struct, wq_barrier)
   - 等待wq_barrier 
   > wait_for_completion(wq_barrier->done)
   - 然后释放wq_barrier->work_struct 
   > destroy_work_on_stack(wq_barrier->work_struct)

** flush_work(work_struct)
   - 等待work_struct执行结束
   > __flush_work(work_struct)

** __cancel_work_timer(work_struct, is_dwork)
   - 取消一个work_struct ? 
   > try_to_grab_pending(work_struct, is_dwork, flags)
   - 如果找不到? 
   > flush_work(work_struct)
   - 设置取消标志? 
   > mark_work_canceling(work_struct)
   - 在flush一遍? 
   > flush_work(work_struct)
   - 清除work_struct->data 
   > clear_work_data(work_struct)

** cancel_work_sync(work_struct)
   > __cancel_work_timer(work_struct, false)

** flush_delayed_work(delayed_work)
   - flush一个延时的work_struct 
   - 取消计时器 
   > del_timer_sync(delayed_work->timer)
   - 直接执行它? 
   > __queue_work(delayed_work->cpu, delayed_work->workqueue_struct, delayed_work->work_struct)
   - 然后等待它完成 
   > flush_work(delayed_work->work_struct)

** cancel_delayed_work(delayed_work)
   - 取消一个delayed_work 
   > try_to_grab_pending(delayed_work->work_struct, true, flags)
   - 重新设置work_struct的标记
   > set_work_pool_and_clear_pending(delayed_work->work_struct, get_work_pool_id(delayed_work->work_struct))
   
** cancel_delayed_work_sync(delayed_work)
   > __cancel_work_timer(delayed_work->work_struct, true)

** schedule_on_each_cpu(func)
   - 在每个cpu上创建一个work_struct, 执行函数func 
   > alloc_percpu(work_struct)
   - 遍历每个cpu, 提交work_struct 
   > INIT_WORK(work_struct, func)
   > schedule_work_on(cpu, work_struct)
   - 然后等待完成 
   > flush_work(per_cpu_ptr(work_struct, cpu))
   
** flush_scheduled_work()
   - 刷新一个workqueue_struct, 全局的system_wq 
   > flush_workqueue(system_wq)

** execute_work 
   #+BEGIN_SRC 
   struct work_struct work;
   #+END_SRC

** execute_in_process_context(work_func_t, execute_work)
   - 提交一个work_struct, 让他在非中断上下文中执行 
   - 如果当前不在中断中, 直接执行
   > in_interrupt()
   - 否则使用execute_work调度 
   > schedule_work(execute_work->work_struct)

** init_worker_pool(worker_pool)
   - 创建worker_pool

** rcu_free_pool(rcu_head)
   - 异步释放worker_pool 
   > idr_destroy(worker_pool->worker_idr)
   - 释放device attributes 
   > free_workqueue_attrs(worker_pool->attrs)

** put_unbound_pool(worker_pool)
   - 释放worker_pool, 减小worker_pool->refcnt
   - 如果不是0, 直接返回
   - 检查是否可以释放
   - worker_pool->flags没有POOL_DISASSOCIATED或者
   - worker_pool->worlist里面还有work_struct, 不能释放
   - 释放全局的idr索引? 
   > idr_remove(worker_pool_idr, worker_pool->id)
   - 释放hash表 
   > hash_del(worker_pool->hash_node)
   - 释放所有的worker, 在worker_pool->idle_list链表中
   > first_worker(worker_pool)
   > destroy_worker(worker_pool)
   - 释放2个timer, idle_timer, mayday_timer
   - rcu异步释放
   > call_rcu_sched(worker_pool->rcu, rcu_free_pool)

** workqueue_attrs
   #+BEGIN_SRC 
	int			nice;		/* nice level */
	cpumask_var_t		cpumask;	/* allowed CPUs */
	bool			no_numa;	/* disable NUMA affinity */   
   #+END_SRC

** get_unbound_pool(workqueue_attrs)
   - 查找和workqueue_attrs匹配的worker_pool
   - 遍历unbound_pool_hash里面的worker_pool
   - 比较worker_pool->attrs和workqueue_attrs
   - 如果找不到,创建新一个 
   > init_worker_pool(worker_pool)
   - 分配idr索引, 建立hahs表关系
   > worker_pool_assign_id(worker_pool)
   > hash_add(unbound_pool_hash, worker_pool->hash_node, hash)
   - 创建worker 
   > create_and_start_worker(worker_pool)

** rcu_free_pwq(rcu_head)
   - 异步释放pool_workqueue 
   > kmem_cache_free(pwq_cache, pool_workqueue)

** pwq_unbound_release_workfn(work_struct)
   - 使用work_struct释放pool_workqueue
   - 使用system_wq
   - work_struct是pool_workqueue->unbound_release_work
   - 如果workqueue_struct->flags没有WQ_UNBOUND, 不能释放?
   - 释放pool_workqueue->pwqs_node链表?
   - 这是workqueue_struct->pwqs?
   - 释放pool_workqueue
   > put_unbound_pool(worker_pool)
   > call_rcu_sched(pool_workqueue->rcu, rcu_free_pwq)
   - 如果workqueue_struct->pwqs队列为空,没有pool_workqueue, 释放它自己
   > free_workqueue_attrs(workqueue_struct->unbound_attrs)
   > kfree(workqueue_struct)

** pwq_adjust_max_active(pool_workqueue)
   - 更新pool_workqueue->max_active?
   - pool_workqueue->worker_pool->flags没有POOL_FREEZING
   - 而且workqueue_struct->flags没有WQ_FREEZABLE
   - 设置pool_workqueue->max_active = workqueue_struct->saved_max_active
   - 然后唤醒worker? 直到pool_workqueue->nr_active >= pool_workqueue->max_active 
   > pwq_activate_first_delayed(pool_workqueue)
   - 唤醒worker_pool的任务?? 
   > wake_up_worker(pool_workqueue->worker_pool)
   - 如果上面freeze检查不满足, 仅设置pool_workqueue->max_active = 0

** init_pwq(pool_workqueue, workqueue_struct, worker_pool)
   - 初始化pool_workqueue
   - 设定pool_workqueue->worker_pool, workqueue_struct
   - 设定pool_workqueue->unbound_release_work, 释放自己? 

** link_pwq(pool_workqueue)
   - 设置pool_workqueue->work_color = workqueue_struct->work_color
   - 调整max_active? 
   > pwq_adjust_max_active(pool_workqueue)
   - 把pool_workqueue->pwqs_node放到workqueue_struct->pwqs

** alloc_unbound_pwq(workqueue_struct, workqueue_attrs)
   - 构造pool_workqueue
   - 先根据workqueue_attrus找到worker_pool
   > get_unbound_pool(workqueue_attrs)
   - 初始化 
   > init_pwq(pool_workqueue, workqueue_struct, worker_pool)

** free_unbound_pwq(pool_workqueue)
   - 释放pool_workqueue, 首先是worker_pool 
   > put_unbound_pool(pool_workqueue->worker_pool)
   - 然后是自己 
   > kmem_cache_free(pwq_cache, pool_workqueue)

** wq_calc_node_cpumask(workqueue_attrs, node, cpu_going_down, cpumask)
   - 计算workqueue可以使用的cpumask?
   - 如果不使用numa? 
   - wq_numa_enable==0, 或者workqueue_attrs->no_numa!=0, 直接使用workqueue_attrs->cpumask
   - 否则 计算node对应的cpumask 
   > cpumask_and(cpumask, cpumask_of_node(node), workqueue_attrs->cpumask)
   - 去掉cpu_goding_down中的cpumask 
   > cpumask_clear_cpu(cpu_going_down, cpumask)
   - 然后使用wq_numa_possible_cpumask[node]过滤
   > cpumask_add(cpumask, workqueue_attrs->cpumask, wq_numa_possible_cpumask[node])

** numa_pwq_tlb_install(workqueue_struct, node, pool_workqueue)
   - 把pool_workqueue放到workqueue_struct中?
   > link_pwq(pool_workqueue)
   - 设置workqueue_struct->numa_pwq_tbl[node] = pool_workqueue

** apply_workqueue_attrs(workqueue_struct, workqueue_attrs)
   - 设置unbound的workqueue_struct?
   - 如果workqueue_struct->flags没有WQ_UNBOUND, 返回-EINVAL
   - 构造pool_workqueue数组, 长度是wq_numa_tbl_len, 全局变量
   - 构造workqueue_attrs, 保存参数workqueue_attrs
   > alloc_workqueue_attrs(GFP_KERNEL)
   > copy_workqueue_attrs(new_attrs, attrs)
   - 先准备一个默认的pool_workqueue 
   > alloc_unbound_pwq(workqueue_struct, workqueue_attrs)
   - 遍历所有的node
   - 如果它的cpu可用? 
   > wq_calc_node_cpumask(workqueue_struct, node, -1, workqueue_attrs->cpumask)
   - 为node分配一个专用的pool_workqueue 
   > alloc_unbound_pwq(workqueue_struct, workqueue_attrs)
   - 否则使用默认的pool_workqueue
   - 然后把上面的构造的pool_workqueue数组更新给workqueue_struct 
   > numa_pwq_tbl_install(workqueue_struct, node, pwq_tlb[node])
   - 把默认的pool_workqueue放到哪里? 
   > link_pwq(default_pool_workqueue)
   
** wq_update_unbound_numa(workqueue_struct, cpu, online)
   - 在cpu热插拔之后，更新numa affinity?
   - 如果没有使用numa affinity, 直接返回
   - wq_numa_enable==0 
   - 或者 workqueue_struct->flags没有WQ_UNBOUND, 为什么是Unbound?
   - 或者workqueue_struct->unbound_attrs->no_numa !=0
   - 使用workqueue_struct->unbound_attrs更新?
   > copy_workqueue_attrs(workqueue_attrs, workqueue_struct->unbound_attrs)
   - 找到workqueue_struct->numa_pwq_tbl中node对应的pool_workqueue
   > unbound_pwq_by_node(workqueue_struct, node)
   - 重新计算cpumask 
   > wq_calc_node_cpumask(workqueue_struct->unbound_attrs, node, cpu_off, cpumask)
   - 如果cpumask和现在的一样, 直接返回
   > cpumask(cpumask, pool_workqueue->worker_pool->workqueue_attrs->cpumask)
   - 重新构造新的pool_workqueue 
   > alloc_unbound_pwq(workqueue_struct, workqueue_struct)
   - 给workqueue_struct 
   > numa_pwq_tbl_install(workqueue_struct, node, pool_workqueue)
   
** alloc_and_link_pwqs(workqueue_struct)
   - 为workqueue_struct创建pool_workqueue?
   - 如果workqueue_struct->flags没有WQ_UNBOUND
   - 创建cpu专有的pool_workqueue 
   - 遍历所有的cpu, 使用cpu_pools初始化pool_workqueue?
   > init_pwq(pool_workqueue, workqueue_struct, cpu_pools[highpri]
   > link_pwq(pool_workqueue)
   - 如果有WQ_UNBOUND, 使用workqueue_attrs创建? 
   > apply_workqueue_attrs(workqueue_struct, unbound_std_wq_attrs[highpri])

** wq_clamp_max_active(max_active, flags, name)
   - 过滤max_active, 使他在一个范围内
   - 如果flags有WQ_UNBOUND, 范围是(1, WQ_UNBOUND_MAX_ACTIVE)
   - 否则是(1, WQ_MAX_ACTIVE)

** __alloc_workqueue_key(fmt, flags, max_active, key, lock_name, ..)
   - 创建workqueue_struct?
   - 如果flags有WQ_POWER_EFFICIENT, 而且wq_power_efficient有效,
   - 设置flags的WQ_UNBOUND
   - 如果flags有WQ_UNBOUND, 使用numa的pool_workqueue?
   - 而且使用unbound_attrs 
   > alloc_workqueue_attrs(GFP_KERNEL)
   - 创建pool_workqueue 
   > alloc_and_link_pwqs(workqueue_struct)
   - 如果flags有WQ_MEM_RECLAIM, 创建rescuer?
   - 表示会在回收内存时使用
   - 把创建的worker给workqueue_struct->rescuer
   - 设置每个pool_workqueue的max_active 
   > pwq_adjust_max_active(pool_workqueue)

** destroy_workqueue(workqueue_struct)
   - flush所有的work_struct 
   > drain_workqueue(workqueue_struct)
   - 检查workqueue是否可释放
   - 遍历所有的pool_workqueue, 其中的每个work_color,没有work_struct 
   - pool_workqueue->nr_in_flight[i] == 0
   - 关闭rescuer 
   > kthread_stop(workqueue_struct->rescuer->task)
   - 释放所有的pool_workqueue

** workqueue_set_max_active(workqueue_struct, max_active)
   - 设定workqueue_struct->saved_max_active
   - 首先修改到特定的范围内 
   > wq_clamp_max_active(max_active, workqueue_struct->flags, workqueue_struct->name)
   - 调整每个pool_workqueue的max_active 
   > pwq_adjust_max_active(pool_workqueue)
   
** current_is_workqueue_rescuer()
   - 获取当前的worker, worker->rescue_wq不是NULL
   > current_wq_worker()

** workqueue_congested(cpu, workqueue_struct)
   - workqueue在某个cpu上阻塞?
   - 如果参数cpu是WQ_CPU_UNBOUND, 使用当前cpu 
   > smp_processor_id()
   - 根据cpu获取pool_workqueue
   - 如果workqueue_struct->flags没有WQ_UNBOUND, 之用percpu变量
   - per_cpu_ptr(workqueue_struct->cpu_pwqs, cpu)
   - 否则是workqueue_struct->numa_pwq_tlb
   > unbound_pwq_by_node(workqueue_struct, cpu_to_node(cpu))
   - 检查pool_workqueue->delayed_works链表, 如果不是空就是congested? 

** work_busy(work_struct)
   - 检查work_struct是否在等待或工作中
   - 首先是等待中, work_struct->data有WORK_STRUCT_PENDING_BIT
   - 返回WORK_BUSY_PENDING
   > work_pending(work_struct)
   - 查找是否有使用的worker, 返回WORK_BUSY_RUNNING
   > get_work_pool(work_struct)
   > find_worker_executing_work(worker_pool, work_struct)

** set_worker_desc(fmt, ..)
   - 格式化到worker->desc
   - 设定worker->desc_valid = true

** wq_unbind_fn(work_struct)
   - 在cpu热插拔时,使worker调度到其他cpu?
   - 遍历当前cpu上面的所有worker_pool, 根据cpu_worker_pools全局变量
   > smp_processor_id() 
   - 遍历所有的worker, 设置worker->flags的WORKER_UNBOUND
   - 根据worker_pool->worker_idr索引遍历
   - 设置worker_pool->flags的POOL_DISASSOCIATED标志
   - 设置worker_pool->nr_running = 0, 有什么影响?
   - 唤醒worker_pool的任务 
   > wake_up_worker(worker_pool)

** rebind_workers(worker_pool)
   - 把worker_pool的所有worker绑定都某个cpu上
   - 遍历worker_pool的所有worker
   - 设置worker->task的cpumask 
   > set_cpus_allowed_ptr(worker->task, worker_pool->workqueue_attrs->cpumask)
   - 再次遍历worker
   - 如果worker->flags有WORKER_IDLE, 唤醒他们 
   > wake_up_process(worker->task)
   - 设置worker->flags的WORKER_REBOUND, 去掉WORKER_UNBOUND标志

** restore_unbound_workers_cpumask(worker_pool, cpu)
   - 如果cpu不在worker_pool->workqueue_attrs->cpumask中
   - 直接退出 
   > cpumask_test_cpu(cpu, worker_pool->workqueue_attrs->cpumask)
   - 重新计算cpumask? 哪里更新的cpu_online_mask?
   > cpumask_and(cpumask, worker_pool->workqueue_attrs->cpumask, cpu_online_mask)
   - 上面计算了cpumask也没有使用?
   - 遍历worker_pool的所有worker 
   > set_cpus_allowed_ptr(worker->task, worker_pool->workqueue_attrs->cpumask)

** workqueue_cpu_up_callback(notifier_block, active, hcpu)
   - 处理cpu事件?
   - 如果是CPU_UP_PREPARE事件, 遍历所有的worker_pool, 启动worker 
   > craete_and_start_worker(worker_pool)
   - 如果是CPU_ONLINE事件, 遍历所有的worker_pool
   - 如果worker_pool->cpu是当前cpu
   - 去掉worker_pool->flags的POOL_DISASSOCIATED
   > rebind_workers(worker_pool)
   - 否则worker_pool->cpu <0 
   > restore_unbound_workers_cpumask(worker_pool, cpu)
   - 最后遍历所有的workqueue_struct 
   > wq_update_unbound_numa(workqueue_struct, cpu, true)

** workqueue_cpu_down_callback(notifier_block, action, hcpu)
   - 处理CPU_DOWN_PREPARE事件
   - 构造work_struct, 使用wq_unbind_fn 
   - 提交work_struct到system_highpri_wq中
   > queue_work_on(cpu, system_highpri_wq, unbind_work)
   - 使用work_struct实现unbind操作
   - 遍历workqueue_struct 
   > wq_update_unbound_numa(workqueue_struct, cpu, false)
   - 等待上面提交的work_struct 
   > flush_work(unbind_work)

** work_for_cpu 
   #+BEGIN_SRC 
	struct work_struct work;
	long (*fn)(void *);
	void *arg;
	long ret;   
   #+END_SRC

** work_for_cpu_fn(work_struct) 
   - 执行上面的操作, 结果放到work_for_cpu->ret
   - work_for_cpu->fn(work_for_cpu->arg)

** work_on_cpu(cpu, fn, arg)
   - 构造work_for_cpu, 提交work_struct, 让它在cpu上执行 
   > schedule_work_on(cpu, work_for_cpu->work_struct)
   - 等待提交的work_struct 
   > __flush_work(work_for_cpu->work_struct)
   - 最后返回work_for_cpu->ret

** freeze_workqueues_begin() 
   - 暂定workqueue的所有任务?
   - 以后所有的work_struct都会提交给delayed_works队列,而不是worker_pool->worklist队列
   - 设置workqueue_freezing = true, 全局变量
   - 遍历所有的worker_pool, 设置worker_pool->flags的POOL_FREEZING
   - 遍历所有的workqueue_struct, 所有的pool_workqueue
   - 重新调整max_active ? 
   > pwq_adjust_max_active(pool_workqueue)

** freeze_workqueues_busy()
   - 检查可暂停的workqueue是否还工作?
   - 遍历所有的workqueue_struct, 只处理可暂定的 
   - workqueue_struct->flags有WQ_FREEZABLE
   - 遍历pool_workqueue, 检查pool_workqueue->nr_active!=0
   - 表示还有运行的work_struct ?? 

** thaw_workqueues()
   - 恢复暂停的workqueue_struct
   - 遍历所有的worker_pool, 去掉worker_pool->flags的POOL_FREEZING
   - 同样遍历workqueue_struct和pool_workqueue 
   > pwq_adjust_max_active(pool_workqueue)

** wq_numa_init()
   - 这是系统启动时的初始化函数
   - 首先计算numa节点个数, wq_numa_tbl_len
   - 创建默认的workqueue_attrs?  wq_update_unbound_numa_attrs_buf
   > alloc_workqueue_attrs(GFP_KERNEL)
   - 准备wq_numa_possible_cpumask, 这是cpumask数组, 长度是wq_numa_tbl_len

** init_workqueues()
   - 注册cpu热插拔事件
   > cpu_notifier(workqueue_cpu_up_callback, CPU_PRI_WORKQUEUE_UP)
   > hotcpu_notifier(workqueue_cpu_down_callback, CPU_PRI_WORKQUEUE_DOWN)
   - 初始化numa参数  
   > wq_numa_init()
   - 初始化worker_pool?
   - 遍历cpu, 以及每个cpu的cpu_worker_pool[NR_STD_WORKER_POOLS]数组
   - 每个cpu有2个worker_pool?
   - 创建worker_pool 
   > init_worker_pool(worker_pool)
   - 设置worker_pool->cpu = cpu, node
   - 设置worker_pool->workqueue_attrs->cpumask
   > cpumask_copy(worker_pool->workqueue_attrs->cpumask, cpumask_of(cpu))
   - 设置worker_pool->workqueue_attrs->nice = std_nice[i]
   - 2个worker_pool对应2个nice: 0和HIGHPRI_NICE_LEVEL
   - 分配全局的id 
   > worker_pool_assign_id(worker_pool)
   - 再次遍历所有的worker_pool
   - 去掉worker_pool->flags的POOL_DISASSOCIATED, 启动他们 
   > create_and_start_worker(worker_pool)
   - 准备全局变量unbound_std_wq_attrs, 同样是2个workqueue_attrs, 和每个cpu有2个worker_pool对应
   > alloc_workqueue_attrs(GFP_KERNEL)
   - 设定workqueue_attrs->nice = 0, HIGHPRI_NICE_LEVEL
   - 最后创建多个workqueue_struct
   - system_wq, system_highpri_wq, system_long_wq, system_unbound_wq
   - system_freezable_wq, system_power_efficient_wq
   - system_power_efficient_wq, system_freezable_power_efficient_wq
   - 这些都谁使用??

